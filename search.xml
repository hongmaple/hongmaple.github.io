<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java空指针异常</title>
      <link href="/posts/7636008d/"/>
      <url>/posts/7636008d/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-什么是空指针"><a href="#1-什么是空指针" class="headerlink" title="1.什么是空指针"></a>1.什么是空指针</h2><p>指针只存在于c语言中，Java中是没有指针的，空指针就是空引用，java空指针异常就是引用本身为空，却调用了方法，这个时候就会出现空指针异常。可以理解，成员变量和方法是属于对象的（除去静态），在对象中才存在相对应的成员变量和方法，然后通过对象去调用这些成员变量和方法。对于空指针来说，它不指向任何对象，也就没有所谓的成员变量和方法，这个时候用它去调用某些属性和方法，当然会出现空指针异常。下面这个例子可以看我的上一篇随笔（1）</p><p>   for(int i=0;i&lt;arr.length;i++){</p><p>  arr[i] = new Student(); //这句容易丢</p><p>  请输入java成绩：</p><p>  arr[i].javascore=input.nextInt();  //NullPointerException</p><p>   请输入数学成绩</p><p>  arr[i].mathScore= input.nextInt();</p><p>   请输入sql成绩：</p><p>  arr[i].sqlScore = input.nextInt(）；</p><p> }</p><p>如果arr【i】没有实例化，由于空指针调用了不属于的JavaScore这个属性，程序终止，报告空指针异常。</p><p>下面我贴出一个网上的代码：</p><p>public class Test {</p><p>  private int a=1;</p><p>  private int b=2;</p><p>  public static void main(String[] args) {</p><p>​    // TODO Auto-generated method stub</p><p>​    Test t1 = new Test();</p><p>​    Test t2 = null;</p><p>​    System.out.println(t1.a);</p><p>​    System.out.println(t2.a);</p><p>​    System.out.println(t2.c());</p><p>  }</p><p>  public String c(){</p><p>​    return “123”;</p><p>  }</p><p>}</p><p>我们分析上面这段示例代码，在Test类中，有两个成员变量a和b，和一个方法c()。然后在main()方法中，我们创建了两个对象t1和t2，其中t1指向通过构造方法实例出的Test对象，而t2只是声明，并指向了空，并没有指向实际的对象。调试的时候，第一条输出语句是可以通过编译的，而执行到第二条输出语句的时候，由于空指针调用了不属于它的a，程序终止，报告空指针异常。同样，注释第二条输出语句，程序在执行到第三条输出语句的时候，由于调用了不属于它的c()方法，会出现一样的错误。</p><h2 id="2-如何处理解决空指针异常"><a href="#2-如何处理解决空指针异常" class="headerlink" title="2.如何处理解决空指针异常"></a>2.如何处理解决空指针异常</h2><h3 id="报空指针异常的原因"><a href="#报空指针异常的原因" class="headerlink" title="报空指针异常的原因"></a>报空指针异常的原因</h3><p>字符串变量未初始化； </p><p>接口类型的对象没有用具体的类初始化，比如： </p><p>List it；会报错 </p><p>List it = new ArrayList()；则不会报错了 </p><p>3当一个对象的值为空时，你没有判断为空的情况。</p><p>实际开发中，大多数的空指针异常主要与对象的操作相关。 </p><p>  下面列出可能发生空指针异常的几种情况及相应解决方案： </p><p>  代码段1： </p><p>　　out.println(request.getParameter(“username”)); </p><p>　　分析：代码段1的功能十分简单，就是输出用户输入”username”的值。 </p><p>说明：看上去，上面的语句找不出什么语法错误，而且在大多数情况下也遇不到什么问题。但是，如果某个用户在输入数据时并没有提供表单 域”username” 的值，或通过某种途径绕过表单直接输入时，此request.getParameter(“username”)的值为空（注意不是空字符串，是空对象 null。），out对象的println方法是无法直接对空对象操作的，因此代码段1所在的JSP页面将会抛出 “Java.lang.NullPointerException”异常。而且即使对象可能为空时，也调用Java.lang.Object或 Object对象本身的一些方法如toString()， equal(Object obj)等操作。 </p><p>  代码段2： </p><p>　　String userName = request.getParameter(“username”); </p><p>　　If (userName.equals(“root”)) </p><p>　　{….} </p><p>分析：代码段2的功能是检测用户提供的用户名，如果是用户名称为”root”的用户时，就执行一些特别的操作。 </p><p>说明：在代码段2中，如果有用户没有提供表单域”username”的值时，字符串对象userName为null值，不能够将一个null的对象与另一 个对象直接比较，同样，代码段2所在的JSP页面就会抛空指针错误。 </p><p>一个小技巧：如果要把某个方法的返回值与常量做比较，把常量放在前面，可以避免调用null对象的equals方法。譬如： </p><p>  If (“root”.equals(userName)) </p><p>{….} </p><p>即使userName对象返回了null对象，这里也不会有空指针异常，可以照常运转。 </p><p>  代码段3： </p><p>　　String userName = session.getAttribute(“session.username”).toString(); </p><p>​    分析：代码段3的功能是将session中session.username的值取出，并将该值赋给字符串对象userName。 </p><p>说明：在一般情况下，如果在用户已经进行某个会话，则不会出现什么问题；但是，如果此时应用服务器重新启动，而用户还没有重新登录，（也可能是用户关闭浏 览器，但是仍打开原来的页面。）那么，此时该session的值就会失效，同时导致session中的session.username的值为空。对一个 为 null的对象的直接执行toString()操作，就会导致系统抛出空指针异常。 </p><p>  代码段4： </p><p>public static void main(String args[]){ </p><p>Person p=null; </p><p>p.setName(“张三”)； </p><p>System.out.println(p.getName()); </p><p>} </p><p>分析：声明一个Person对象，并打印出该对象的中的Name名字。 </p><p>说明：这个时候你的p就出现空指针异常，因为你只是声明了这个Person类型的对象并没有创建对象，所以它的堆里面没有地址引用，切忌你要用对 象掉用方法的时候一定要创建对象。</p>]]></content>
      
      
      <categories>
          
          <category> JavaBug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaException </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAD反编译tricks</title>
      <link href="/posts/f7e7625a/"/>
      <url>/posts/f7e7625a/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><p><a href="https://varaneckas.com/jad/" target="_blank" rel="noopener">jad</a>反编译工具，已经不再更新，且只支持JDK1.4，但并不影响其强大的功能。</p><p>基本用法：<code>jad xxx.class</code>，会生成直接可读的xxx.jad文件。</p><h2 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h2><p>对于基本类型和包装类型之间的转换，通过xxxValue()和valueOf()两个方法完成自动拆装箱，使用jad进行反编译可以看到该过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="keyword">new</span> Integer(<span class="number">10</span>);  <span class="comment">// 自动拆箱</span></span><br><span class="line">    Integer y = x;            <span class="comment">// 自动装箱</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = (<span class="keyword">new</span> Integer(<span class="number">10</span>)).intValue();   <span class="comment">// intValue()拆箱</span></span><br><span class="line">        Integer integer = Integer.valueOf(i);   <span class="comment">// valueOf()装箱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="foreach语法糖"><a href="#foreach语法糖" class="headerlink" title="foreach语法糖"></a>foreach语法糖</h2><p>在遍历迭代时可以foreach语法糖，对于数组类型直接转换成for循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始代码</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> item: arr) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反编译后代码</span></span><br><span class="line"><span class="keyword">int</span> ai[] = &#123;</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> ai1[] = ai;</span><br><span class="line"><span class="keyword">int</span> i = ai1.length;</span><br><span class="line"><span class="comment">// 转换成for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> k = ai1[j];</span><br><span class="line">    System.out.println(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于容器类的遍历会使用iterator进行迭代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList arraylist = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        arraylist.add(Integer.valueOf(<span class="number">1</span>));</span><br><span class="line">        arraylist.add(Integer.valueOf(<span class="number">2</span>));</span><br><span class="line">        arraylist.add(Integer.valueOf(<span class="number">3</span>));</span><br><span class="line">        Integer integer;</span><br><span class="line">        <span class="comment">// 使用的for循环+Iterator，类似于链表迭代：</span></span><br><span class="line">        <span class="comment">// for (ListNode cur = head; cur != null; System.out.println(cur.val))&#123;</span></span><br><span class="line">        <span class="comment">//     cur = cur.next;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(Iterator iterator = arraylist.iterator(); iterator.hasNext(); System.out.println(integer))</span><br><span class="line">            integer = (Integer)iterator.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Arrays-asList-T…"><a href="#Arrays-asList-T…" class="headerlink" title="Arrays.asList(T…)"></a>Arrays.asList(T…)</h2><p>熟悉Arrays.asList(T…)用法的小伙伴都应该知道，asList()方法传入的参数不能是基本类型的数组，必须包装成包装类型再使用，否则对应生成的列表的大小永远是1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    Integer[] arr2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    List lists1 = Arrays.asList(arr1);</span><br><span class="line">    List lists2 = Arrays.asList(arr2);</span><br><span class="line">    System.out.println(lists1.size()); <span class="comment">// 1</span></span><br><span class="line">    System.out.println(lists2.size()); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从反编译结果来解释，为什么传入基本类型的数组后，返回的List大小是1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反编译后文件</span></span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ai[] = &#123;</span><br><span class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 使用包装类型，全部元素由int包装为Integer</span></span><br><span class="line">        Integer ainteger[] = &#123;</span><br><span class="line">            Integer.valueOf(<span class="number">1</span>), Integer.valueOf(<span class="number">2</span>), Integer.valueOf(<span class="number">3</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意这里被反编译成二维数组，而且是一个1行三列的二维数组</span></span><br><span class="line">        <span class="comment">// list.size()当然返回1</span></span><br><span class="line">        List list = Arrays.asList(<span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; ai &#125;);</span><br><span class="line">        List list1 = Arrays.asList(ainteger);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">        System.out.println(list1.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面结果可以看到，传入基本类型的数组后，会被转换成一个二维数组，而且是<strong>new int[1][arr.length]</strong>这样的数组，调用list.size()当然返回1。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>Java中的类、接口、枚举、注解都可以看做是类类型。使用jad来看一下@interface被转换成什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Foo&#123;</span><br><span class="line">  String[] value();</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看反编译代码可以看出：</p><ul><li>自定义的注解类Foo被转换成接口Foo，并且继承Annotation接口</li><li>原来自定义接口中的value()和bar()被转换成抽象方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Annotation</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String[] value();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解通常和反射配合使用，而且既然自定义的注解最终被转换成接口，注解中的属性被转换成接口中的抽象方法，那么通过反射之后拿到接口实例，在通过接口实例自然能够调用对应的抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Foo</span>(value=&#123;<span class="string">"sherman"</span>, <span class="string">"decompiler"</span>&#125;, bar=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Foo foo = Demo<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotation</span>(<span class="title">Foo</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        System.out.println(Arrays.toString(foo.value())); <span class="comment">// [sherman, decompiler]</span></span><br><span class="line">        System.out.println(foo.bar());                    <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>通过jad反编译可以很好地理解枚举类。</p><h3 id="空枚举"><a href="#空枚举" class="headerlink" title="空枚举"></a>空枚举</h3><p>先定义一个空的枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> DummyEnum &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用jad反编译查看结果：</p><ul><li>自定义枚举类被转换成final类，并且继承Enum</li><li>提供了两个参数（name，odinal）的私有构造器，并且调用了父类的构造器。注意即使没有提供任何参数，也会有该该构造器，其中name就是枚举实例的名称，odinal是枚举实例的索引号</li><li>初始化了一个private static final自定义类型的空数组 <strong>$VALUES</strong></li><li>提供了两个public static方法：<ul><li>values()方法通过clone()方法返回内部$VALUES的浅拷贝。这个方法结合私有构造器可以完美实现单例模式，想一想values()方法是不是和单例模式中getInstance()方法功能类似</li><li>valueOf(String s)：调用父类Enum的valueOf方法并强转返回</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DummyEnum</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">// 功能和单例模式的getInstance()方法相同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DummyEnum[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (DummyEnum[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 调用父类的valueOf方法，并墙砖返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DummyEnum <span class="title">valueOf</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (DummyEnum)Enum.valueOf(DummyEnum, s);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 默认提供一个私有的私有两个参数的构造器，并调用父类Enum的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DummyEnum</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 初始化一个private static final的本类空数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DummyEnum $VALUES[] = <span class="keyword">new</span> DummyEnum[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="包含抽象方法的枚举"><a href="#包含抽象方法的枚举" class="headerlink" title="包含抽象方法的枚举"></a>包含抽象方法的枚举</h3><p>枚举类中也可以包含抽象方法，但是必须定义枚举实例并且立即重写抽象方法，就像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> DummyEnum &#123;</span><br><span class="line">    DUMMY1 &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dummyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"[1]: implements abstract method in enum class"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    DUMMY2 &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dummyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"[2]: implements abstract method in enum class"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">dummyMethod</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来反编译看看有哪些变化：</p><ul><li>原来final class变成了abstract class：这很好理解，有抽象方法的类自然是抽象类</li><li>多了两个public static final的成员DUMMY1、DUMMY2，这两个实例的初始化过程被放到了static代码块中，并且实例过程中直接重写了抽象方法，类似于匿名内部类的形式。</li><li>数组<strong>$VALUES[]</strong>初始化时放入枚举实例</li></ul><p>还有其它变化么？</p><p>在反编译后的DummyEnum类中，是存在抽象方法的，而枚举实例在静态代码块中初始化过程中重写了抽象方法。在Java中，抽象方法和抽象方法重写同时放在一个类中，只能通过内部类形式完成。因此上面第二点应该说成就是以内部类形式初始化。</p><p>可以看一下DummyEnum.class存放的位置，应该多了两个文件：</p><ul><li>DummyEnum$1.class</li><li>DummyEnum$2.class</li></ul><p>Java中.class文件出现$符号表示有内部类存在，就像OutClass$InnerClass，这两个文件出现也应证了上面的匿名内部类初始化的说法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DummyEnum</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DummyEnum[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (DummyEnum[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DummyEnum <span class="title">valueOf</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (DummyEnum)Enum.valueOf(DummyEnum, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DummyEnum</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">dummyMethod</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个pubic static final实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DummyEnum DUMMY1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DummyEnum DUMMY2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DummyEnum $VALUES[];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// static代码块进行初始化</span></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        DUMMY1 = <span class="keyword">new</span> DummyEnum(<span class="string">"DUMMY1"</span>, <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dummyMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"[1]: implements abstract method in enum class"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">;</span><br><span class="line">        DUMMY2 = <span class="keyword">new</span> DummyEnum(<span class="string">"DUMMY2"</span>, <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dummyMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"[2]: implements abstract method in enum class"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">;</span><br><span class="line"><span class="comment">// 对本类数组进行初始化</span></span><br><span class="line">        $VALUES = (<span class="keyword">new</span> DummyEnum[] &#123;</span><br><span class="line">            DUMMY1, DUMMY2</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正常的枚举类"><a href="#正常的枚举类" class="headerlink" title="正常的枚举类"></a>正常的枚举类</h3><p>实际开发中，枚举类通常的形式是有两个参数（int code，Sring msg）的构造器，可以作为状态码进行返回。Enum类实际上也是提供了包含两个参数且是protected的构造器，这里为了避免歧义，将枚举类的构造器设置为三个，使用jad反编译：</p><p>最大的变化是：现在的private构造器从2个参数变成5个，而且在内部仍然将前两个参数通过super传递给父类，剩余的三个参数才是真正自己提供的参数。可以想象，如果自定义的枚举类只提供了一个参数，最终生成底层代码中private构造器应该有三个参数，前两个依然通过super传递给父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomEnum</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CustomEnum[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (CustomEnum[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CustomEnum <span class="title">valueOf</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (CustomEnum)Enum.valueOf(CustomEnum, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CustomEnum</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j, String s1, Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">        code = j;</span><br><span class="line">        msg = s1;</span><br><span class="line">        data = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> CustomEnum FIRST;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> CustomEnum SECOND;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> CustomEnum THIRD;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CustomEnum $VALUES[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        FIRST = <span class="keyword">new</span> CustomEnum(<span class="string">"FIRST"</span>, <span class="number">0</span>, <span class="number">10010</span>, <span class="string">"first"</span>, Long.valueOf(<span class="number">100L</span>));</span><br><span class="line">        SECOND = <span class="keyword">new</span> CustomEnum(<span class="string">"SECOND"</span>, <span class="number">1</span>, <span class="number">10020</span>, <span class="string">"second"</span>, <span class="string">"Foo"</span>);</span><br><span class="line">        THIRD = <span class="keyword">new</span> CustomEnum(<span class="string">"THIRD"</span>, <span class="number">2</span>, <span class="number">10030</span>, <span class="string">"third"</span>, <span class="keyword">new</span> Object());</span><br><span class="line">        $VALUES = (<span class="keyword">new</span> CustomEnum[] &#123;</span><br><span class="line">            FIRST, SECOND, THIRD</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BIO-NIO-AIO</title>
      <link href="/posts/fc2ac800/"/>
      <url>/posts/fc2ac800/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><p>熟练掌握 BIO,NIO,AIO 的基本概念以及一些常见问题是你准备面试的过程中不可或缺的一部分，另外这些知识点也是你学习 Netty 的基础。</p><h1 id="BIO-NIO-AIO-总结"><a href="#BIO-NIO-AIO-总结" class="headerlink" title="BIO,NIO,AIO 总结"></a>BIO,NIO,AIO 总结</h1><p> Java 中的 BIO、NIO和 AIO 理解为是 Java 语言对操作系统的各种 IO 模型的封装。程序员在使用这些 API 的时候，不需要关心操作系统层面的知识，也不需要根据不同操作系统编写不同的代码。只需要使用Java的API就可以了。</p><p>在讲 BIO,NIO,AIO 之前先来回顾一下这样几个概念：同步与异步，阻塞与非阻塞。</p><p>关于同步和异步的概念解读困扰着很多程序员，大部分的解读都会带有自己的一点偏见。参考了 <a href="https://stackoverflow.com/questions/748175/asynchronous-vs-synchronous-execution-what-does-it-really-mean" target="_blank" rel="noopener">Stackoverflow</a>相关问题后对原有答案进行了进一步完善：</p><blockquote><p>When you execute something synchronously, you wait for it to finish before moving on to another task. When you execute something asynchronously, you can move on to another task before it finishes.</p><p>当你同步执行某项任务时，你需要等待其完成才能继续执行其他任务。当你异步执行某些操作时，你可以在完成另一个任务之前继续进行。</p></blockquote><ul><li><strong>同步</strong> ：两个同步任务相互依赖，并且一个任务必须以依赖于另一任务的某种方式执行。 比如在<code>A-&gt;B</code>事件模型中，你需要先完成 A 才能执行B。 再换句话说，同步调用种被调用者未处理完请求之前，调用不返回，调用者会一直等待结果的返回。</li><li><strong>异步</strong>： 两个异步的任务完全独立的，一方的执行不需要等待另外一方的执行。再换句话说，异步调用种一调用就返回结果不需要等待结果返回，当结果返回的时候通过回调函数或者其他方式拿着结果再做相关事情，</li></ul><p><strong>阻塞和非阻塞</strong></p><ul><li><strong>阻塞：</strong> 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</li><li><strong>非阻塞：</strong> 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。</li></ul><p><strong>如何区分 “同步/异步 ”和 “阻塞/非阻塞” 呢？</strong></p><p>同步/异步是从行为角度描述事物的，而阻塞和非阻塞描述的当前事物的状态（等待调用结果时的状态）。</p><h2 id="1-BIO-Blocking-I-O"><a href="#1-BIO-Blocking-I-O" class="headerlink" title="1. BIO (Blocking I/O)"></a>1. BIO (Blocking I/O)</h2><p>同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。</p><h3 id="1-1-传统-BIO"><a href="#1-1-传统-BIO" class="headerlink" title="1.1 传统 BIO"></a>1.1 传统 BIO</h3><p>BIO通信（一请求一应答）模型图如下(图源网络，原出处不明)：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2.png" alt="传统BIO通信模型图"></p><p>采用 <strong>BIO 通信模型</strong> 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在<code>while(true)</code> 循环中服务端会调用 <code>accept()</code> 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接，如上图所示。</p><p>如果要让 <strong>BIO 通信模型</strong> 能够同时处理多个客户端请求，就必须使用多线程（主要原因是<code>socket.accept()</code>、<code>socket.read()</code>、<code>socket.write()</code> 涉及的三个主要函数都是同步阻塞的），也就是说它在接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的 <strong>一请求一应答通信模型</strong> 。我们可以设想一下如果这个连接不做任何事情的话就会造成不必要的线程开销，不过可以通过 <strong>线程池机制</strong> 改善，线程池还可以让线程的创建和回收成本相对较低。使用<code>FixedThreadPool</code> 可以有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了N(客户端请求数量):M(处理客户端请求的线程数量)的伪异步I/O模型（N 可以远远大于 M），下面一节”伪异步 BIO”中会详细介绍到。</p><p><strong>我们再设想一下当客户端并发访问量增加后这种模型会出现什么问题？</strong></p><p>在 Java 虚拟机中，线程是宝贵的资源，线程的创建和销毁成本很高，除此之外，线程的切换成本也是很高的。尤其在 Linux 这样的操作系统中，线程本质上就是一个进程，创建和销毁线程都是重量级的系统函数。如果并发访问量增加会导致线程数急剧膨胀可能会导致线程堆栈溢出、创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。</p><h3 id="1-2-伪异步-IO"><a href="#1-2-伪异步-IO" class="headerlink" title="1.2 伪异步 IO"></a>1.2 伪异步 IO</h3><p>为了解决同步阻塞I/O面临的一个链路需要一个线程处理的问题，后来有人对它的线程模型进行了优化一一一后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M：线程池最大线程数N的比例关系，其中M可以远远大于N.通过线程池可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。</p><p>伪异步IO模型图(图源网络，原出处不明)：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/3.png" alt="伪异步IO模型图"></p><p>采用线程池和任务队列可以实现一种叫做伪异步的 I/O 通信框架，它的模型图如上图所示。当有新的客户端接入时，将客户端的 Socket 封装成一个Task（该任务实现java.lang.Runnable接口）投递到后端的线程池中进行处理，JDK 的线程池维护一个消息队列和 N 个活跃线程，对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。</p><p>伪异步I/O通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题。不过因为它的底层仍然是同步阻塞的BIO模型，因此无法从根本上解决问题。</p><h3 id="1-3-代码示例"><a href="#1-3-代码示例" class="headerlink" title="1.3 代码示例"></a>1.3 代码示例</h3><p>下面代码中演示了BIO通信（一请求一应答）模型。我们会在客户端创建多个线程依次连接服务端并向其发送”当前时间+:hello world”，服务端会为每个客户端线程创建一个线程来处理。代码示例出自闪电侠的博客，原地址如下：        </p><p><a href="https://www.jianshu.com/p/a4e03835921a" target="_blank" rel="noopener">https://www.jianshu.com/p/a4e03835921a</a></p><p><strong>客户端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 闪电侠</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年10月14日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO 创建多个线程，模拟多个客户端连接服务端</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">3333</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.getOutputStream().write((<span class="keyword">new</span> Date() + <span class="string">": hello world"</span>).getBytes());</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 闪电侠</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年10月14日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// TODO 服务端处理客户端连接请求</span></span><br><span class="line">    ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">3333</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 阻塞方法获取新的连接</span></span><br><span class="line">          Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 每一个新的连接都创建一个线程，负责读取数据</span></span><br><span class="line">          <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">int</span> len;</span><br><span class="line">              <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">              InputStream inputStream = socket.getInputStream();</span><br><span class="line">              <span class="comment">// 按字节流方式读取数据</span></span><br><span class="line">              <span class="keyword">while</span> ((len = inputStream.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(data, <span class="number">0</span>, len));</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><p>在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p><h2 id="2-NIO-New-I-O"><a href="#2-NIO-New-I-O" class="headerlink" title="2. NIO (New I/O)"></a>2. NIO (New I/O)</h2><h3 id="2-1-NIO-简介"><a href="#2-1-NIO-简介" class="headerlink" title="2.1 NIO 简介"></a>2.1 NIO 简介</h3><p> NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。</p><p>NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。</p><h3 id="2-2-NIO的特性-NIO与IO区别"><a href="#2-2-NIO的特性-NIO与IO区别" class="headerlink" title="2.2 NIO的特性/NIO与IO区别"></a>2.2 NIO的特性/NIO与IO区别</h3><p>如果是在面试中回答这个问题，我觉得首先肯定要从 NIO 流是非阻塞 IO 而 IO 流是阻塞 IO 说起。然后，可以从 NIO 的3个核心组件/特性为 NIO 带来的一些改进来分析。如果，你把这些都回答上了我觉得你对于 NIO 就有了更为深入一点的认识，面试官问到你这个问题，你也能很轻松的回答上来了。</p><h4 id="1-Non-blocking-IO（非阻塞IO）"><a href="#1-Non-blocking-IO（非阻塞IO）" class="headerlink" title="1)Non-blocking IO（非阻塞IO）"></a>1)Non-blocking IO（非阻塞IO）</h4><p><strong>IO流是阻塞的，NIO流是不阻塞的。</strong></p><p>Java NIO使我们可以进行非阻塞IO操作。比如说，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</p><p>Java IO的各种流是阻塞的。这意味着，当一个线程调用 <code>read()</code> 或  <code>write()</code> 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了</p><h4 id="2-Buffer-缓冲区"><a href="#2-Buffer-缓冲区" class="headerlink" title="2)Buffer(缓冲区)"></a>2)Buffer(缓冲区)</h4><p><strong>IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。</strong></p><p>Buffer是一个对象，它包含一些要写入或者要读出的数据。在NIO类库中加入Buffer对象，体现了新库与原I/O的一个重要区别。在面向流的I/O中·可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。</p><p>在NIO厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。</p><p>最常用的缓冲区是 ByteBuffer,一个 ByteBuffer 提供了一组功能用于操作 byte 数组。除了ByteBuffer,还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean类型）都对应有一种缓冲区。</p><h4 id="3-Channel-通道"><a href="#3-Channel-通道" class="headerlink" title="3)Channel (通道)"></a>3)Channel (通道)</h4><p>NIO 通过Channel（通道） 进行读写。</p><p>通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。</p><h4 id="4-Selector-选择器"><a href="#4-Selector-选择器" class="headerlink" title="4)Selector (选择器)"></a>4)Selector (选择器)</h4><p>NIO有选择器，而IO没有。</p><p>选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/Slector.png" alt="一个单线程中Selector维护3个Channel的示意图"></p><h3 id="2-3-NIO-读数据和写数据方式"><a href="#2-3-NIO-读数据和写数据方式" class="headerlink" title="2.3  NIO 读数据和写数据方式"></a>2.3  NIO 读数据和写数据方式</h3><p>通常来说NIO中的所有IO都是从 Channel（通道） 开始的。</p><ul><li>从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。</li><li>从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。</li></ul><p>数据读取和写入操作图示：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/NIO%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F.png" alt="NIO读写数据的方式"></p><h3 id="2-4-NIO核心组件简单介绍"><a href="#2-4-NIO核心组件简单介绍" class="headerlink" title="2.4 NIO核心组件简单介绍"></a>2.4 NIO核心组件简单介绍</h3><p>NIO 包含下面几个核心的组件：</p><ul><li>Channel(通道)</li><li>Buffer(缓冲区)</li><li>Selector(选择器)</li></ul><p>整个NIO体系包含的类远远不止这三个，只能说这三个是NIO体系的“核心API”。我们上面已经对这三个概念进行了基本的阐述，这里就不多做解释了。</p><h3 id="2-5-代码示例"><a href="#2-5-代码示例" class="headerlink" title="2.5 代码示例"></a>2.5 代码示例</h3><p>代码示例出自闪电侠的博客，原地址如下：        </p><p><a href="https://www.jianshu.com/p/a4e03835921a" target="_blank" rel="noopener">https://www.jianshu.com/p/a4e03835921a</a></p><p>客户端 IOClient.java 的代码不变，我们对服务端使用 NIO 进行改造。以下代码较多而且逻辑比较复杂，大家看看就好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 闪电侠</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019年2月21日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: NIO 改造后的服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. serverSelector负责轮询是否有新的连接，服务端监测到新的连接之后，不再创建一个新的线程，</span></span><br><span class="line">    <span class="comment">// 而是直接将新连接绑定到clientSelector上，这样就不用 IO 模型中 1w 个 while 循环在死等</span></span><br><span class="line">    Selector serverSelector = Selector.open();</span><br><span class="line">    <span class="comment">// 2. clientSelector负责轮询连接是否有数据可读</span></span><br><span class="line">    Selector clientSelector = Selector.open();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 对应IO编程中服务端启动</span></span><br><span class="line">        ServerSocketChannel listenerChannel = ServerSocketChannel.open();</span><br><span class="line">        listenerChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">3333</span>));</span><br><span class="line">        listenerChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        listenerChannel.register(serverSelector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="comment">// 监测是否有新的连接，这里的1指的是阻塞的时间为 1ms</span></span><br><span class="line">          <span class="keyword">if</span> (serverSelector.select(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Set&lt;SelectionKey&gt; set = serverSelector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">              SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// (1) 每来一个新连接，不需要创建一个线程，而是直接注册到clientSelector</span></span><br><span class="line">                  SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();</span><br><span class="line">                  clientChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                  clientChannel.register(clientSelector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  keyIterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="comment">// (2) 批量轮询是否有哪些连接有数据可读，这里的1指的是阻塞的时间为 1ms</span></span><br><span class="line">          <span class="keyword">if</span> (clientSelector.select(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Set&lt;SelectionKey&gt; set = clientSelector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">              SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  SocketChannel clientChannel = (SocketChannel) key.channel();</span><br><span class="line">                  ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                  <span class="comment">// (3) 面向 Buffer</span></span><br><span class="line">                  clientChannel.read(byteBuffer);</span><br><span class="line">                  byteBuffer.flip();</span><br><span class="line">                  System.out.println(</span><br><span class="line">                      Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  keyIterator.remove();</span><br><span class="line">                  key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么大家都不愿意用 JDK 原生 NIO 进行开发呢？从上面的代码中大家都可以看出来，是真的难用！除了编程复杂、编程模型难之外，它还有以下让人诟病的问题：</p><ul><li>JDK 的 NIO 底层由 epoll 实现，该实现饱受诟病的空轮询 bug 会导致 cpu 飙升 100%</li><li>项目庞大之后，自行实现的 NIO 很容易出现各类 bug，维护成本较高，上面这一坨代码我都不能保证没有 bug</li></ul><p>Netty 的出现很大程度上改善了 JDK 原生 NIO 所存在的一些让人难以忍受的问题。</p><h3 id="3-AIO-Asynchronous-I-O"><a href="#3-AIO-Asynchronous-I-O" class="headerlink" title="3. AIO (Asynchronous I/O)"></a>3. AIO (Asynchronous I/O)</h3><p>AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p>AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。（除了 AIO 其他的 IO 类型都是同步的，这一点可以从底层IO线程模型解释，推荐一篇文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247484746&amp;idx=1&amp;sn=c0a7f9129d780786cabfcac0a8aa6bb7&source=41#wechat_redirect" target="_blank" rel="noopener">《漫话：如何给女朋友解释什么是Linux的五种IO模型？》</a> ）</p><p>查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《Netty 权威指南》第二版</li><li><a href="https://zhuanlan.zhihu.com/p/23488863" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23488863</a> (美团技术团队)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaEE基础知识</title>
      <link href="/posts/6c3aa244/"/>
      <url>/posts/6c3aa244/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><h2 id="Servlet总结"><a href="#Servlet总结" class="headerlink" title="Servlet总结"></a>Servlet总结</h2><p>在Java Web程序中，<strong>Servlet</strong>主要负责接收用户请求 <code>HttpServletRequest</code>,在<code>doGet()</code>,<code>doPost()</code>中做相应的处理，并将回应<code>HttpServletResponse</code>反馈给用户。<strong>Servlet</strong> 可以设置初始化参数，供Servlet内部使用。一个Servlet类只会有一个实例，在它初始化时调用<code>init()</code>方法，销毁时调用<code>destroy()</code>方法<strong>。</strong>Servlet需要在web.xml中配置（MyEclipse中创建Servlet会自动配置），<strong>一个Servlet可以设置多个URL访问</strong>。<strong>Servlet不是线程安全</strong>，因此要谨慎使用类变量。</p><h2 id="阐述Servlet和CGI的区别"><a href="#阐述Servlet和CGI的区别" class="headerlink" title="阐述Servlet和CGI的区别?"></a>阐述Servlet和CGI的区别?</h2><h3 id="CGI的不足之处"><a href="#CGI的不足之处" class="headerlink" title="CGI的不足之处:"></a>CGI的不足之处:</h3><p>1，需要为每个请求启动一个操作CGI程序的系统进程。如果请求频繁，这将会带来很大的开销。</p><p>2，需要为每个请求加载和运行一个CGI程序，这将带来很大的开销 </p><p>3，需要重复编写处理网络协议的代码以及编码，这些工作都是非常耗时的。</p><h3 id="Servlet的优点"><a href="#Servlet的优点" class="headerlink" title="Servlet的优点:"></a>Servlet的优点:</h3><p>1，只需要启动一个操作系统进程以及加载一个JVM，大大降低了系统的开销</p><p>2，如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销</p><p>3，所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。</p><p>4，Servlet能直接和Web服务器交互，而普通的CGI程序不能。Servlet还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。</p><p>补充：Sun Microsystems公司在1996年发布Servlet技术就是为了和CGI进行竞争，Servlet是一个特殊的Java程序，一个基于Java的Web应用通常包含一个或多个Servlet类。Servlet不能够自行创建并执行，它是在Servlet容器中运行的，容器将用户的请求传递给Servlet程序，并将Servlet的响应回传给用户。通常一个Servlet会关联一个或多个JSP页面。以前CGI经常因为性能开销上的问题被诟病，然而Fast CGI早就已经解决了CGI效率上的问题，所以面试的时候大可不必信口开河的诟病CGI，事实上有很多你熟悉的网站都使用了CGI技术。</p><p>参考：《javaweb整合开发王者归来》P7</p><h2 id="Servlet接口中有哪些方法及Servlet生命周期探秘"><a href="#Servlet接口中有哪些方法及Servlet生命周期探秘" class="headerlink" title="Servlet接口中有哪些方法及Servlet生命周期探秘"></a>Servlet接口中有哪些方法及Servlet生命周期探秘</h2><p>Servlet接口定义了5个方法，其中<strong>前三个方法与Servlet生命周期相关</strong>：</p><ul><li><code>void init(ServletConfig config) throws ServletException</code></li><li><code>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</code></li><li><code>void destroy()</code></li><li><code>java.lang.String getServletInfo()</code></li><li><code>ServletConfig getServletConfig()</code></li></ul><p><strong>生命周期：</strong> <strong>Web容器加载Servlet并将其实例化后，Servlet生命周期开始</strong>，容器运行其<strong>init()方法</strong>进行Servlet的初始化；请求到达时调用Servlet的<strong>service()方法</strong>，service()方法会根据需要调用与请求对应的<strong>doGet或doPost</strong>等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的<strong>destroy()方法</strong>。<strong>init方法和destroy方法只会执行一次，service方法客户端每次请求Servlet都会执行</strong>。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。</p><p>参考：《javaweb整合开发王者归来》P81</p><h2 id="get和post请求的区别"><a href="#get和post请求的区别" class="headerlink" title="get和post请求的区别"></a>get和post请求的区别</h2><p>get和post请求实际上是没有区别，大家可以自行查询相关文章（参考文章：<a href="https://www.cnblogs.com/logsharing/p/8448446.html" target="_blank" rel="noopener">https://www.cnblogs.com/logsharing/p/8448446.html</a>，知乎对应的问题链接：<a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener">get和post区别？</a>）！</p><p>可以把 get 和 post 当作两个不同的行为，两者并没有什么本质区别，底层都是 TCP 连接。 get请求用来从服务器上获得资源，而post是用来向服务器提交数据。比如你要获取人员列表可以用 get 请求，你需要创建一个人员可以用 post 。这也是 Restful  API 最基本的一个要求。</p><p>推荐阅读：</p><ul><li><a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener">https://www.zhihu.com/question/28586791</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd</a></li></ul><h2 id="什么情况下调用doGet-和doPost"><a href="#什么情况下调用doGet-和doPost" class="headerlink" title="什么情况下调用doGet()和doPost()"></a>什么情况下调用doGet()和doPost()</h2><p>Form标签里的method的属性为get时调用doGet()，为post时调用doPost()。</p><h2 id="转发-Forward-和重定向-Redirect-的区别"><a href="#转发-Forward-和重定向-Redirect-的区别" class="headerlink" title="转发(Forward)和重定向(Redirect)的区别"></a>转发(Forward)和重定向(Redirect)的区别</h2><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p><p><strong>转发（Forward）</strong><br>通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">"login_success.jsp"</span>).forward(request, response);</span><br></pre></td></tr></table></figure><p><strong>重定向（Redirect）</strong>  是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 <code>HttpServletResponse</code> 的 <code>setStatus(int status)</code> 方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。</p><ol><li><strong>从地址栏显示来说</strong></li></ol><p>forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.<br>redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</p><ol start="2"><li><strong>从数据共享来说</strong></li></ol><p>forward:转发页面和转发到的页面可以共享request里面的数据.<br>redirect:不能共享数据.</p><ol start="3"><li><strong>从运用地方来说</strong></li></ol><p>forward:一般用于用户登陆的时候,根据角色转发到相应的模块.<br>redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等</p><ol start="4"><li>从效率来说</li></ol><p>forward:高.<br>redirect:低.</p><h2 id="自动刷新-Refresh"><a href="#自动刷新-Refresh" class="headerlink" title="自动刷新(Refresh)"></a>自动刷新(Refresh)</h2><p>自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet中通过HttpServletResponse对象设置Header属性实现自动刷新例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response.setHeader(<span class="string">"Refresh"</span>,<span class="string">"5;URL=http://localhost:8080/servlet/example.htm"</span>);</span><br></pre></td></tr></table></figure><p>其中5为时间，单位为秒。URL指定就是要跳转的页面（如果设置自己的路径，就会实现每过5秒自动刷新本页面一次）</p><h2 id="Servlet与线程安全"><a href="#Servlet与线程安全" class="headerlink" title="Servlet与线程安全"></a>Servlet与线程安全</h2><p><strong>Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。</strong> 解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet()和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。<br>注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。</p><p>参考：《javaweb整合开发王者归来》P92</p><h2 id="JSP和Servlet是什么关系"><a href="#JSP和Servlet是什么关系" class="headerlink" title="JSP和Servlet是什么关系"></a>JSP和Servlet是什么关系</h2><p>其实这个问题在上面已经阐述过了，Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。</p><h2 id="JSP工作原理"><a href="#JSP工作原理" class="headerlink" title="JSP工作原理"></a>JSP工作原理</h2><p>JSP是一种Servlet，但是与HttpServlet的工作方式不太一样。HttpServlet是先由源代码编译为class文件后部署到服务器下，为先编译后部署。而JSP则是先部署后编译。JSP会在客户端第一次请求JSP文件时被编译为HttpJspPage类（接口Servlet的一个子类）。该类会被服务器临时存放在服务器工作目录里面。下面通过实例给大家介绍。<br>工程JspLoginDemo下有一个名为login.jsp的Jsp文件，把工程第一次部署到服务器上后访问这个Jsp文件，我们发现这个目录下多了下图这两个东东。<br>.class文件便是JSP对应的Servlet。编译完毕后再运行class文件来响应客户端请求。以后客户端访问login.jsp的时候，Tomcat将不再重新编译JSP文件，而是直接调用class文件来响应客户端请求。<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/1.png" alt="JSP工作原理"><br>由于JSP只会在客户端第一次请求的时候被编译 ，因此第一次请求JSP时会感觉比较慢，之后就会感觉快很多。如果把服务器保存的class文件删除，服务器也会重新编译JSP。</p><p>开发Web程序时经常需要修改JSP。Tomcat能够自动检测到JSP程序的改动。如果检测到JSP源代码发生了改动。Tomcat会在下次客户端请求JSP时重新编译JSP，而不需要重启Tomcat。这种自动检测功能是默认开启的，检测改动会消耗少量的时间，在部署Web应用的时候可以在web.xml中将它关掉。</p><p>参考：《javaweb整合开发王者归来》P97</p><h2 id="JSP有哪些内置对象、作用分别是什么"><a href="#JSP有哪些内置对象、作用分别是什么" class="headerlink" title="JSP有哪些内置对象、作用分别是什么"></a>JSP有哪些内置对象、作用分别是什么</h2><p><a href="http://blog.csdn.net/qq_34337272/article/details/64310849" target="_blank" rel="noopener">JSP内置对象 - CSDN博客 </a> </p><p>JSP有9个内置对象：</p><ul><li>request：封装客户端的请求，其中包含来自GET或POST请求的参数；</li><li>response：封装服务器对客户端的响应；</li><li>pageContext：通过该对象可以获取其他对象；</li><li>session：封装用户会话的对象；</li><li>application：封装服务器运行环境的对象；</li><li>out：输出服务器响应的输出流对象；</li><li>config：Web应用的配置对象；</li><li>page：JSP页面本身（相当于Java程序中的this）；</li><li>exception：封装页面抛出异常的对象。</li></ul><h2 id="Request对象的主要方法有哪些"><a href="#Request对象的主要方法有哪些" class="headerlink" title="Request对象的主要方法有哪些"></a>Request对象的主要方法有哪些</h2><ul><li>setAttribute(String name,Object)：设置名字为name的request 的参数值 </li><li>getAttribute(String name)：返回由name指定的属性值 </li><li>getAttributeNames()：返回request 对象所有属性的名字集合，结果是一个枚举的实例 </li><li>getCookies()：返回客户端的所有 Cookie 对象，结果是一个Cookie 数组 </li><li>getCharacterEncoding() ：返回请求中的字符编码方式 = getContentLength() ：返回请求的 Body的长度 </li><li>getHeader(String name) ：获得HTTP协议定义的文件头信息 </li><li>getHeaders(String name) ：返回指定名字的request Header 的所有值，结果是一个枚举的实例 </li><li>getHeaderNames() ：返回所以request Header 的名字，结果是一个枚举的实例 </li><li>getInputStream() ：返回请求的输入流，用于获得请求中的数据 </li><li>getMethod() ：获得客户端向服务器端传送数据的方法 </li><li>getParameter(String name) ：获得客户端传送给服务器端的有 name指定的参数值 </li><li>getParameterNames() ：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例 </li><li>getParameterValues(String name)：获得有name指定的参数的所有值 </li><li>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称 </li><li>getQueryString() ：获得查询字符串 </li><li>getRequestURI() ：获取发出请求字符串的客户端地址 </li><li>getRemoteAddr()：获取客户端的 IP 地址 </li><li>getRemoteHost() ：获取客户端的名字 </li><li>getSession([Boolean create]) ：返回和请求相关 Session </li><li>getServerName() ：获取服务器的名字 </li><li>getServletPath()：获取客户端所请求的脚本文件的路径 </li><li>getServerPort()：获取服务器的端口号 </li><li>removeAttribute(String name)：删除请求中的一个属性 </li></ul><h2 id="request-getAttribute-和-request-getParameter-有何区别"><a href="#request-getAttribute-和-request-getParameter-有何区别" class="headerlink" title="request.getAttribute()和 request.getParameter()有何区别"></a>request.getAttribute()和 request.getParameter()有何区别</h2><p><strong>从获取方向来看：</strong></p><p><code>getParameter()</code>是获取 POST/GET 传递的参数值；</p><p><code>getAttribute()</code>是获取对象容器中的数据值；</p><p><strong>从用途来看：</strong></p><p><code>getParameter()</code>用于客户端重定向时，即点击了链接或提交按扭时传值用，即用于在用表单或url重定向传值时接收数据用。</p><p><code>getAttribute()</code> 用于服务器端重定向时，即在 sevlet 中使用了 forward 函数,或 struts 中使用了<br>mapping.findForward。 getAttribute 只能收到程序用 setAttribute 传过来的值。</p><p>另外，可以用 <code>setAttribute()</code>,<code>getAttribute()</code> 发送接收对象.而 <code>getParameter()</code> 显然只能传字符串。<br><code>setAttribute()</code> 是应用服务器把这个对象放在该页面所对应的一块内存中去，当你的页面服务器重定向到另一个页面时，应用服务器会把这块内存拷贝另一个页面所对应的内存中。这样<code>getAttribute()</code>就能取得你所设下的值，当然这种方法可以传对象。session也一样，只是对象在内存中的生命周期不一样而已。<code>getParameter()</code>只是应用服务器在分析你送上来的 request页面的文本时，取得你设在表单或 url 重定向时的值。</p><p><strong>总结：</strong></p><p><code>getParameter()</code>返回的是String,用于读取提交的表单中的值;（获取之后会根据实际需要转换为自己需要的相应类型，比如整型，日期类型啊等等）</p><p><code>getAttribute()</code>返回的是Object，需进行转换,可用<code>setAttribute()</code>设置成任意对象，使用很灵活，可随时用</p><h2 id="include指令include的行为的区别"><a href="#include指令include的行为的区别" class="headerlink" title="include指令include的行为的区别"></a>include指令include的行为的区别</h2><p><strong>include指令：</strong> JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。 语法格式如下：<br>&lt;%@ include file=”文件相对 url 地址” %&gt;</p><p>i<strong>nclude动作：</strong> <code>&lt;jsp:include&gt;</code>动作元素用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。语法格式如下：<br>&lt;jsp:include page=”相对 URL 地址” flush=”true” /&gt;</p><h2 id="JSP九大内置对象，七大动作，三大指令"><a href="#JSP九大内置对象，七大动作，三大指令" class="headerlink" title="JSP九大内置对象，七大动作，三大指令"></a>JSP九大内置对象，七大动作，三大指令</h2><p><a href="http://blog.csdn.net/qq_34337272/article/details/64310849" target="_blank" rel="noopener">JSP九大内置对象，七大动作，三大指令总结</a></p><h2 id="讲解JSP中的四种作用域"><a href="#讲解JSP中的四种作用域" class="headerlink" title="讲解JSP中的四种作用域"></a>讲解JSP中的四种作用域</h2><p>JSP中的四种作用域包括page、request、session和application，具体来说：</p><ul><li><strong>page</strong>代表与一个页面相关的对象和属性。</li><li><strong>request</strong>代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。</li><li><strong>session</strong>代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。</li><li><strong>application</strong>代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</li></ul><h2 id="如何实现JSP或Servlet的单线程模式"><a href="#如何实现JSP或Servlet的单线程模式" class="headerlink" title="如何实现JSP或Servlet的单线程模式"></a>如何实现JSP或Servlet的单线程模式</h2><p>对于JSP页面，可以通过page指令进行设置。<br><code>&lt;%@page isThreadSafe=&quot;false&quot;%&gt;</code></p><p>对于Servlet，可以让自定义的Servlet实现SingleThreadModel标识接口。</p><p>说明：如果将JSP或Servlet设置成单线程工作模式，会导致每个请求创建一个Servlet实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。</p><h2 id="实现会话跟踪的技术有哪些"><a href="#实现会话跟踪的技术有哪些" class="headerlink" title="实现会话跟踪的技术有哪些"></a>实现会话跟踪的技术有哪些</h2><ol><li><strong>使用Cookie</strong></li></ol><p>向客户端发送Cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie c =<span class="keyword">new</span> Cookie(<span class="string">"name"</span>,<span class="string">"value"</span>); <span class="comment">//创建Cookie </span></span><br><span class="line">c.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>); <span class="comment">//设置最大时效，此处设置的最大时效为一天</span></span><br><span class="line">response.addCookie(c); <span class="comment">//把Cookie放入到HTTP响应中</span></span><br></pre></td></tr></table></figure><p>从客户端读取Cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String name =<span class="string">"name"</span>; </span><br><span class="line">Cookie[]cookies =request.getCookies(); </span><br><span class="line"><span class="keyword">if</span>(cookies !=<span class="keyword">null</span>)&#123; </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;cookies.length;i++)&#123; </span><br><span class="line">    Cookie cookie =cookies[i]; </span><br><span class="line">    <span class="keyword">if</span>(name.equals(cookis.getName())) </span><br><span class="line">    <span class="comment">//something is here. </span></span><br><span class="line">    <span class="comment">//you can get the value </span></span><br><span class="line">    cookie.getValue(); </span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>优点:</strong> 数据可以持久保存，不需要服务器资源，简单，基于文本的Key-Value</p><p><strong>缺点:</strong> 大小受到限制，用户可以禁用Cookie功能，由于保存在本地，有一定的安全风险。</p><ol start="2"><li>URL 重写</li></ol><p>在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。 </p><p><strong>优点：</strong> 在Cookie被禁用的时候依然可以使用</p><p><strong>缺点：</strong> 必须对网站的URL进行编码，所有页面必须动态生成，不能用预先记录下来的URL进行访问。</p><p>3.隐藏的表单域</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span> =<span class="string">"session"</span> <span class="attr">value</span>=<span class="string">"..."</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>优点：</strong> Cookie被禁时可以使用</p><p><strong>缺点：</strong> 所有页面必须是表单提交之后的结果。</p><ol start="4"><li>HttpSession</li></ol><p> 在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方 法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用 HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象。与上面三种方式不同的 是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession 中的对象移到其他存储设备中，但是这样势必影响性能。添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了 Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。</p><h2 id="Cookie和Session的的区别"><a href="#Cookie和Session的的区别" class="headerlink" title="Cookie和Session的的区别"></a>Cookie和Session的的区别</h2><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><p> <strong>Cookie 一般用来保存用户信息</strong> 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p><p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。 </p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/qrcode_for_gh_ea338256af79_258.jpg" alt="我的公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java疑难点</title>
      <link href="/posts/28b1a159/"/>
      <url>/posts/28b1a159/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h1><h2 id="1-1-正确使用-equals-方法"><a href="#1-1-正确使用-equals-方法" class="headerlink" title="1.1. 正确使用 equals 方法"></a>1.1. 正确使用 equals 方法</h2><p>Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。 </p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</span></span><br><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (str.equals(<span class="string">"SnailClimb"</span>)) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的程序会抛出空指针异常，但是我们把第二行的条件判断语句改为下面这样的话，就不会抛出空指针异常，else 语句块得到执行。：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"SnailClimb"</span>.equals(str);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>不过更推荐使用 <code>java.util.Objects#equals</code>(JDK7 引入的工具类)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Objects.equals(<span class="keyword">null</span>,<span class="string">"SnailClimb"</span>);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>我们看一下<code>java.util.Objects#equals</code>的源码就知道原因了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。</span></span><br><span class="line">        <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>Reference:<a href="https://blog.csdn.net/tick_tock97/article/details/72824894" target="_blank" rel="noopener">Java中equals方法造成空指针异常的原因及解决方案</a></p><ul><li>每种原始类型都有默认值一样，如int默认值为 0，boolean 的默认值为 false，null 是任何引用类型的默认值，不严格的说是所有 Object 类型的默认值。</li><li>可以使用 == 或者 != 操作来比较null值，但是不能使用其他算法或者逻辑操作。在Java中<code>null == null</code>将返回true。</li><li>不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</li></ul><h2 id="1-2-整型包装类值的比较"><a href="#1-2-整型包装类值的比较" class="headerlink" title="1.2. 整型包装类值的比较"></a>1.2. 整型包装类值的比较</h2><p>所有整型包装类对象值的比较必须使用equals方法。</p><p>先看下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">3</span>;</span><br><span class="line">Integer y = <span class="number">3</span>;</span><br><span class="line">System.out.println(x == y);<span class="comment">// true</span></span><br><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">System.out.println(a == b);<span class="comment">//false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>当使用自动装箱方式创建一个Integer对象时，当数值在-128 ~127时，会将创建的 Integer 对象缓存起来，当下次再出现该数值时，直接从缓存中取出对应的Integer对象。所以上述代码中，x和y引用的是相同的Integer对象。    </p><p><strong>注意：</strong>如果你的IDE(IDEA/Eclipse)上安装了阿里巴巴的p3c插件，这个插件如果检测到你用 ==的话会报错提示，推荐安装一个这个插件，很不错。</p><h2 id="1-3-BigDecimal"><a href="#1-3-BigDecimal" class="headerlink" title="1.3. BigDecimal"></a>1.3. BigDecimal</h2><h3 id="1-3-1-BigDecimal-的用处"><a href="#1-3-1-BigDecimal-的用处" class="headerlink" title="1.3.1. BigDecimal 的用处"></a>1.3.1. BigDecimal 的用处</h3><p>《阿里巴巴Java开发手册》中提到：<strong>浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。</strong> 具体原理和浮点数的编码方式有关，这里就不多提了，我们下面直接上实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999964</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>具有基本数学知识的我们很清楚的知道输出并不是我们想要的结果（<strong>精度丢失</strong>），我们如何解决这个问题呢？一种很常用的方法是：<strong>使用使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">"1.0"</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">"0.9"</span>);</span><br><span class="line">BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">"0.8"</span>);</span><br><span class="line">BigDecimal x = a.subtract(b);<span class="comment">// 0.1</span></span><br><span class="line">BigDecimal y = b.subtract(c);<span class="comment">// 0.1</span></span><br><span class="line">System.out.println(x.equals(y));<span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="1-3-2-BigDecimal-的大小比较"><a href="#1-3-2-BigDecimal-的大小比较" class="headerlink" title="1.3.2. BigDecimal 的大小比较"></a>1.3.2. BigDecimal 的大小比较</h3><p><code>a.compareTo(b)</code> : 返回 -1 表示小于，0 表示 等于， 1表示 大于。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">"1.0"</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">"0.9"</span>);</span><br><span class="line">System.out.println(a.compareTo(b));<span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="1-3-3-BigDecimal-保留几位小数"><a href="#1-3-3-BigDecimal-保留几位小数" class="headerlink" title="1.3.3. BigDecimal 保留几位小数"></a>1.3.3. BigDecimal 保留几位小数</h3><p>通过 <code>setScale</code>方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA会提示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal m = <span class="keyword">new</span> BigDecimal(<span class="string">"1.255433"</span>);</span><br><span class="line">BigDecimal n = m.setScale(<span class="number">3</span>,BigDecimal.ROUND_HALF_DOWN);</span><br><span class="line">System.out.println(n);<span class="comment">// 1.255</span></span><br></pre></td></tr></table></figure><h3 id="1-3-4-BigDecimal-的使用注意事项"><a href="#1-3-4-BigDecimal-的使用注意事项" class="headerlink" title="1.3.4. BigDecimal 的使用注意事项"></a>1.3.4. BigDecimal 的使用注意事项</h3><p>注意：我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 <strong>BigDecimal(String)</strong> 构造方法来创建对象。《阿里巴巴Java开发手册》对这部分内容也有提到如下图所示。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/BigDecimal.png" alt="《阿里巴巴Java开发手册》对这部分BigDecimal的描述"></p><h3 id="1-3-5-总结"><a href="#1-3-5-总结" class="headerlink" title="1.3.5. 总结"></a>1.3.5. 总结</h3><p>BigDecimal 主要用来操作（大）浮点数，BigInteger 主要用来操作大整数（超过 long 类型）。</p><p>BigDecimal 的实现利用到了 BigInteger, 所不同的是 BigDecimal 加入了小数位的概念</p><h2 id="1-4-基本数据类型与包装数据类型的使用标准"><a href="#1-4-基本数据类型与包装数据类型的使用标准" class="headerlink" title="1.4. 基本数据类型与包装数据类型的使用标准"></a>1.4. 基本数据类型与包装数据类型的使用标准</h2><p>Reference:《阿里巴巴Java开发手册》</p><ul><li>【强制】所有的 POJO 类属性必须使用包装数据类型。</li><li>【强制】RPC 方法的返回值和参数必须使用包装数据类型。</li><li>【推荐】所有的局部变量使用基本数据类型。</li></ul><p>比如我们如果自定义了一个Student类,其中有一个属性是成绩score,如果用Integer而不用int定义,一次考试,学生可能没考,值是null,也可能考了,但考了0分,值是0,这两个表达的状态明显不一样.</p><p><strong>说明</strong> :POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，都由使用者来保证。</p><p><strong>正例</strong> : 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。</p><p><strong>反例</strong> : 比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能够表示额外的信息，如:远程调用失败，异常退出。</p><h1 id="2-集合"><a href="#2-集合" class="headerlink" title="2. 集合"></a>2. 集合</h1><h2 id="2-1-Arrays-asList-使用指南"><a href="#2-1-Arrays-asList-使用指南" class="headerlink" title="2.1. Arrays.asList()使用指南"></a>2.1. Arrays.asList()使用指南</h2><p>最近使用<code>Arrays.asList()</code>遇到了一些坑，然后在网上看到这篇文章：<a href="http://javadevnotes.com/java-array-to-list-examples" target="_blank" rel="noopener">Java Array to List Examples</a> 感觉挺不错的，但是还不是特别全面。所以，自己对于这块小知识点进行了简单的总结。</p><h3 id="2-1-1-简介"><a href="#2-1-1-简介" class="headerlink" title="2.1.1. 简介"></a>2.1.1. 简介</h3><p><code>Arrays.asList()</code>在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个List集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] myArray = &#123; <span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span> &#125;； </span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class="line"><span class="comment">//上面两个语句等价于下面一条语句</span></span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(<span class="string">"Apple"</span>,<span class="string">"Banana"</span>, <span class="string">"Orange"</span>);</span><br></pre></td></tr></table></figure><p>JDK 源码对于这个方法的说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，与           Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-《阿里巴巴Java-开发手册》对其的描述"><a href="#2-1-2-《阿里巴巴Java-开发手册》对其的描述" class="headerlink" title="2.1.2. 《阿里巴巴Java 开发手册》对其的描述"></a>2.1.2. 《阿里巴巴Java 开发手册》对其的描述</h3><p><code>Arrays.asList()</code>将数组转换为集合后,底层其实还是数组，《阿里巴巴Java 开发手册》对于这个方法有如下描述：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B-Arrays.asList()%E6%96%B9%E6%B3%95.png" alt="阿里巴巴Java开发手-Arrays.asList()方法"></p><h3 id="2-1-3-使用时的注意事项总结"><a href="#2-1-3-使用时的注意事项总结" class="headerlink" title="2.1.3. 使用时的注意事项总结"></a>2.1.3. 使用时的注意事项总结</h3><p><strong>传递的数组必须是对象数组，而不是基本类型。</strong> </p><p><code>Arrays.asList()</code>是泛型方法，传入的对象必须是对象数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//1</span></span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></span><br><span class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="keyword">int</span> [] array=(<span class="keyword">int</span>[]) myList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组，这也就解释了上面的代码。</p><p>我们使用包装类型数组就可以解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure><p><strong>使用集合的修改方法:<code>add()</code>、<code>remove()</code>、<code>clear()</code>会抛出异常。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List myList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">myList.add(<span class="number">4</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.remove(<span class="number">1</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.clear();<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br></pre></td></tr></table></figure><p><code>Arrays.asList()</code> 方法返回的并不是 <code>java.util.ArrayList</code> ，而是 <code>java.util.Arrays</code> 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List myList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(myList.getClass());<span class="comment">//class java.util.Arrays$ArrayList</span></span><br></pre></td></tr></table></figure><p>下图是<code>java.util.Arrays$ArrayList</code>的简易源码，我们可以看到这个类重写的方法有哪些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们再看一下<code>java.util.AbstractList</code>的<code>remove()</code>方法，这样我们就明白为啥会抛出<code>UnsupportedOperationException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-4-如何正确的将数组转换为ArrayList"><a href="#2-1-4-如何正确的将数组转换为ArrayList" class="headerlink" title="2.1.4. 如何正确的将数组转换为ArrayList?"></a>2.1.4. 如何正确的将数组转换为ArrayList?</h3><p>stackoverflow：<a href="https://dwz.cn/vcBkTiTW" target="_blank" rel="noopener">https://dwz.cn/vcBkTiTW</a></p><p><strong>1. 自己动手实现（教育目的）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK1.5+</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">arrayToList</span><span class="params">(<span class="keyword">final</span> T[] array)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> List&lt;T&gt; l = <span class="keyword">new</span> ArrayList&lt;T&gt;(array.length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> T s : array) &#123;</span><br><span class="line">    l.add(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">System.out.println(arrayToList(myArray).getClass());<span class="comment">//class java.util.ArrayList</span></span><br></pre></td></tr></table></figure><p><strong>2. 最简便的方法(推荐)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>))</span><br></pre></td></tr></table></figure><p><strong>3. 使用 Java8 的Stream(推荐)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.stream(myArray).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span></span><br><span class="line"><span class="keyword">int</span> [] myArray2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p><strong>4. 使用 Guava(推荐)</strong></p><p>对于不可变集合，你可以使用<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java" target="_blank" rel="noopener"><code>ImmutableList</code></a>类及其<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L101" target="_blank" rel="noopener"><code>of()</code></a>与<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L225" target="_blank" rel="noopener"><code>copyOf()</code></a>工厂方法：（参数不能为空）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; il = ImmutableList.of(<span class="string">"string"</span>, <span class="string">"elements"</span>);  <span class="comment">// from varargs</span></span><br><span class="line">List&lt;String&gt; il = ImmutableList.copyOf(aStringArray);      <span class="comment">// from array</span></span><br></pre></td></tr></table></figure><p>对于可变集合，你可以使用<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java" target="_blank" rel="noopener"><code>Lists</code></a>类及其<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java#L87" target="_blank" rel="noopener"><code>newArrayList()</code></a>工厂方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = Lists.newArrayList(anotherListOrCollection);    <span class="comment">// from collection</span></span><br><span class="line">List&lt;String&gt; l2 = Lists.newArrayList(aStringArray);               <span class="comment">// from array</span></span><br><span class="line">List&lt;String&gt; l3 = Lists.newArrayList(<span class="string">"or"</span>, <span class="string">"string"</span>, <span class="string">"elements"</span>); <span class="comment">// from varargs</span></span><br></pre></td></tr></table></figure><p><strong>5. 使用 Apache Commons Collections</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">CollectionUtils.addAll(list, str);</span><br></pre></td></tr></table></figure><h2 id="2-2-Collection-toArray-方法使用的坑-amp-如何反转数组"><a href="#2-2-Collection-toArray-方法使用的坑-amp-如何反转数组" class="headerlink" title="2.2. Collection.toArray()方法使用的坑&amp;如何反转数组"></a>2.2. Collection.toArray()方法使用的坑&amp;如何反转数组</h2><p>该方法是一个泛型方法：<code>&lt;T&gt; T[] toArray(T[] a);</code> 如果<code>toArray</code>方法中没有传递任何参数的话返回的是<code>Object</code>类型数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String [] s= <span class="keyword">new</span> String[]&#123;</span><br><span class="line">    <span class="string">"dog"</span>, <span class="string">"lazy"</span>, <span class="string">"a"</span>, <span class="string">"over"</span>, <span class="string">"jumps"</span>, <span class="string">"fox"</span>, <span class="string">"brown"</span>, <span class="string">"quick"</span>, <span class="string">"A"</span></span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">s=list.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);<span class="comment">//没有指定类型的话会报错</span></span><br></pre></td></tr></table></figure><p>由于JVM优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型。详见：<a href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/" target="_blank" rel="noopener">https://shipilev.net/blog/2016/arrays-wisdom-ancients/</a></p><h2 id="2-3-不要在-foreach-循环里进行元素的-remove-add-操作"><a href="#2-3-不要在-foreach-循环里进行元素的-remove-add-操作" class="headerlink" title="2.3. 不要在 foreach 循环里进行元素的 remove/add 操作"></a>2.3. 不要在 foreach 循环里进行元素的 remove/add 操作</h2><p>如果要进行<code>remove</code>操作，可以调用迭代器的 <code>remove</code>方法而不是集合类的 remove 方法。因为如果列表在任何时间从结构上修改创建迭代器之后，以任何方式除非通过迭代器自身<code>remove/add</code>方法，迭代器都将抛出一个<code>ConcurrentModificationException</code>,这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</p><blockquote><p><strong>fail-fast 机制</strong> ：多个线程对 fail-fast 集合进行修改的时，可能会抛出ConcurrentModificationException，单线程下也会出现这种情况，上面已经提到过。</p></blockquote><p><code>java.util</code>包下面的所有的集合类都是fail-fast的，而<code>java.util.concurrent</code>包下面的所有的类都是fail-safe的。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/foreach-remove:add.png" alt="不要在 foreach 循环里进行元素的 remove/add 操作"></p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程规范</title>
      <link href="/posts/5a88bde2/"/>
      <url>/posts/5a88bde2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><p>讲真的，下面推荐的文章或者资源建议阅读 3 遍以上。</p><h3 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h3><ul><li><strong>阿里巴巴Java开发手册（详尽版）</strong> <a href="https://github.com/alibaba/p3c/blob/master/阿里巴巴Java开发手册（华山版）.pdf" target="_blank" rel="noopener">https://github.com/alibaba/p3c/blob/master/阿里巴巴Java开发手册（华山版）.pdf</a></li><li><strong>Google Java编程风格指南：</strong> <a href="http://hawstein.com/2014/01/20/google-java-style/" target="_blank" rel="noopener">http://hawstein.com/2014/01/20/google-java-style/</a></li></ul><h3 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h3><ul><li><strong>程序员你为什么这么累:</strong> <a href="https://xwjie.github.io/rule/" target="_blank" rel="noopener">https://xwjie.github.io/rule/</a></li></ul><h3 id="如何写出优雅的-Java-代码"><a href="#如何写出优雅的-Java-代码" class="headerlink" title="如何写出优雅的 Java 代码"></a>如何写出优雅的 Java 代码</h3><ol><li>使用 IntelliJ IDEA 作为您的集成开发环境 (IDE)</li><li>使用 JDK 8 或更高版本</li><li>使用 Maven/Gradle</li><li>使用 Lombok</li><li>编写单元测试</li><li>重构:常见,但也很慢</li><li>注意代码规范</li><li>定期联络客户，以获取他们的反馈</li></ol><p>上述建议的详细内容：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485140&idx=1&sn=ecaeace613474f1859aaeed0282ae680&chksm=cea2491ff9d5c00982ffaece847ce1aead89fdb3fe190752d9837c075c79fc95db5940992c56&token=1328169465&lang=zh_CN&scene=21#wechat_redirect" target="_blank" rel="noopener">八点建议助您写出优雅的Java代码</a>。</p><p>更多代码优化相关内容推荐：</p><ul><li><a href="https://juejin.im/post/5dad23685188251d2c4ea2b6" target="_blank" rel="noopener">业务复杂=if else？刚来的大神竟然用策略+工厂彻底干掉了他们！</a></li><li><a href="http://lrwinx.github.io/2017/03/04/%E7%BB%86%E6%80%9D%E6%9E%81%E6%81%90-%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E5%86%99java%E5%90%97/" target="_blank" rel="noopener">一些不错的 Java 实践！推荐阅读3遍以上！</a></li><li><a href="https://juejin.im/post/5dafbc02e51d4524a0060bdd" target="_blank" rel="noopener">[解锁新姿势] 兄dei，你代码需要优化了</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485599&idx=1&sn=d83ff4e6b1ee951a0a33508a10980ea3&chksm=cea24754f9d5ce426d18b435a8c373ddc580c06c7d6a45cc51377361729c31c7301f1bbc3b78&token=1328169465&lang=zh_CN#rd" target="_blank" rel="noopener">消灭 Java 代码的“坏味道”</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO与NIO</title>
      <link href="/posts/8d1b7b28/"/>
      <url>/posts/8d1b7b28/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><h2 id="IO流学习总结"><a href="#IO流学习总结" class="headerlink" title="IO流学习总结"></a>IO流学习总结</h2><h3 id="一-Java-IO，硬骨头也能变软"><a href="#一-Java-IO，硬骨头也能变软" class="headerlink" title="一　Java IO，硬骨头也能变软"></a><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247483981&idx=1&sn=6e5c682d76972c8d2cf271a85dcf09e2&chksm=fd98542ccaefdd3a70428e9549bc33e8165836855edaa748928d16c1ebde9648579d3acaac10#rd" target="_blank" rel="noopener">一　Java IO，硬骨头也能变软</a></h3><p><strong>（1） 按操作方式分类结构图：</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/IO-%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB.png" alt="IO-操作方式分类"></p><p><strong>（2）按操作对象分类结构图</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/IO-%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB.png" alt="IO-操作对象分类"></p><h3 id="二-java-IO体系的学习总结"><a href="#二-java-IO体系的学习总结" class="headerlink" title="二　java IO体系的学习总结"></a><a href="https://blog.csdn.net/nightcurtis/article/details/51324105" target="_blank" rel="noopener">二　java IO体系的学习总结</a></h3><ol><li><p><strong>IO流的分类：</strong></p><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul></li><li><p><strong>流的原理浅析:</strong></p><p>java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java Io流的40多个类都是从如下4个抽象类基类中派生出来的。</p><ul><li><strong>InputStream/Reader</strong>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><strong>OutputStream/Writer</strong>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul></li><li><p><strong>常用的io流的用法</strong> </p></li></ol><h3 id="三-Java-IO面试题"><a href="#三-Java-IO面试题" class="headerlink" title="三　Java IO面试题"></a><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247483985&idx=1&sn=38531c2cee7b87f125df7aef41637014&chksm=fd985430caefdd26b0506aa84fc26251877eccba24fac73169a4d6bd1eb5e3fbdf3c3b940261#rd" target="_blank" rel="noopener">三　Java IO面试题</a></h3><h2 id="NIO与AIO学习总结"><a href="#NIO与AIO学习总结" class="headerlink" title="NIO与AIO学习总结"></a>NIO与AIO学习总结</h2><h3 id="一-Java-NIO-概览"><a href="#一-Java-NIO-概览" class="headerlink" title="一 Java NIO 概览"></a><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247483956&idx=1&sn=57692bc5b7c2c6dfb812489baadc29c9&chksm=fd985455caefdd4331d828d8e89b22f19b304aa87d6da73c5d8c66fcef16e4c0b448b1a6f791#rd" target="_blank" rel="noopener">一 Java NIO 概览</a></h3><ol><li><p><strong>NIO简介</strong>:</p><p>Java NIO 是 java 1.4, 之后新出的一套IO接口NIO中的N可以理解为Non-blocking，不单纯是New。</p></li><li><p><strong>NIO的特性/NIO与IO区别:</strong></p><ul><li>1)IO是面向流的，NIO是面向缓冲区的；</li><li>2)IO流是阻塞的，NIO流是不阻塞的;</li><li>3)NIO有选择器，而IO没有。</li></ul></li><li><p><strong>读数据和写数据方式:</strong></p><ul><li><p>从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。</p></li><li><p>从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。</p></li></ul></li><li><p><strong>NIO核心组件简单介绍</strong></p><ul><li><strong>Channels</strong></li><li><strong>Buffers</strong></li><li><strong>Selectors</strong></li></ul></li></ol><h3 id="二-Java-NIO-之-Buffer-缓冲区"><a href="#二-Java-NIO-之-Buffer-缓冲区" class="headerlink" title="二 Java NIO 之 Buffer(缓冲区)"></a><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247483961&idx=1&sn=f67bef4c279e78043ff649b6b03fdcbc&chksm=fd985458caefdd4e3317ccbdb2d0a5a70a5024d3255eebf38183919ed9c25ade536017c0a6ba#rd" target="_blank" rel="noopener">二 Java NIO 之 Buffer(缓冲区)</a></h3><ol><li><p><strong>Buffer(缓冲区)介绍:</strong></p><ul><li>Java NIO Buffers用于和NIO Channel交互。 我们从Channel中读取数据到buffers里，从Buffer把数据写入到Channels；</li><li>Buffer本质上就是一块内存区；</li><li>一个Buffer有三个属性是必须掌握的，分别是：capacity容量、position位置、limit限制。</li></ul></li><li><p><strong>Buffer的常见方法</strong></p><ul><li>Buffer clear()</li><li>Buffer flip()</li><li>Buffer rewind()</li><li>Buffer position(int newPosition)</li></ul></li><li><p><strong>Buffer的使用方式/方法介绍:</strong></p><ul><li><p>分配缓冲区（Allocating a Buffer）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">28</span>);<span class="comment">//以ByteBuffer为例子</span></span><br></pre></td></tr></table></figure></li><li><p>写入数据到缓冲区（Writing Data to a Buffer）</p><p><strong>写数据到Buffer有两种方法：</strong></p><p>1.从Channel中写数据到Buffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf); <span class="comment">//read into buffer.</span></span><br></pre></td></tr></table></figure><p>2.通过put写数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.put(<span class="number">127</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Buffer常用方法测试</strong></p><p> 说实话，NIO编程真的难，通过后面这个测试例子，你可能才能勉强理解前面说的Buffer方法的作用。</p></li></ol><h3 id="三-Java-NIO-之-Channel（通道）"><a href="#三-Java-NIO-之-Channel（通道）" class="headerlink" title="三 Java NIO 之 Channel（通道）"></a><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247483966&idx=1&sn=d5cf18c69f5f9ec2aff149270422731f&chksm=fd98545fcaefdd49296e2c78000ce5da277435b90ba3c03b92b7cf54c6ccc71d61d13efbce63#rd" target="_blank" rel="noopener">三 Java NIO 之 Channel（通道）</a></h3><ol><li><strong>Channel（通道）介绍</strong><ul><li>通常来说NIO中的所有IO都是从 Channel（通道） 开始的。 </li><li>NIO Channel通道和流的区别：</li></ul></li><li><strong>FileChannel的使用</strong></li><li><strong>SocketChannel和ServerSocketChannel的使用</strong></li><li><strong>️DatagramChannel的使用</strong></li><li><strong>Scatter / Gather</strong><ul><li>Scatter: 从一个Channel读取的信息分散到N个缓冲区中(Buufer).</li><li>Gather: 将N个Buffer里面内容按照顺序发送到一个Channel.</li></ul></li><li><strong>通道之间的数据传输</strong><ul><li>在Java NIO中如果一个channel是FileChannel类型的，那么他可以直接把数据传输到另一个channel。</li><li>transferFrom() :transferFrom方法把数据从通道源传输到FileChannel</li><li>transferTo() :transferTo方法把FileChannel数据传输到另一个channel</li></ul></li></ol><h3 id="四-Java-NIO之Selector（选择器）"><a href="#四-Java-NIO之Selector（选择器）" class="headerlink" title="四 Java NIO之Selector（选择器）"></a><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247483970&idx=1&sn=d5e2b133313b1d0f32872d54fbdf0aa7&chksm=fd985423caefdd354b587e57ce6cf5f5a7bec48b9ab7554f39a8d13af47660cae793956e0f46#rd" target="_blank" rel="noopener">四 Java NIO之Selector（选择器）</a></h3><ol><li><p><strong>Selector（选择器）介绍</strong></p><ul><li>Selector 一般称 为选择器 ，当然你也可以翻译为 多路复用器 。它是Java NIO核心组件中的一个，用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。</li><li>使用Selector的好处在于： 使用更少的线程来就可以来处理通道了， 相比使用多个线程，避免了线程上下文切换带来的开销。</li></ul></li><li><p><strong>Selector（选择器）的使用方法介绍</strong></p><ul><li><p>Selector的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure></li><li><p>注册Channel到Selector(Channel必须是非阻塞的)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector, Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure></li><li><p>SelectionKey介绍</p><p>一个SelectionKey键表示了一个特定的通道对象和一个特定的选择器对象之间的注册关系。</p></li><li><p>从Selector中选择channel(Selecting Channels via a Selector)</p><p>选择器维护注册过的通道的集合，并且这种注册关系都被封装在SelectionKey当中.</p></li><li><p>停止选择的方法</p><p>wakeup()方法 和close()方法。</p></li></ul></li><li><p><strong>模板代码</strong></p><p>有了模板代码我们在编写程序时，大多数时间都是在模板代码中添加相应的业务代码。</p></li><li><p><strong>客户端与服务端简单交互实例</strong></p></li></ol><h3 id="五-Java-NIO之拥抱Path和Files"><a href="#五-Java-NIO之拥抱Path和Files" class="headerlink" title="五 Java NIO之拥抱Path和Files"></a><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247483976&idx=1&sn=2296c05fc1b840a64679e2ad7794c96d&chksm=fd985429caefdd3f48e2ee6fdd7b0f6fc419df90b3de46832b484d6d1ca4e74e7837689c8146&token=537240785&lang=zh_CN#rd" target="_blank" rel="noopener">五 Java NIO之拥抱Path和Files</a></h3><p><strong>一 文件I/O基石：Path：</strong></p><ul><li>创建一个Path</li><li>File和Path之间的转换，File和URI之间的转换</li><li>获取Path的相关信息</li><li>移除Path中的冗余项</li></ul><p><strong>二 拥抱Files类：</strong></p><ul><li>Files.exists() 检测文件路径是否存在</li><li>Files.createFile() 创建文件</li><li>Files.createDirectories()和Files.createDirectory()创建文件夹</li><li>Files.delete()方法 可以删除一个文件或目录</li><li>Files.copy()方法可以吧一个文件从一个地址复制到另一个位置</li><li>获取文件属性</li><li>遍历一个文件夹</li><li>Files.walkFileTree()遍历整个目录</li></ul><h3 id="六-NIO学习总结以及NIO新特性介绍"><a href="#六-NIO学习总结以及NIO新特性介绍" class="headerlink" title="六 NIO学习总结以及NIO新特性介绍"></a><a href="https://blog.csdn.net/a953713428/article/details/64907250" target="_blank" rel="noopener">六 NIO学习总结以及NIO新特性介绍</a></h3><ul><li><strong>内存映射：</strong></li></ul><p>这个功能主要是为了提高大文件的读写速度而设计的。内存映射文件(memory-mappedfile)能让你创建和修改那些大到无法读入内存的文件。有了内存映射文件，你就可以认为文件已经全部读进了内存，然后把它当成一个非常大的数组来访问了。将文件的一段区域映射到内存中，比传统的文件处理速度要快很多。内存映射文件它虽然最终也是要从磁盘读取数据，但是它并不需要将数据读取到OS内核缓冲区，而是直接将进程的用户私有地址空间中的一部分区域与文件对象建立起映射关系，就好像直接从内存中读、写文件一样，速度当然快了。</p><h3 id="七-Java-NIO-AsynchronousFileChannel异步文件通"><a href="#七-Java-NIO-AsynchronousFileChannel异步文件通" class="headerlink" title="七 Java NIO AsynchronousFileChannel异步文件通"></a><a href="http://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-asynchronousfilechannel.html" target="_blank" rel="noopener">七 Java NIO AsynchronousFileChannel异步文件通</a></h3><p>Java7中新增了AsynchronousFileChannel作为nio的一部分。AsynchronousFileChannel使得数据可以进行异步读写。</p><h3 id="八-高并发Java（8）：NIO和AIO"><a href="#八-高并发Java（8）：NIO和AIO" class="headerlink" title="八 高并发Java（8）：NIO和AIO"></a><a href="http://www.importnew.com/21341.html" target="_blank" rel="noopener">八 高并发Java（8）：NIO和AIO</a></h3><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><h3 id="在-Java-7-中体会-NIO-2-异步执行的快乐"><a href="#在-Java-7-中体会-NIO-2-异步执行的快乐" class="headerlink" title="在 Java 7 中体会 NIO.2 异步执行的快乐"></a><a href="https://www.ibm.com/developerworks/cn/java/j-lo-nio2/index.html" target="_blank" rel="noopener">在 Java 7 中体会 NIO.2 异步执行的快乐</a></h3><h3 id="Java-AIO总结与示例"><a href="#Java-AIO总结与示例" class="headerlink" title="Java AIO总结与示例"></a><a href="https://blog.csdn.net/x_i_y_u_e/article/details/52223406" target="_blank" rel="noopener">Java AIO总结与示例</a></h3><p>AIO是异步IO的缩写，虽然NIO在网络操作中，提供了非阻塞的方法，但是NIO的IO行为还是同步的。对于NIO来说，我们的业务线程是在IO操作准备好时，得到通知，接着就由这个线程自行进行IO操作，IO操作本身是同步的。</p><p><strong>欢迎关注我的微信公众号:”Java面试通关手册”（一个有温度的微信公众号，期待与你共同进步<del>~</del>坚持原创，分享美文，分享各种Java学习资源）：</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java开发规范</title>
      <link href="/posts/89b4f7f0/"/>
      <url>/posts/89b4f7f0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://www.cnblogs.com/liqiangchn/p/12000361.html" target="_blank" rel="noopener">https://www.cnblogs.com/liqiangchn/p/12000361.html</a> </p></blockquote><p>简洁清爽的代码风格应该是大多数工程师所期待的。在工作中笔者常常因为起名字而纠结，夸张点可以说是编程5分钟，命名两小时！究竟为什么命名成为了工作中的拦路虎。</p><p>每个公司都有不同的标准，目的是为了保持统一，减少沟通成本，提升团队研发效能。所以本文中是笔者结合阿里巴巴开发规范，以及工作中的见闻针对Java领域相关命名进行整理和总结，仅供参考。</p><h2 id="一，Java中的命名规范"><a href="#一，Java中的命名规范" class="headerlink" title="一，Java中的命名规范"></a>一，Java中的命名规范</h2><p>好的命名能体现出代码的特征，含义或者是用途，让阅读者可以根据名称的含义快速厘清程序的脉络。不同语言中采用的命名形式大相径庭，Java中常用到的命名形式共有三种，既首字母大写的UpperCamelCase，首字母小写的lowerCamelCase以及全部大写的并用下划线分割单词的UPPER_CAMEL_UNSER_SCORE。通常约定，<strong>类一般采用大驼峰命名，方法和局部变量使用小驼峰命名，而大写下划线命名通常是常量和枚举中使用。</strong></p><table><thead><tr><th align="center">类型</th><th align="center">约束</th><th align="center">例</th></tr></thead><tbody><tr><td align="center">项目名</td><td align="center">全部小写，多个单词用中划线分隔‘-’</td><td align="center">spring-cloud</td></tr><tr><td align="center">包名</td><td align="center">全部小写</td><td align="center">com.alibaba.fastjson</td></tr><tr><td align="center">类名</td><td align="center">单词首字母大写</td><td align="center">Feature, ParserConfig,DefaultFieldDeserializer</td></tr><tr><td align="center">变量名</td><td align="center">首字母小写，多个单词组成时，除首个单词，其他单词首字母都要大写</td><td align="center">password, userName</td></tr><tr><td align="center">常量名</td><td align="center">全部大写，多个单词，用’_’分隔</td><td align="center">CACHE_EXPIRED_TIME</td></tr><tr><td align="center">方法</td><td align="center">同变量</td><td align="center">read(), readObject(), getById()</td></tr></tbody></table><h2 id="二，包命名"><a href="#二，包命名" class="headerlink" title="二，包命名"></a>二，包命名</h2><p><strong>包名</strong>统一使用<strong>小写</strong>，<strong>点分隔符</strong>之间有且仅有一个自然语义的英文单词或者多个单词自然连接到一块（如 springframework，deepspace不需要使用任何分割）。包名统一使用单数形式，如果类命有复数含义，则可以使用复数形式。</p><p>包名的构成可以分为以下几四部分【前缀】 【发起者名】【项目名】【模块名】。常见的前缀可以分为以下几种：</p><table><thead><tr><th align="center">前缀名</th><th align="center">例</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">indi（或onem ）</td><td align="center">indi.发起者名.项目名.模块名.……</td><td align="center">个体项目，指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。</td></tr><tr><td align="center">pers</td><td align="center">pers.个人名.项目名.模块名.……</td><td align="center">个人项目，指个人发起，独自完成，可分享的项目，copyright主要属于个人</td></tr><tr><td align="center">priv</td><td align="center">priv.个人名.项目名.模块名.……</td><td align="center">私有项目，指个人发起，独自完成，非公开的私人使用的项目，copyright属于个人。</td></tr><tr><td align="center">team</td><td align="center">team.团队名.项目名.模块名.……</td><td align="center">团队项目，指由团队发起，并由该团队开发的项目，copyright属于该团队所有</td></tr><tr><td align="center">顶级域名</td><td align="center">com.公司名.项目名.模块名.……</td><td align="center">公司项目，copyright由项目发起的公司所有</td></tr></tbody></table><h2 id="三，类命名"><a href="#三，类命名" class="headerlink" title="三，类命名"></a>三，类命名</h2><p><strong>类名使用大驼峰命名形式</strong>，类命通常时<strong>名词或名词短语</strong>，接口名除了用名词和名词短语以外，还可以使用形容词或形容词短语，如Cloneable，Callable等，表示实现该接口的类有某种功能或能力。对于测试类则以它要测试的类开头，以Test结尾，如HashMapTest。</p><p>对于一些特殊特有名词缩写也可以使用全大写命名，比如XMLHttpRequest，不过笔者认为缩写三个字母以内都大写，超过三个字母则按照要给单词算。这个没有标准如阿里巴巴中fastjson用JSONObject作为类命，而google则使用JsonObjectRequest命名，对于这种特殊的缩写，原则是统一就好。</p><table><thead><tr><th>属性</th><th>约束</th><th>例</th></tr></thead><tbody><tr><td>抽象类</td><td>Abstract 或者 Base 开头</td><td>BaseUserService</td></tr><tr><td>枚举类</td><td>Enum 作为后缀</td><td>GenderEnum</td></tr><tr><td>工具类</td><td>Utils作为后缀</td><td>StringUtils</td></tr><tr><td>异常类</td><td>Exception结尾</td><td>RuntimeException</td></tr><tr><td>接口实现类</td><td>接口名+ Impl</td><td>UserServiceImpl</td></tr><tr><td>领域模型相关</td><td>/DO/DTO/VO/DAO</td><td>正例：UserDAO 反例： UserDo， UserDao</td></tr><tr><td>设计模式相关类</td><td>Builder，Factory等</td><td>当使用到设计模式时，需要使用对应的设计模式作为后缀，如ThreadFactory</td></tr><tr><td>处理特定功能的</td><td>Handler，Predicate, Validator</td><td>表示处理器，校验器，断言，这些类工厂还有配套的方法名如handle，predicate，validate</td></tr><tr><td>测试类</td><td>Test结尾</td><td>UserServiceTest， 表示用来测试UserService类的</td></tr><tr><td>MVC分层</td><td>Controller，Service，ServiceImpl，DAO后缀</td><td>UserManageController，UserManageDAO</td></tr></tbody></table><h2 id="四，方法"><a href="#四，方法" class="headerlink" title="四，方法"></a>四，方法</h2><p><strong>方法命名采用小驼峰的形式</strong>，首字小写，往后的每个单词首字母都要大写。 和类名不同的是，方法命名一般为<strong>动词或动词短语</strong>，与参数或参数名共同组成动宾短语，即动词 + 名词。一个好的函数名一般能通过名字直接获知该函数实现什么样的功能。</p><h3 id="4-1-返回真伪值的方法"><a href="#4-1-返回真伪值的方法" class="headerlink" title="4.1 返回真伪值的方法"></a>4.1 返回真伪值的方法</h3><p>注：Prefix-前缀，Suffix-后缀，Alone-单独使用</p><table><thead><tr><th>位置</th><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>Prefix</td><td>is</td><td>对象是否符合期待的状态</td><td>isValid</td></tr><tr><td>Prefix</td><td>can</td><td>对象<strong>能否执行</strong>所期待的动作</td><td>canRemove</td></tr><tr><td>Prefix</td><td>should</td><td>调用方执行某个命令或方法是<strong>好还是不好</strong>,<strong>应不应该</strong>，或者说<strong>推荐还是不推荐</strong></td><td>shouldMigrate</td></tr><tr><td>Prefix</td><td>has</td><td>对象<strong>是否持有</strong>所期待的数据和属性</td><td>hasObservers</td></tr><tr><td>Prefix</td><td>needs</td><td>调用方<strong>是否需要</strong>执行某个命令或方法</td><td>needsMigrate</td></tr></tbody></table><h3 id="4-2-用来检查的方法"><a href="#4-2-用来检查的方法" class="headerlink" title="4.2 用来检查的方法"></a>4.2 用来检查的方法</h3><table><thead><tr><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>ensure</td><td>检查是否为期待的状态，不是则抛出异常或返回error code</td><td>ensureCapacity</td></tr><tr><td>validate</td><td>检查是否为正确的状态，不是则抛出异常或返回error code</td><td>validateInputs</td></tr></tbody></table><h3 id="4-3-按需求才执行的方法"><a href="#4-3-按需求才执行的方法" class="headerlink" title="4.3 按需求才执行的方法"></a>4.3 按需求才执行的方法</h3><table><thead><tr><th>位置</th><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>Suffix</td><td>IfNeeded</td><td>需要的时候执行，不需要的时候什么都不做</td><td>drawIfNeeded</td></tr><tr><td>Prefix</td><td>might</td><td>同上</td><td>mightCreate</td></tr><tr><td>Prefix</td><td>try</td><td>尝试执行，失败时抛出异常或是返回errorcode</td><td>tryCreate</td></tr><tr><td>Suffix</td><td>OrDefault</td><td>尝试执行，失败时返回默认值</td><td>getOrDefault</td></tr><tr><td>Suffix</td><td>OrElse</td><td>尝试执行、失败时返回实际参数中指定的值</td><td>getOrElse</td></tr><tr><td>Prefix</td><td>force</td><td>强制尝试执行。error抛出异常或是返回值</td><td>forceCreate, forceStop</td></tr></tbody></table><h3 id="4-4-异步相关方法"><a href="#4-4-异步相关方法" class="headerlink" title="4.4 异步相关方法"></a>4.4 异步相关方法</h3><table><thead><tr><th>位置</th><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>Prefix</td><td>blocking</td><td>线程阻塞方法</td><td>blockingGetUser</td></tr><tr><td>Suffix</td><td>InBackground</td><td>执行在后台的线程</td><td>doInBackground</td></tr><tr><td>Suffix</td><td>Async</td><td>异步方法</td><td>sendAsync</td></tr><tr><td>Suffix</td><td>Sync</td><td>对应已有异步方法的同步方法</td><td>sendSync</td></tr><tr><td>Prefix or Alone</td><td>schedule</td><td>Job和Task放入队列</td><td>schedule, scheduleJob</td></tr><tr><td>Prefix or Alone</td><td>post</td><td>同上</td><td>postJob</td></tr><tr><td>Prefix or Alone</td><td>execute</td><td>执行异步方法（注：我一般拿这个做同步方法名）</td><td>execute, executeTask</td></tr><tr><td>Prefix or Alone</td><td>start</td><td>同上</td><td>start, startJob</td></tr><tr><td>Prefix or Alone</td><td>cancel</td><td>停止异步方法</td><td>cancel, cancelJob</td></tr><tr><td>Prefix or Alone</td><td>stop</td><td>同上</td><td>stop, stopJob</td></tr></tbody></table><h3 id="4-5-回调方法"><a href="#4-5-回调方法" class="headerlink" title="4.5 回调方法"></a>4.5 回调方法</h3><table><thead><tr><th>位置</th><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>Prefix</td><td>on</td><td>事件发生时执行</td><td>onCompleted</td></tr><tr><td>Prefix</td><td>before</td><td>事件发生前执行</td><td>beforeUpdate</td></tr><tr><td>Prefix</td><td>pre</td><td>同上</td><td>preUpdate</td></tr><tr><td>Prefix</td><td>will</td><td>同上</td><td>willUpdate</td></tr><tr><td>Prefix</td><td>after</td><td>事件发生后执行</td><td>afterUpdate</td></tr><tr><td>Prefix</td><td>post</td><td>同上</td><td>postUpdate</td></tr><tr><td>Prefix</td><td>did</td><td>同上</td><td>didUpdate</td></tr><tr><td>Prefix</td><td>should</td><td>确认事件是否可以发生时执行</td><td>shouldUpdate</td></tr></tbody></table><h3 id="4-6-操作对象生命周期的方法"><a href="#4-6-操作对象生命周期的方法" class="headerlink" title="4.6 操作对象生命周期的方法"></a>4.6 操作对象生命周期的方法</h3><table><thead><tr><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>initialize</td><td>初始化。也可作为延迟初始化使用</td><td>initialize</td></tr><tr><td>pause</td><td>暂停</td><td>onPause ，pause</td></tr><tr><td>stop</td><td>停止</td><td>onStop，stop</td></tr><tr><td>abandon</td><td>销毁的替代</td><td>abandon</td></tr><tr><td>destroy</td><td>同上</td><td>destroy</td></tr><tr><td>dispose</td><td>同上</td><td>dispose</td></tr></tbody></table><h3 id="4-7-与集合操作相关的方法"><a href="#4-7-与集合操作相关的方法" class="headerlink" title="4.7 与集合操作相关的方法"></a>4.7 与集合操作相关的方法</h3><table><thead><tr><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>contains</td><td>是否持有与指定对象相同的对象</td><td>contains</td></tr><tr><td>add</td><td>添加</td><td>addJob</td></tr><tr><td>append</td><td>添加</td><td>appendJob</td></tr><tr><td>insert</td><td>插入到下标n</td><td>insertJob</td></tr><tr><td>put</td><td>添加与key对应的元素</td><td>putJob</td></tr><tr><td>remove</td><td>移除元素</td><td>removeJob</td></tr><tr><td>enqueue</td><td>添加到队列的最末位</td><td>enqueueJob</td></tr><tr><td>dequeue</td><td>从队列中头部取出并移除</td><td>dequeueJob</td></tr><tr><td>push</td><td>添加到栈头</td><td>pushJob</td></tr><tr><td>pop</td><td>从栈头取出并移除</td><td>popJob</td></tr><tr><td>peek</td><td>从栈头取出但不移除</td><td>peekJob</td></tr><tr><td>find</td><td>寻找符合条件的某物</td><td>findById</td></tr></tbody></table><h3 id="4-8-与数据相关的方法"><a href="#4-8-与数据相关的方法" class="headerlink" title="4.8 与数据相关的方法"></a>4.8 与数据相关的方法</h3><table><thead><tr><th>单词</th><th>意义</th><th>例</th></tr></thead><tbody><tr><td>create</td><td>新创建</td><td>createAccount</td></tr><tr><td>new</td><td>新创建</td><td>newAccount</td></tr><tr><td>from</td><td>从既有的某物新建，或是从其他的数据新建</td><td>fromConfig</td></tr><tr><td>to</td><td>转换</td><td>toString</td></tr><tr><td>update</td><td>更新既有某物</td><td>updateAccount</td></tr><tr><td>load</td><td>读取</td><td>loadAccount</td></tr><tr><td>fetch</td><td>远程读取</td><td>fetchAccount</td></tr><tr><td>delete</td><td>删除</td><td>deleteAccount</td></tr><tr><td>remove</td><td>删除</td><td>removeAccount</td></tr><tr><td>save</td><td>保存</td><td>saveAccount</td></tr><tr><td>store</td><td>保存</td><td>storeAccount</td></tr><tr><td>commit</td><td>保存</td><td>commitChange</td></tr><tr><td>apply</td><td>保存或应用</td><td>applyChange</td></tr><tr><td>clear</td><td>清除数据或是恢复到初始状态</td><td>clearAll</td></tr><tr><td>reset</td><td>清除数据或是恢复到初始状态</td><td>resetAll</td></tr></tbody></table><h3 id="4-9-成对出现的动词"><a href="#4-9-成对出现的动词" class="headerlink" title="4.9 成对出现的动词"></a>4.9 成对出现的动词</h3><table><thead><tr><th>单词</th><th>意义</th></tr></thead><tbody><tr><td>get获取</td><td>set 设置</td></tr><tr><td>add 增加</td><td>remove 删除</td></tr><tr><td>create 创建</td><td>destory 移除</td></tr><tr><td>start 启动</td><td>stop 停止</td></tr><tr><td>open 打开</td><td>close 关闭</td></tr><tr><td>read 读取</td><td>write 写入</td></tr><tr><td>load 载入</td><td>save 保存</td></tr><tr><td>create 创建</td><td>destroy 销毁</td></tr><tr><td>begin 开始</td><td>end 结束</td></tr><tr><td>backup 备份</td><td>restore 恢复</td></tr><tr><td>import 导入</td><td>export 导出</td></tr><tr><td>split 分割</td><td>merge 合并</td></tr><tr><td>inject 注入</td><td>extract 提取</td></tr><tr><td>attach 附着</td><td>detach 脱离</td></tr><tr><td>bind 绑定</td><td>separate 分离</td></tr><tr><td>view 查看</td><td>browse 浏览</td></tr><tr><td>edit 编辑</td><td>modify 修改</td></tr><tr><td>select 选取</td><td>mark 标记</td></tr><tr><td>copy 复制</td><td>paste 粘贴</td></tr><tr><td>undo 撤销</td><td>redo 重做</td></tr><tr><td>insert 插入</td><td>delete 移除</td></tr><tr><td>add 加入</td><td>append 添加</td></tr><tr><td>clean 清理</td><td>clear 清除</td></tr><tr><td>index 索引</td><td>sort 排序</td></tr><tr><td>find 查找</td><td>search 搜索</td></tr><tr><td>increase 增加</td><td>decrease 减少</td></tr><tr><td>play 播放</td><td>pause 暂停</td></tr><tr><td>launch 启动</td><td>run 运行</td></tr><tr><td>compile 编译</td><td>execute 执行</td></tr><tr><td>debug 调试</td><td>trace 跟踪</td></tr><tr><td>observe 观察</td><td>listen 监听</td></tr><tr><td>build 构建</td><td>publish 发布</td></tr><tr><td>input 输入</td><td>output 输出</td></tr><tr><td>encode 编码</td><td>decode 解码</td></tr><tr><td>encrypt 加密</td><td>decrypt 解密</td></tr><tr><td>compress 压缩</td><td>decompress 解压缩</td></tr><tr><td>pack 打包</td><td>unpack 解包</td></tr><tr><td>parse 解析</td><td>emit 生成</td></tr><tr><td>connect 连接</td><td>disconnect 断开</td></tr><tr><td>send 发送</td><td>receive 接收</td></tr><tr><td>download 下载</td><td>upload 上传</td></tr><tr><td>refresh 刷新</td><td>synchronize 同步</td></tr><tr><td>update 更新</td><td>revert 复原</td></tr><tr><td>lock 锁定</td><td>unlock 解锁</td></tr><tr><td>check out 签出</td><td>check in 签入</td></tr><tr><td>submit 提交</td><td>commit 交付</td></tr><tr><td>push 推</td><td>pull 拉</td></tr><tr><td>expand 展开</td><td>collapse 折叠</td></tr><tr><td>begin 起始</td><td>end 结束</td></tr><tr><td>start 开始</td><td>finish 完成</td></tr><tr><td>enter 进入</td><td>exit 退出</td></tr><tr><td>abort 放弃</td><td>quit 离开</td></tr><tr><td>obsolete 废弃</td><td>depreciate 废旧</td></tr><tr><td>collect 收集</td><td>aggregate 聚集</td></tr></tbody></table><h2 id="五，变量-amp-常量命名"><a href="#五，变量-amp-常量命名" class="headerlink" title="五，变量&amp;常量命名"></a>五，变量&amp;常量命名</h2><h3 id="5-1-变量命名"><a href="#5-1-变量命名" class="headerlink" title="5.1 变量命名"></a>5.1 变量命名</h3><p>变量是指在程序运行中可以改变其值的量，包括成员变量和局部变量。变量名由多单词组成时，第一个单词的首字母小写，其后单词的首字母大写，俗称骆驼式命名法（也称驼峰命名法），如 computedValues，index、变量命名时，尽量简短且能清楚的表达变量的作用，命名体现具体的业务含义即可。</p><p>变量名不应以下划线或美元符号开头，尽管这在语法上是允许的。变量名应简短且富于描述。变量名的选用应该易于记忆，即，能够指出其用途。尽量避免单个字符的变量名，除非是一次性的临时变量。pojo中的布尔变量，都不要加is(数据库中的布尔字段全都要加 is_ 前缀)。</p><h3 id="5-2-常量命名"><a href="#5-2-常量命名" class="headerlink" title="5.2 常量命名"></a>5.2 常量命名</h3><p>常量命名CONSTANT_CASE，一般采用全部大写（作为方法参数时除外），单词间用下划线分割。那么什么是常量呢？</p><p>常量是在作用域内保持不变的值，一般使用final进行修饰。一般分为三种，全局常量（public static final修饰），类内常量（private static final 修饰）以及局部常量（方法内，或者参数中的常量），局部常量比较特殊，通常采用小驼峰命名即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个demo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Jann Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-12-07 00:25</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 局部常量(正例)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> USER_MESSAGE_CACHE_EXPIRE_TIME = <span class="number">3600</span>;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 局部常量(反例，命名不清晰）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MESSAGE_CACHE_TIME = <span class="number">3600</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局常量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERROR_MESSAGE = <span class="string">" error message"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 成员变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentUserId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 控制台打印 &#123;<span class="doctag">@code</span> message&#125; 信息</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息体，局部常量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">final</span> String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量一般都有自己的业务含义,<strong>不要害怕长度过长而进行省略或者缩写</strong>。如，用户消息缓存过期时间的表示，那种方式更佳清晰，交给你来评判。</p><h2 id="通用命名规则"><a href="#通用命名规则" class="headerlink" title="通用命名规则#"></a>通用命名规则<a href="https://www.cnblogs.com/liqiangchn/p/12000361.html#450918152" target="_blank" rel="noopener">#</a></h2><ol><li>尽量不要使用拼音；杜绝拼音和英文混用。对于一些通用的表示或者难以用英文描述的可以采用拼音，一旦采用拼音就坚决不能和英文混用。<br>正例： BeiJing， HangZhou<br>反例： validateCanShu</li><li>命名过程中尽量不要出现特殊的字符，常量除外。</li><li>尽量不要和jdk或者框架中已存在的类重名，也不能使用java中的关键字命名。</li><li>妙用介词，如for(可以用同音的4代替), to(可用同音的2代替), from, with，of等。<br>如类名采用User4RedisDO，方法名getUserInfoFromRedis，convertJson2Map等。</li></ol><h2 id="六，代码注解"><a href="#六，代码注解" class="headerlink" title="六，代码注解"></a>六，代码注解</h2><h3 id="6-1-注解的原则"><a href="#6-1-注解的原则" class="headerlink" title="6.1 注解的原则"></a>6.1 注解的原则</h3><p>好的命名增加代码阅读性，代码的命名往往有严格的限制。而注解不同，程序员往往可以自由发挥，单并不意味着可以为所欲为之胡作非为。优雅的注解通常要满足三要素。</p><ol><li>Nothing is strange<br>没有注解的代码对于阅读者非常不友好，哪怕代码写的在清除，阅读者至少从心理上会有抵触，更何况代码中往往有许多复杂的逻辑，所以一定要写注解，不仅要记录代码的逻辑，还有说清楚修改的逻辑。</li><li>Less is more<br>从代码维护角度来讲，代码中的注解一定是精华中的精华。合理清晰的命名能让代码易于理解，对于逻辑简单且命名规范，能够清楚表达代码功能的代码不需要注解。滥用注解会增加额外的负担，更何况大部分都是废话。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据id获取信息【废话注解】</span></span><br><span class="line">getMessageById(id)</span><br></pre></td></tr></table></figure><ol><li>Advance with the time<br>注解应该随着代码的变动而改变，注解表达的信息要与代码中完全一致。通常情况下修改代码后一定要修改注解。</li></ol><h3 id="6-2-注解格式"><a href="#6-2-注解格式" class="headerlink" title="6.2 注解格式"></a>6.2 注解格式</h3><p>注解大体上可以分为两种，一种是javadoc注解，另一种是简单注解。javadoc注解可以生成JavaAPI为外部用户提供有效的支持javadoc注解通常在使用IDEA，或者Eclipse等开发工具时都可以自动生成，也支持自定义的注解模板，仅需要对对应的字段进行解释。参与同一项目开发的同学，尽量设置成相同的注解模板。</p><h4 id="a-包注解"><a href="#a-包注解" class="headerlink" title="a. 包注解"></a>a. 包注解</h4><p>包注解在工作中往往比较特殊，通过包注解可以快速知悉当前包下代码是用来实现哪些功能，强烈建议工作中加上，尤其是对于一些比较复杂的包，包注解一般在包的根目录下，名称统一为package-info.java。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 落地也质量检测</span></span><br><span class="line"><span class="comment"> * 1. 用来解决什么问题</span></span><br><span class="line"><span class="comment"> * 对广告主投放的广告落地页进行性能检测，模拟不同的系统，如Android，IOS等; 模拟不同的网络：2G，3G，4G，wifi等</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 如何实现</span></span><br><span class="line"><span class="comment"> * 基于chrome浏览器，用chromedriver驱动浏览器，设置对应的网络，OS参数，获取到浏览器返回结果。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意： 网络环境配置信息&#123;<span class="doctag">@link</span> cn.mycookies.landingpagecheck.meta.NetWorkSpeedEnum&#125;目前使用是常规速度，可以根据实际情况进行调整</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cruder</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 2019/12/7 20:3 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> cn.mycookies.landingpagecheck;</span><br></pre></td></tr></table></figure><h4 id="b-类注接"><a href="#b-类注接" class="headerlink" title="b. 类注接"></a>b. 类注接</h4><p>javadoc注解中，每个类都必须有注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright (C), 2019-2020, Jann  balabala...</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 类的介绍：这是一个用来做什么事情的类，有哪些功能，用到的技术.....</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>   类创建者姓名 保持对齐</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span>     创建日期 保持对齐</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span>  版本号 保持对齐</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="c-属性注解"><a href="#c-属性注解" class="headerlink" title="c. 属性注解"></a>c. 属性注解</h4><p>在每个属性前面必须加上属性注释，通常有以下两种形式，至于怎么选择，你高兴就好，不过一个项目中要保持统一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 提示信息 */</span></span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br></pre></td></tr></table></figure><h4 id="d-方法注释"><a href="#d-方法注释" class="headerlink" title="d. 方法注释"></a>d. 方法注释</h4><p>在每个方法前面必须加上方法注释，对于方法中的每个参数，以及返回值都要有说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 方法的详细说明，能干嘛，怎么实现的，注意事项...</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> xxx  参数1的使用说明， 能否为null</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 返回结果的说明， 不同情况下会返回怎样的结果</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> 异常类型   注明从此类方法中抛出异常的说明</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h4 id="e-构造方法注释"><a href="#e-构造方法注释" class="headerlink" title="e. 构造方法注释"></a>e. 构造方法注释</h4><p>在每个构造方法前面必须加上注释，注释模板如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造方法的详细说明</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> xxx  参数1的使用说明， 能否为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> 异常类型   注明从此类方法中抛出异常的说明</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>而简单注解往往是需要工程师字节定义，在使用注解时应该注意以下几点：</p><ol><li>枚举类的各个属性值都要使用注解，枚举可以理解为是常量，通常不会发生改变，通常会被在多个地方引用，对枚举的修改和添加属性通常会带来很大的影响。</li><li>保持排版整洁，不要使用行尾注释；双斜杠和星号之后要用1个空格分隔。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">id = <span class="number">1</span>;<span class="comment">// 反例：不要使用行尾注释</span></span><br><span class="line"><span class="comment">//反例：换行符与注释之间没有缩进</span></span><br><span class="line"><span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="comment">// 正例：姓名</span></span><br><span class="line">String name;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 多行注释</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2. 对于不同的逻辑说明，可以用空行分隔</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是命名和注解，他们的目的都是为了让代码和工程师进行对话，增强代码的可读性，可维护性。优秀的代码往往能够见名知意，注解往往是对命名的补充和完善。命名太南了！</p><p>参考文献：</p><ul><li>《码出高效》</li><li><a href="https://www.cnblogs.com/wangcp-2014/p/10215620.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangcp-2014/p/10215620.html</a></li><li><a href="https://qiita.com/KeithYokoma/items/2193cf79ba76563e3db6" target="_blank" rel="noopener">https://qiita.com/KeithYokoma/items/2193cf79ba76563e3db6</a></li><li><a href="https://google.github.io/styleguide/javaguide.html#s2.1-file-name" target="_blank" rel="noopener">https://google.github.io/styleguide/javaguide.html#s2.1-file-name</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程系列</title>
      <link href="/posts/d0e8ab59/"/>
      <url>/posts/d0e8ab59/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p><h2 id="多线程系列文章"><a href="#多线程系列文章" class="headerlink" title="多线程系列文章"></a>多线程系列文章</h2><p>下列文章，我都更新在了我的博客专栏：<a href="https://blog.csdn.net/column/details/20860.html" target="_blank" rel="noopener">Java并发编程指南</a>。</p></blockquote><ol><li><p><a href="http://blog.csdn.net/qq_34337272/article/details/79640870" target="_blank" rel="noopener">Java多线程学习（一）Java多线程入门</a></p></li><li><p><a href="http://blog.csdn.net/qq_34337272/article/details/79655194" target="_blank" rel="noopener">Java多线程学习（二）synchronized关键字（1）</a></p></li><li><p><a href="http://blog.csdn.net/qq_34337272/article/details/79670775" target="_blank" rel="noopener">Java多线程学习（二）synchronized关键字（2）</a></p></li><li><p><a href="http://blog.csdn.net/qq_34337272/article/details/79680771" target="_blank" rel="noopener">Java多线程学习（三）volatile关键字</a></p></li><li><p><a href="http://blog.csdn.net/qq_34337272/article/details/79690279" target="_blank" rel="noopener">Java多线程学习（四）等待/通知（wait/notify）机制</a></p></li><li><p><a href="http://blog.csdn.net/qq_34337272/article/details/79694226" target="_blank" rel="noopener">Java多线程学习（五）线程间通信知识点补充</a></p></li><li><p><a href="http://blog.csdn.net/qq_34337272/article/details/79714196" target="_blank" rel="noopener">Java多线程学习（六）Lock锁的使用</a></p></li><li><p><a href="https://blog.csdn.net/qq_34337272/article/details/79844051" target="_blank" rel="noopener">Java多线程学习（七）并发编程中一些问题</a></p></li><li><p><a href="https://blog.csdn.net/qq_34337272/article/details/79959271" target="_blank" rel="noopener">Java多线程学习（八）线程池与Executor 框架</a></p></li></ol><blockquote><h2 id="多线程系列文章重要知识点与思维导图"><a href="#多线程系列文章重要知识点与思维导图" class="headerlink" title="多线程系列文章重要知识点与思维导图"></a>多线程系列文章重要知识点与思维导图</h2></blockquote><h3 id="Java多线程学习（一）Java多线程入门"><a href="#Java多线程学习（一）Java多线程入门" class="headerlink" title="Java多线程学习（一）Java多线程入门"></a>Java多线程学习（一）Java多线程入门</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://user-gold-cdn.xitu.io/2018/8/4/16504e0cb6bac32e?w=758&h=772&f=jpeg&s=247210" alt=""></p><h3 id="Java多线程学习（二）synchronized关键字（1）"><a href="#Java多线程学习（二）synchronized关键字（1）" class="headerlink" title="Java多线程学习（二）synchronized关键字（1）"></a>Java多线程学习（二）synchronized关键字（1）</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://user-gold-cdn.xitu.io/2018/8/4/16504e245ceb3ea9?w=1028&h=490&f=jpeg&s=203811" alt=""></p><p>注意：<strong>可重入锁的概念</strong>。</p><p>   另外要注意：<strong>synchronized取得的锁都是对象锁，而不是把一段代码或方法当做锁。</strong> 如果多个线程访问的是同一个对象，哪个线程先执行带synchronized关键字的方法，则哪个线程就持有该方法，那么其他线程只能呈等待状态。如果多个线程访问的是多个对象则不一定，因为多个对象会产生多个锁。</p><h3 id="Java多线程学习（二）synchronized关键字（2）"><a href="#Java多线程学习（二）synchronized关键字（2）" class="headerlink" title="Java多线程学习（二）synchronized关键字（2）"></a>Java多线程学习（二）synchronized关键字（2）</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://user-gold-cdn.xitu.io/2018/8/4/16504e3d98213324?w=1448&h=439&f=jpeg&s=245012" alt="思维导图"></p><p>   <strong>注意：</strong></p><ul><li>其他线程执行对象中<strong>synchronized同步方法</strong>（上一节我们介绍过，需要回顾的可以看上一节的文章）和<strong>synchronized(this)代码块</strong>时呈现同步效果;</li><li><strong>如果两个线程使用了同一个“对象监视器”（synchronized(object)）,运行结果同步，否则不同步</strong>.</li></ul><p>   <strong>synchronized关键字加到static静态方法</strong>和<strong>synchronized(class)代码块</strong>上都是是给<strong>Class类</strong>上锁，而<strong>synchronized关键字加到非static静态方法</strong>上是给<strong>对象</strong>上锁。</p><p>   数据类型String的常量池属性:<strong>在Jvm中具有String常量池缓存的功能</strong></p><h3 id="Java多线程学习（三）volatile关键字"><a href="#Java多线程学习（三）volatile关键字" class="headerlink" title="Java多线程学习（三）volatile关键字"></a>Java多线程学习（三）volatile关键字</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://user-gold-cdn.xitu.io/2018/8/4/16504e4ab69d8d58" alt="volatile关键字"><br>   <strong>注意：</strong></p><p>   <strong>synchronized关键字</strong>和<strong>volatile关键字</strong>比较</p><h3 id="Java多线程学习（四）等待-通知（wait-notify）机制"><a href="#Java多线程学习（四）等待-通知（wait-notify）机制" class="headerlink" title="Java多线程学习（四）等待/通知（wait/notify）机制"></a>Java多线程学习（四）等待/通知（wait/notify）机制</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://user-gold-cdn.xitu.io/2018/3/25/1625d2a9188ec021?w=1254&h=452&f=jpeg&s=229471" alt="本节思维导图"></p><h3 id="Java多线程学习（五）线程间通信知识点补充"><a href="#Java多线程学习（五）线程间通信知识点补充" class="headerlink" title="Java多线程学习（五）线程间通信知识点补充"></a>Java多线程学习（五）线程间通信知识点补充</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://user-gold-cdn.xitu.io/2018/8/4/16504e618d6886c5?w=1146&h=427&f=jpeg&s=220573" alt="本节思维导图"><br>   <strong>注意：</strong> ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</p><h3 id="Java多线程学习（六）Lock锁的使用"><a href="#Java多线程学习（六）Lock锁的使用" class="headerlink" title="Java多线程学习（六）Lock锁的使用"></a>Java多线程学习（六）Lock锁的使用</h3><p>   <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://user-gold-cdn.xitu.io/2018/3/27/1626755a8e9a8774?w=1197&h=571&f=jpeg&s=258439" alt="本节思维导图"></p><h3 id="Java多线程学习（七）并发编程中一些问题"><a href="#Java多线程学习（七）并发编程中一些问题" class="headerlink" title="Java多线程学习（七）并发编程中一些问题"></a>Java多线程学习（七）并发编程中一些问题</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://user-gold-cdn.xitu.io/2018/4/7/162a01b71ebc4842?w=1067&h=517&f=png&s=36857" alt="思维导图"></p><h3 id="Java多线程学习（八）线程池与Executor-框架"><a href="#Java多线程学习（八）线程池与Executor-框架" class="headerlink" title="Java多线程学习（八）线程池与Executor 框架"></a>Java多线程学习（八）线程池与Executor 框架</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-14/86510659.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手教你定位常见Java性能问题</title>
      <link href="/posts/c91f9dad/"/>
      <url>/posts/c91f9dad/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><h2 id="手把手教你定位常见Java性能问题"><a href="#手把手教你定位常见Java性能问题" class="headerlink" title="手把手教你定位常见Java性能问题"></a>手把手教你定位常见Java性能问题</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>性能优化一向是后端服务优化的重点，但是线上性能故障问题不是经常出现，或者受限于业务产品，根本就没办法出现性能问题，包括笔者自己遇到的性能问题也不多，所以为了提前储备知识，当出现问题的时候不会手忙脚乱，我们本篇文章来模拟下常见的几个Java性能故障，来学习怎么去分析和定位。</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>既然是定位问题，肯定是需要借助工具，我们先了解下需要哪些工具可以帮忙定位问题。</p><p> <strong>top命令</strong> </p><p><code>top</code>命令使我们最常用的Linux命令之一，它可以实时的显示当前正在执行的进程的CPU使用率，内存使用率等系统信息。<code>top -Hp pid</code> 可以查看线程的系统资源使用情况。</p><p> <strong>vmstat命令</strong> </p><p>vmstat是一个指定周期和采集次数的虚拟内存检测工具，可以统计内存，CPU，swap的使用情况，它还有一个重要的常用功能，用来观察进程的上下文切换。字段说明如下:</p><ul><li><p>r: 运行队列中进程数量（当数量大于CPU核数表示有阻塞的线程）</p></li><li><p>b: 等待IO的进程数量</p></li><li><p>swpd: 使用虚拟内存大小</p></li><li><p>free: 空闲物理内存大小</p></li><li><p>buff: 用作缓冲的内存大小(内存和硬盘的缓冲区)</p></li><li><p>cache: 用作缓存的内存大小（CPU和内存之间的缓冲区）</p></li><li><p>si: 每秒从交换区写到内存的大小，由磁盘调入内存</p></li><li><p>so: 每秒写入交换区的内存大小，由内存调入磁盘</p></li><li><p>bi: 每秒读取的块数</p></li><li><p>bo: 每秒写入的块数</p></li><li><p>in: 每秒中断数，包括时钟中断。</p></li><li><p>cs: 每秒上下文切换数。</p></li><li><p>us: 用户进程执行时间百分比(user time)</p></li><li><p>sy: 内核系统进程执行时间百分比(system time)</p></li><li><p>wa: IO等待时间百分比</p></li><li><p>id: 空闲时间百分比</p><p><strong>pidstat命令</strong></p></li></ul><p>pidstat 是 Sysstat 中的一个组件，也是一款功能强大的性能监测工具，<code>top</code> 和 <code>vmstat</code> 两个命令都是监测进程的内存、CPU 以及 I/O 使用情况，而 pidstat 命令可以检测到线程级别的。<code>pidstat</code>命令线程切换字段说明如下：</p><ul><li><p>UID ：被监控任务的真实用户ID。</p></li><li><p>TGID ：线程组ID。</p></li><li><p>TID：线程ID。</p></li><li><p>cswch/s：主动切换上下文次数，这里是因为资源阻塞而切换线程，比如锁等待等情况。</p></li><li><p>nvcswch/s：被动切换上下文次数，这里指CPU调度切换了线程。</p><p><strong>jstack命令</strong></p></li></ul><p>jstack是JDK工具命令，它是一种线程堆栈分析工具，最常用的功能就是使用 <code>jstack pid</code> 命令查看线程的堆栈信息，也经常用来排除死锁情况。</p><p><strong>jstat 命令</strong></p><p>它可以检测Java程序运行的实时情况，包括堆内存信息和垃圾回收信息，我们常常用来查看程序垃圾回收情况。常用的命令是<code>jstat -gc pid</code>。信息字段说明如下：</p><ul><li><p>S0C：年轻代中 To Survivor 的容量（单位 KB）；</p></li><li><p>S1C：年轻代中 From Survivor 的容量（单位 KB）；</p></li><li><p>S0U：年轻代中 To Survivor 目前已使用空间（单位 KB）；</p></li><li><p>S1U：年轻代中 From Survivor 目前已使用空间（单位 KB）；</p></li><li><p>EC：年轻代中 Eden 的容量（单位 KB）；</p></li><li><p>EU：年轻代中 Eden 目前已使用空间（单位 KB）；</p></li><li><p>OC：老年代的容量（单位 KB）；</p></li><li><p>OU：老年代目前已使用空间（单位 KB）；</p></li><li><p>MC：元空间的容量（单位 KB）；</p></li><li><p>MU：元空间目前已使用空间（单位 KB）；</p></li><li><p>YGC：从应用程序启动到采样时年轻代中 gc 次数；</p></li><li><p>YGCT：从应用程序启动到采样时年轻代中 gc 所用时间 (s)；</p></li><li><p>FGC：从应用程序启动到采样时 老年代（Full Gc）gc 次数；</p></li><li><p>FGCT：从应用程序启动到采样时 老年代代（Full Gc）gc 所用时间 (s)；</p></li><li><p>GCT：从应用程序启动到采样时 gc 用的总时间 (s)。</p></li></ul><p> <strong>jmap命令</strong></p><p>jmap也是JDK工具命令，他可以查看堆内存的初始化信息以及堆内存的使用情况，还可以生成dump文件来进行详细分析。查看堆内存情况命令<code>jmap -heap pid</code>。</p><p> <strong>mat内存工具</strong></p><p>MAT(Memory Analyzer Tool)工具是eclipse的一个插件(MAT也可以单独使用)，它分析大内存的dump文件时，可以非常直观的看到各个对象在堆空间中所占用的内存大小、类实例数量、对象引用关系、利用OQL对象查询，以及可以很方便的找出对象GC Roots的相关信息。</p><p><strong>idea中也有这么一个插件，就是JProfiler</strong>。 </p><p>相关阅读：</p><ol><li>《性能诊断利器 JProfiler 快速入门和最佳实践》：<a href="https://segmentfault.com/a/1190000017795841" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017795841</a></li></ol><h2 id="模拟环境准备"><a href="#模拟环境准备" class="headerlink" title="模拟环境准备"></a>模拟环境准备</h2><p>基础环境jdk1.8，采用SpringBoot框架来写几个接口来触发模拟场景，首先是模拟CPU占满情况</p><h2 id="CPU占满"><a href="#CPU占满" class="headerlink" title="CPU占满"></a>CPU占满</h2><p>模拟CPU占满还是比较简单，直接写一个死循环计算消耗CPU即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 模拟CPU占满</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@GetMapping</span>(<span class="string">"/cpu/loop"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCPULoop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"请求cpu死循环"</span>);</span><br><span class="line">      Thread.currentThread().setName(<span class="string">"loop-thread-cpu"</span>);</span><br><span class="line">      <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          num++;</span><br><span class="line">          <span class="keyword">if</span> (num == Integer.MAX_VALUE) &#123;</span><br><span class="line">              System.out.println(<span class="string">"reset"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          num = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>请求接口地址测试<code>curl localhost:8080/cpu/loop</code>,发现CPU立马飙升到100%</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="./images/performance-tuning/java-performance1.png" alt=""></p><p>通过执行<code>top -Hp 32805</code> 查看Java线程情况</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="./images/performance-tuning/java-performance2.png" alt=""></p><p>执行 <code>printf &#39;%x&#39; 32826</code> 获取16进制的线程id，用于<code>dump</code>信息查询，结果为 <code>803a</code>。最后我们执行<code>jstack 32805 |grep -A 20 803a</code>来查看下详细的<code>dump</code>信息。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="./images/performance-tuning/java-performance3.png" alt=""></p><p>这里<code>dump</code>信息直接定位出了问题方法以及代码行，这就定位出了CPU占满的问题。</p><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>模拟内存泄漏借助了ThreadLocal对象来完成，ThreadLocal是一个线程私有变量，可以绑定到线程上，在整个线程的生命周期都会存在，但是由于ThreadLocal的特殊性，ThreadLocal是基于ThreadLocalMap实现的，ThreadLocalMap的Entry继承WeakReference，而Entry的Key是WeakReference的封装，换句话说Key就是弱引用，弱引用在下次GC之后就会被回收，如果ThreadLocal在set之后不进行后续的操作，因为GC会把Key清除掉，但是Value由于线程还在存活，所以Value一直不会被回收，最后就会发生内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟内存泄漏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/memory/leak"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">leak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"模拟内存泄漏"</span>);</span><br><span class="line">        ThreadLocal&lt;Byte[]&gt; localVariable = <span class="keyword">new</span> ThreadLocal&lt;Byte[]&gt;();</span><br><span class="line">        localVariable.set(<span class="keyword">new</span> Byte[<span class="number">4096</span> * <span class="number">1024</span>]);<span class="comment">// 为线程添加变量</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们给启动加上堆内存大小限制，同时设置内存溢出的时候输出堆栈快照并输出日志。</p><p><code>java -jar -Xms500m -Xmx500m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof  -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:/tmp/heaplog.log analysis-demo-0.0.1-SNAPSHOT.jar</code></p><p>启动成功后我们循环执行100次,<code>for i in {1..500}; do curl localhost:8080/memory/leak;done</code>,还没执行完毕，系统已经返回500错误了。查看系统日志出现了如下异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure><p>我们用<code>jstat -gc pid</code> 命令来看看程序的GC情况。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="./images/performance-tuning/java-performance4.png" alt=""></p><p>很明显，内存溢出了，堆内存经过45次 Full Gc 之后都没释放出可用内存，这说明当前堆内存中的对象都是存活的，有GC Roots引用，无法回收。那是什么原因导致内存溢出呢？是不是我只要加大内存就行了呢？如果是普通的内存溢出也许扩大内存就行了，但是如果是内存泄漏的话，扩大的内存不一会就会被占满，所以我们还需要确定是不是内存泄漏。我们之前保存了堆 Dump 文件，这个时候借助我们的MAT工具来分析下。导入工具选择<code>Leak Suspects Report</code>，工具直接就会给你列出问题报告。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="./images/performance-tuning/java-performance5.png" alt=""></p><p>这里已经列出了可疑的4个内存泄漏问题，我们点击其中一个查看详情。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="./images/performance-tuning/java-performance6.png" alt=""></p><p>这里已经指出了内存被线程占用了接近50M的内存，占用的对象就是ThreadLocal。如果想详细的通过手动去分析的话，可以点击<code>Histogram</code>,查看最大的对象占用是谁，然后再分析它的引用关系，即可确定是谁导致的内存溢出。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="./images/performance-tuning/java-performance7.png" alt=""></p><p>上图发现占用内存最大的对象是一个Byte数组，我们看看它到底被那个GC Root引用导致没有被回收。按照上图红框操作指引，结果如下图：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="./images/performance-tuning/java-performance8.png" alt=""></p><p>我们发现Byte数组是被线程对象引用的，图中也标明，Byte数组对像的GC Root是线程，所以它是不会被回收的，展开详细信息查看，我们发现最终的内存占用对象是被ThreadLocal对象占据了。这也和MAT工具自动帮我们分析的结果一致。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁会导致耗尽线程资源，占用内存，表现就是内存占用升高，CPU不一定会飙升(看场景决定)，如果是直接new线程，会导致JVM内存被耗尽，报无法创建线程的错误，这也是体现了使用线程池的好处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> ExecutorService service = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">4</span>, <span class="number">10</span>,</span><br><span class="line">            <span class="number">0</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟死锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/cpu/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testCPU</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请求cpu"</span>);</span><br><span class="line">        Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">        Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line">        service.submit(<span class="keyword">new</span> DeadLockThread(lock1, lock2), <span class="string">"deadLookThread-"</span> + <span class="keyword">new</span> Random().nextInt());</span><br><span class="line">        service.submit(<span class="keyword">new</span> DeadLockThread(lock2, lock1), <span class="string">"deadLookThread-"</span> + <span class="keyword">new</span> Random().nextInt());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object lock1;</span><br><span class="line">    <span class="keyword">private</span> Object lock2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeadLockThread1</span><span class="params">(Object lock1, Object lock2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock1 = lock1;</span><br><span class="line">        <span class="keyword">this</span>.lock2 = lock2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"get lock2 and wait lock1"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"get lock1 and lock2 "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们循环请求接口2000次，发现不一会系统就出现了日志错误，线程池和队列都满了,由于我选择的当队列满了就拒绝的策略，所以系统直接抛出异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@2760298 rejected from java.util.concurrent.ThreadPoolExecutor@7ea7cd51[Running, pool size &#x3D; 10, active threads &#x3D; 10, queued tasks &#x3D; 1024, completed tasks &#x3D; 846]</span><br></pre></td></tr></table></figure><p>通过<code>ps -ef|grep java</code>命令找出 Java 进程 pid，执行<code>jstack pid</code> 即可出现java线程堆栈信息，这里发现了5个死锁，我们只列出其中一个，很明显线程<code>pool-1-thread-2</code>锁住了<code>0x00000000f8387d88</code>等待<code>0x00000000f8387d98</code>锁，线程<code>pool-1-thread-1</code>锁住了<code>0x00000000f8387d98</code>等待锁<code>0x00000000f8387d88</code>,这就产生了死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">"pool-1-thread-2"</span>:</span><br><span class="line">        at top.luozhou.analysisdemo.controller.DeadLockThread2.run(DeadLockThread.java:<span class="number">30</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0x00000000f8387d98</span>&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0x00000000f8387d88</span>&gt; (a java.lang.Object)</span><br><span class="line">        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:<span class="number">511</span>)</span><br><span class="line">        at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">266</span>)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="string">"pool-1-thread-1"</span>:</span><br><span class="line">        at top.luozhou.analysisdemo.controller.DeadLockThread1.run(DeadLockThread.java:<span class="number">30</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0x00000000f8387d88</span>&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0x00000000f8387d98</span>&gt; (a java.lang.Object)</span><br><span class="line">        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:<span class="number">511</span>)</span><br><span class="line">        at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">266</span>)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">          </span><br><span class="line"> Found <span class="number">5</span> deadlocks.</span><br></pre></td></tr></table></figure><h2 id="线程频繁切换"><a href="#线程频繁切换" class="headerlink" title="线程频繁切换"></a>线程频繁切换</h2><p>上下文切换会导致将大量CPU时间浪费在寄存器、内核栈以及虚拟内存的保存和恢复上，导致系统整体性能下降。当你发现系统的性能出现明显的下降时候，需要考虑是否发生了大量的线程上下文切换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@GetMapping</span>(value = <span class="string">"/thread/swap"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">theadSwap</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"模拟线程切换"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadSwap1(<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>)),<span class="string">"thread-swap"</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSwap1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger integer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadSwap1</span><span class="params">(AtomicInteger integer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.integer = integer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            integer.addAndGet(<span class="number">1</span>);</span><br><span class="line">            Thread.yield(); <span class="comment">//让出CPU资源</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我创建多个线程去执行基础的原子+1操作，然后让出 CPU 资源，理论上 CPU 就会去调度别的线程，我们请求接口创建100个线程看看效果如何，<code>curl localhost:8080/thread/swap?num=100</code>。接口请求成功后，我们执行`vmstat 1 10，表示每1秒打印一次，打印10次，线程切换采集结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line">101  0 128000 878384    908 468684    0    0     0     0 4071 8110498 14 86  0  0  0</span><br><span class="line">100  0 128000 878384    908 468684    0    0     0     0 4065 8312463 15 85  0  0  0</span><br><span class="line">100  0 128000 878384    908 468684    0    0     0     0 4107 8207718 14 87  0  0  0</span><br><span class="line">100  0 128000 878384    908 468684    0    0     0     0 4083 8410174 14 86  0  0  0</span><br><span class="line">100  0 128000 878384    908 468684    0    0     0     0 4083 8264377 14 86  0  0  0</span><br><span class="line">100  0 128000 878384    908 468688    0    0     0   108 4182 8346826 14 86  0  0  0</span><br></pre></td></tr></table></figure><p>这里我们关注4个指标，<code>r</code>,<code>cs</code>,<code>us</code>,<code>sy</code>。</p><p><strong>r=100</strong>,说明等待的进程数量是100，线程有阻塞。</p><p><strong>cs=800多万</strong>，说明每秒上下文切换了800多万次，这个数字相当大了。</p><p><strong>us=14</strong>，说明用户态占用了14%的CPU时间片去处理逻辑。</p><p><strong>sy=86</strong>，说明内核态占用了86%的CPU，这里明显就是做上下文切换工作了。</p><p>我们通过<code>top</code>命令以及<code>top -Hp pid</code>查看进程和线程CPU情况，发现Java线程CPU占满了，但是线程CPU使用情况很平均，没有某一个线程把CPU吃满的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                            </span><br><span class="line"> 87093 root      20   0 4194788 299056  13252 S 399.7 16.1  65:34.67 java</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                             </span><br><span class="line">87189 root      20   0 4194788 299056  13252 R  4.7 16.1   0:41.11 java                                                                                </span><br><span class="line">87129 root      20   0 4194788 299056  13252 R  4.3 16.1   0:41.14 java                                                                                </span><br><span class="line">87130 root      20   0 4194788 299056  13252 R  4.3 16.1   0:40.51 java                                                                                </span><br><span class="line">87133 root      20   0 4194788 299056  13252 R  4.3 16.1   0:40.59 java                                                                                </span><br><span class="line">87134 root      20   0 4194788 299056  13252 R  4.3 16.1   0:40.95 java</span><br></pre></td></tr></table></figure><p>结合上面用户态CPU只使用了14%，内核态CPU占用了86%，可以基本判断是Java程序线程上下文切换导致性能问题。</p><p>我们使用<code>pidstat</code>命令来看看Java进程内部的线程切换数据，执行<code>pidstat -p 87093 -w 1 10</code>,采集数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">11:04:30 PM   UID       TGID       TID   cswch&#x2F;s nvcswch&#x2F;s  Command</span><br><span class="line">11:04:30 PM     0         -     87128      0.00     16.07  |__java</span><br><span class="line">11:04:30 PM     0         -     87129      0.00     15.60  |__java</span><br><span class="line">11:04:30 PM     0         -     87130      0.00     15.54  |__java</span><br><span class="line">11:04:30 PM     0         -     87131      0.00     15.60  |__java</span><br><span class="line">11:04:30 PM     0         -     87132      0.00     15.43  |__java</span><br><span class="line">11:04:30 PM     0         -     87133      0.00     16.02  |__java</span><br><span class="line">11:04:30 PM     0         -     87134      0.00     15.66  |__java</span><br><span class="line">11:04:30 PM     0         -     87135      0.00     15.23  |__java</span><br><span class="line">11:04:30 PM     0         -     87136      0.00     15.33  |__java</span><br><span class="line">11:04:30 PM     0         -     87137      0.00     16.04  |__java</span><br></pre></td></tr></table></figure><p>根据上面采集的信息，我们知道Java的线程每秒切换15次左右，正常情况下，应该是个位数或者小数。结合这些信息我们可以断定Java线程开启过多，导致频繁上下文切换，从而影响了整体性能。</p><p><strong>为什么系统的上下文切换是每秒800多万，而 Java 进程中的某一个线程切换才15次左右？</strong></p><p>系统上下文切换分为三种情况:</p><p>1、多任务：在多任务环境中，一个进程被切换出CPU，运行另外一个进程，这里会发生上下文切换。</p><p>2、中断处理：发生中断时，硬件会切换上下文。在vmstat命令中是<code>in</code></p><p>3、用户和内核模式切换：当操作系统中需要在用户模式和内核模式之间进行转换时，需要进行上下文切换,比如进行系统函数调用。</p><p>Linux 为每个 CPU 维护了一个就绪队列，将活跃进程按照优先级和等待 CPU 的时间排序，然后选择最需要 CPU 的进程，也就是优先级最高和等待 CPU 时间最长的进程来运行。也就是vmstat命令中的<code>r</code>。</p><p>那么，进程在什么时候才会被调度到 CPU 上运行呢？</p><ul><li>进程执行完终止了，它之前使用的 CPU 会释放出来，这时再从就绪队列中拿一个新的进程来运行</li><li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片被轮流分配给各个进程。当某个进程时间片耗尽了就会被系统挂起，切换到其它等待 CPU 的进程运行。</li><li>进程在系统资源不足时，要等待资源满足后才可以运行，这时进程也会被挂起，并由系统调度其它进程运行。</li><li>当进程通过睡眠函数 sleep 主动挂起时，也会重新调度。</li><li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。</li><li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。</li></ul><p>结合我们之前的内容分析，阻塞的就绪队列是100左右，而我们的CPU只有4核，这部分原因造成的上下文切换就可能会相当高，再加上中断次数是4000左右和系统的函数调用等，整个系统的上下文切换到800万也不足为奇了。Java内部的线程切换才15次，是因为线程使用<code>Thread.yield()</code>来让出CPU资源，但是CPU有可能继续调度该线程，这个时候线程之间并没有切换，这也是为什么内部的某个线程切换次数并不是非常大的原因。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文模拟了常见的性能问题场景，分析了如何定位CPU100%、内存泄漏、死锁、线程频繁切换问题。分析问题我们需要做好两件事，第一，掌握基本的原理，第二，借助好工具。本文也列举了分析问题的常用工具和命令，希望对你解决问题有所帮助。当然真正的线上环境可能十分复杂，并没有模拟的环境那么简单，但是原理是一样的，问题的表现也是类似的，我们重点抓住原理，活学活用，相信复杂的线上问题也可以顺利解决。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1、<a href="https://linux.die.net/man/1/pidstat" target="_blank" rel="noopener">https://linux.die.net/man/1/pidstat</a></p><p>2、<a href="https://linux.die.net/man/8/vmstat" target="_blank" rel="noopener">https://linux.die.net/man/8/vmstat</a></p><p>3、<a href="https://help.eclipse.org/2020-03/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html" target="_blank" rel="noopener">https://help.eclipse.org/2020-03/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html</a></p><p>4、<a href="https://www.linuxblogs.cn/articles/18120200.html" target="_blank" rel="noopener">https://www.linuxblogs.cn/articles/18120200.html</a></p><p>5、<a href="https://www.tutorialspoint.com/what-is-context-switching-in-operating-system" target="_blank" rel="noopener">https://www.tutorialspoint.com/what-is-context-switching-in-operating-system</a></p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8Tutorial</title>
      <link href="/posts/9e3d4b21/"/>
      <url>/posts/9e3d4b21/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><p>随着 Java 8 的普及度越来越高，很多人都提到面试中关于Java 8 也是非常常问的知识点。应各位要求和需要，我打算对这部分知识做一个总结。本来准备自己总结的，后面看到Github 上有一个相关的仓库，地址：<br><a href="https://github.com/winterbe/java8-tutorial" target="_blank" rel="noopener">https://github.com/winterbe/java8-tutorial</a>。这个仓库是英文的，我对其进行了翻译并添加和修改了部分内容，下面是正文了。</p><h1 id="Java-8-Tutorial"><a href="#Java-8-Tutorial" class="headerlink" title="Java 8 Tutorial"></a>Java 8 Tutorial</h1><p>欢迎阅读我对Java 8的介绍。本教程将逐步指导您完成所有新语言功能。 在简短的代码示例的基础上，您将学习如何使用默认接口方法，lambda表达式，方法引用和可重复注释。 在本文的最后，您将熟悉最新的 API 更改，如流，函数式接口(Functional Interfaces)，Map 类的扩展和新的 Date API。 没有大段枯燥的文字，只有一堆注释的代码片段。</p><h3 id="接口的默认方法-Default-Methods-for-Interfaces"><a href="#接口的默认方法-Default-Methods-for-Interfaces" class="headerlink" title="接口的默认方法(Default Methods for Interfaces)"></a>接口的默认方法(Default Methods for Interfaces)</h3><p>Java 8使我们能够通过使用 <code>default</code> 关键字向接口添加非抽象方法实现。 此功能也称为<a href="http://stackoverflow.com/a/24102730" target="_blank" rel="noopener">虚拟扩展方法</a>。</p><p>第一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Formula 接口中除了抽象方法计算接口公式还定义了默认方法 <code>sqrt</code>。 实现该接口的类只需要实现抽象方法 <code>calculate</code>。 默认方法<code>sqrt</code> 可以直接使用。当然你也可以直接通过接口创建对象，然后实现接口中的默认方法就可以了，我们通过代码演示一下这种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过匿名内部类方式访问接口</span></span><br><span class="line">    Formula formula = <span class="keyword">new</span> Formula() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    System.out.println(formula.calculate(<span class="number">100</span>));     <span class="comment">// 100.0</span></span><br><span class="line">    System.out.println(formula.sqrt(<span class="number">16</span>));           <span class="comment">// 4.0</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> formula 是作为匿名对象实现的。该代码非常容易理解，6行代码实现了计算 <code>sqrt(a * 100)</code>。在下一节中，我们将会看到在 Java 8 中实现单个方法对象有一种更好更方便的方法。</p><p><strong>译者注：</strong> 不管是抽象类还是接口，都可以通过匿名内部类的方式访问。不能通过抽象类或者接口直接创建对象。对于上面通过匿名内部类方式访问接口，我们可以这样理解：一个内部类实现了接口里的抽象方法并且返回一个内部类对象，之后我们让接口的引用来指向这个对象。</p><h3 id="Lambda表达式-Lambda-expressions"><a href="#Lambda表达式-Lambda-expressions" class="headerlink" title="Lambda表达式(Lambda expressions)"></a>Lambda表达式(Lambda expressions)</h3><p>首先看看在老版本的Java中是如何排列字符串的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"peter"</span>, <span class="string">"anna"</span>, <span class="string">"mike"</span>, <span class="string">"xenia"</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>只需要给静态方法<code>Collections.sort</code> 传入一个 List 对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给 <code>sort</code> 方法。</p><p>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看出，代码变得更段且更具有可读性，但是实际上还可以写得更短：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure><p>对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.sort((a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure><p>List 类本身就有一个 <code>sort</code> 方法。并且Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还有什么其他用法。</p><h3 id="函数式接口-Functional-Interfaces"><a href="#函数式接口-Functional-Interfaces" class="headerlink" title="函数式接口(Functional Interfaces)"></a>函数式接口(Functional Interfaces)</h3><p><strong>译者注：</strong> 原文对这部分解释不太清楚，故做了修改！</p><p>Java 语言设计者们投入了大量精力来思考如何使现有的函数友好地支持Lambda。最终采取的方法是：增加函数式接口的概念。<strong>“函数式接口”是指仅仅只包含一个抽象方法,但是可以有多个非抽象方法(也就是上面提到的默认方法)的接口。</strong> 像这样的接口，可以被隐式转换为lambda表达式。<code>java.lang.Runnable</code> 与 <code>java.util.concurrent.Callable</code> 是函数式接口最典型的两个例子。Java 8增加了一种特殊的注解<code>@FunctionalInterface</code>,但是这个注解通常不是必须的(某些情况建议使用)，只要接口只包含一个抽象方法，虚拟机会自动判断该接口为函数式接口。一般建议在接口上使用<code>@FunctionalInterface</code> 注解进行声明，这样的话，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的，如下图所示</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/@FunctionalInterface.png" alt="@FunctionalInterface 注解"></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO 将数字字符串转换为整数类型</span></span><br><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted.getClass()); <span class="comment">//class java.lang.Integer</span></span><br></pre></td></tr></table></figure><p><strong>译者注：</strong> 大部分函数式接口都不用我们自己写，Java8都给我们实现好了，这些接口都在java.util.function包里。</p><h3 id="方法和构造函数引用-Method-and-Constructor-References"><a href="#方法和构造函数引用-Method-and-Constructor-References" class="headerlink" title="方法和构造函数引用(Method and Constructor References)"></a>方法和构造函数引用(Method and Constructor References)</h3><p>前一节中的代码还可以通过静态方法引用来表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted.getClass());   <span class="comment">//class java.lang.Integer</span></span><br></pre></td></tr></table></figure><p>Java 8允许您通过<code>::</code>关键字传递方法或构造函数的引用。 上面的示例显示了如何引用静态方法。 但我们也可以引用对象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">startsWith</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(s.charAt(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Something something = <span class="keyword">new</span> Something();</span><br><span class="line">Converter&lt;String, String&gt; converter = something::startsWith;</span><br><span class="line">String converted = converter.convert(<span class="string">"Java"</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// "J"</span></span><br></pre></td></tr></table></figure><p>接下来看看构造函数是如何使用<code>::</code>关键字来引用的，首先我们定义一个包含多个构造函数的简单类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line"></span><br><span class="line">    Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们指定一个用来创建Person对象的对象工厂接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">P <span class="title">create</span><span class="params">(String firstName, String lastName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用构造函数引用来将他们关联起来，而不是手动实现一个完整的工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;</span><br><span class="line">Person person = personFactory.create(<span class="string">"Peter"</span>, <span class="string">"Parker"</span>);</span><br></pre></td></tr></table></figure><p>我们只需要使用 <code>Person::new</code> 来获取Person类构造函数的引用，Java编译器会自动根据<code>PersonFactory.create</code>方法的参数类型来选择合适的构造函数。</p><h3 id="Lamda-表达式作用域-Lambda-Scopes"><a href="#Lamda-表达式作用域-Lambda-Scopes" class="headerlink" title="Lamda 表达式作用域(Lambda Scopes)"></a>Lamda 表达式作用域(Lambda Scopes)</h3><h4 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h4><p>我们可以直接在 lambda 表达式中访问外部的局部变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>不过这里的 num 必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line">num = <span class="number">3</span>;<span class="comment">//在lambda表达式中试图修改num同样是不允许的。</span></span><br></pre></td></tr></table></figure><h4 id="访问字段和静态变量"><a href="#访问字段和静态变量" class="headerlink" title="访问字段和静态变量"></a>访问字段和静态变量</h4><p>与局部变量相比，我们对lambda表达式中的实例字段和静态变量都有读写访问权限。 该行为和匿名对象是一致的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lambda4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> outerStaticNum;</span><br><span class="line">    <span class="keyword">int</span> outerNum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testScopes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</span><br><span class="line">            outerNum = <span class="number">23</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</span><br><span class="line">            outerStaticNum = <span class="number">72</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问默认接口方法"><a href="#访问默认接口方法" class="headerlink" title="访问默认接口方法"></a>访问默认接口方法</h4><p>还记得第一节中的 formula 示例吗？ <code>Formula</code> 接口定义了一个默认方法<code>sqrt</code>，可以从包含匿名对象的每个 formula 实例访问该方法。 这不适用于lambda表达式。</p><p>无法从 lambda 表达式中访问默认方法,故以下代码无法编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = (a) -&gt; sqrt(a * <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h3 id="内置函数式接口-Built-in-Functional-Interfaces"><a href="#内置函数式接口-Built-in-Functional-Interfaces" class="headerlink" title="内置函数式接口(Built-in Functional Interfaces)"></a>内置函数式接口(Built-in Functional Interfaces)</h3><p>JDK 1.8 API包含许多内置函数式接口。 其中一些借口在老版本的 Java 中是比较常见的比如： <code>Comparator</code> 或<code>Runnable</code>，这些接口都增加了<code>@FunctionalInterface</code>注解以便能用在 lambda 表达式上。</p><p>但是 Java 8 API 同样还提供了很多全新的函数式接口来让你的编程工作更加方便，有一些接口是来自 <a href="https://code.google.com/p/guava-libraries/" target="_blank" rel="noopener">Google Guava</a> 库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。</p><h4 id="Predicates"><a href="#Predicates" class="headerlink" title="Predicates"></a>Predicates</h4><p>Predicate 接口是只有一个参数的返回布尔类型值的 <strong>断言型</strong> 接口。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）：</p><p><strong>译者注：</strong> Predicate 接口源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.function;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该方法是接受一个传入类型,返回一个布尔值.此方法应用于判断.</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//and方法与关系型运算符"&amp;&amp;"相似，两边都成立才返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与关系运算符"!"相似，对判断进行取反</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//or方法与关系型运算符"||"相似，两边只要有一个成立就返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 该方法接收一个Object对象,返回一个Predicate类型.此方法用于判断第一个test的方法与第二个test方法相同(equal).</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">isEqual</span><span class="params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">predicate.test(<span class="string">"foo"</span>);              <span class="comment">// true</span></span><br><span class="line">predicate.negate().test(<span class="string">"foo"</span>);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br></pre></td></tr></table></figure><h4 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h4><p>Function 接口接受一个参数并生成结果。默认方法可用于将多个函数链接在一起（compose, andThen）：</p><p><strong>译者注：</strong> Function  接口源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util.function;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将Function对象应用到输入的参数上，然后返回计算结果。</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="comment">//将两个Function整合，并返回一个能够执行两个Function对象功能的Function对象。</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Function&lt;T, T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</span><br><span class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</span><br><span class="line">backToString.apply(<span class="string">"123"</span>);     <span class="comment">// "123"</span></span><br></pre></td></tr></table></figure><h4 id="Suppliers"><a href="#Suppliers" class="headerlink" title="Suppliers"></a>Suppliers</h4><p>Supplier 接口产生给定泛型类型的结果。 与 Function 接口不同，Supplier 接口不接受参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</span><br><span class="line">personSupplier.get();   <span class="comment">// new Person</span></span><br></pre></td></tr></table></figure><h4 id="Consumers"><a href="#Consumers" class="headerlink" title="Consumers"></a>Consumers</h4><p>Consumer 接口表示要对单个输入参数执行的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(<span class="string">"Hello, "</span> + p.firstName);</span><br><span class="line">greeter.accept(<span class="keyword">new</span> Person(<span class="string">"Luke"</span>, <span class="string">"Skywalker"</span>));</span><br></pre></td></tr></table></figure><h4 id="Comparators"><a href="#Comparators" class="headerlink" title="Comparators"></a>Comparators</h4><p>Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</span><br><span class="line"></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="string">"Doe"</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"Alice"</span>, <span class="string">"Wonderland"</span>);</span><br><span class="line"></span><br><span class="line">comparator.compare(p1, p2);             <span class="comment">// &gt; 0</span></span><br><span class="line">comparator.reversed().compare(p1, p2);  <span class="comment">// &lt; 0</span></span><br></pre></td></tr></table></figure><h2 id="Optionals"><a href="#Optionals" class="headerlink" title="Optionals"></a>Optionals</h2><p>Optionals不是函数式接口，而是用于防止 NullPointerException 的漂亮工具。这是下一节的一个重要概念，让我们快速了解一下Optionals的工作原理。</p><p>Optional 是一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是有时却什么也没有返回，而在Java 8中，你应该返回 Optional 而不是 null。</p><p>译者注：示例中每个方法的作用已经添加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//of（）：为非null的值创建一个Optional</span></span><br><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">"bam"</span>);</span><br><span class="line"><span class="comment">// isPresent（）： 如果值存在返回true，否则返回false</span></span><br><span class="line">optional.isPresent();           <span class="comment">// true</span></span><br><span class="line"><span class="comment">//get()：如果Optional有值则将其返回，否则抛出NoSuchElementException</span></span><br><span class="line">optional.get();                 <span class="comment">// "bam"</span></span><br><span class="line"><span class="comment">//orElse（）：如果有值则将其返回，否则返回指定的其它值</span></span><br><span class="line">optional.orElse(<span class="string">"fallback"</span>);    <span class="comment">// "bam"</span></span><br><span class="line"><span class="comment">//ifPresent（）：如果Optional实例有值则为其调用consumer，否则不做处理</span></span><br><span class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(<span class="number">0</span>)));     <span class="comment">// "b"</span></span><br></pre></td></tr></table></figure><p>推荐阅读：<a href="https://blog.kaaass.net/archives/764" target="_blank" rel="noopener">[Java8]如何正确使用Optional</a></p><h2 id="Streams-流"><a href="#Streams-流" class="headerlink" title="Streams(流)"></a>Streams(流)</h2><p><code>java.util.Stream</code> 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如<code>java.util.Collection</code> 的子类，List 或者 Set， Map 不支持。Stream 的操作可以串行执行或者并行执行。</p><p>首先看看Stream是怎么用，首先创建实例代码的用到的数据List：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stringList.add(<span class="string">"ddd2"</span>);</span><br><span class="line">stringList.add(<span class="string">"aaa2"</span>);</span><br><span class="line">stringList.add(<span class="string">"bbb1"</span>);</span><br><span class="line">stringList.add(<span class="string">"aaa1"</span>);</span><br><span class="line">stringList.add(<span class="string">"bbb3"</span>);</span><br><span class="line">stringList.add(<span class="string">"ccc"</span>);</span><br><span class="line">stringList.add(<span class="string">"bbb2"</span>);</span><br><span class="line">stringList.add(<span class="string">"ddd1"</span>);</span><br></pre></td></tr></table></figure><p>Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作：</p><h3 id="Filter-过滤"><a href="#Filter-过滤" class="headerlink" title="Filter(过滤)"></a>Filter(过滤)</h3><p>过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于<strong>中间操作</strong>，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 Filter(过滤)</span></span><br><span class="line">stringList</span><br><span class="line">        .stream()</span><br><span class="line">        .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</span><br><span class="line">        .forEach(System.out::println);<span class="comment">//aaa2 aaa1</span></span><br></pre></td></tr></table></figure><p>forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。</p><h3 id="Sorted-排序"><a href="#Sorted-排序" class="headerlink" title="Sorted(排序)"></a>Sorted(排序)</h3><p>排序是一个 <strong>中间操作</strong>，返回的是排序好后的 Stream。<strong>如果你不指定一个自定义的 Comparator 则会使用默认排序。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 Sort (排序)</span></span><br><span class="line">stringList</span><br><span class="line">        .stream()</span><br><span class="line">        .sorted()</span><br><span class="line">        .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</span><br><span class="line">        .forEach(System.out::println);<span class="comment">// aaa1 aaa2</span></span><br></pre></td></tr></table></figure><p>需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(stringList);<span class="comment">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span></span><br></pre></td></tr></table></figure><h3 id="Map-映射"><a href="#Map-映射" class="headerlink" title="Map(映射)"></a>Map(映射)</h3><p>中间操作 map 会将元素根据指定的 Function 接口来依次将元素转成另外的对象。</p><p>下面的示例展示了将字符串转换为大写字符串。你也可以通过map来将对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 Map 操作</span></span><br><span class="line">stringList</span><br><span class="line">        .stream()</span><br><span class="line">        .map(String::toUpperCase)</span><br><span class="line">        .sorted((a, b) -&gt; b.compareTo(a))</span><br><span class="line">        .forEach(System.out::println);<span class="comment">// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"</span></span><br></pre></td></tr></table></figure><h3 id="Match-匹配"><a href="#Match-匹配" class="headerlink" title="Match(匹配)"></a>Match(匹配)</h3><p>Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是 <strong>最终操作</strong> ，并返回一个 boolean 类型的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 Match (匹配)操作</span></span><br><span class="line"><span class="keyword">boolean</span> anyStartsWithA =</span><br><span class="line">        stringList</span><br><span class="line">                .stream()</span><br><span class="line">                .anyMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line">System.out.println(anyStartsWithA);      <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> allStartsWithA =</span><br><span class="line">        stringList</span><br><span class="line">                .stream()</span><br><span class="line">                .allMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(allStartsWithA);      <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> noneStartsWithZ =</span><br><span class="line">        stringList</span><br><span class="line">                .stream()</span><br><span class="line">                .noneMatch((s) -&gt; s.startsWith(<span class="string">"z"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(noneStartsWithZ);      <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Count-计数"><a href="#Count-计数" class="headerlink" title="Count(计数)"></a>Count(计数)</h3><p>计数是一个 <strong>最终操作</strong>，返回Stream中元素的个数，<strong>返回值类型是 long</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试 Count (计数)操作</span></span><br><span class="line">  <span class="keyword">long</span> startsWithB =</span><br><span class="line">          stringList</span><br><span class="line">                  .stream()</span><br><span class="line">                  .filter((s) -&gt; s.startsWith(<span class="string">"b"</span>))</span><br><span class="line">                  .count();</span><br><span class="line">  System.out.println(startsWithB);    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="Reduce-规约"><a href="#Reduce-规约" class="headerlink" title="Reduce(规约)"></a>Reduce(规约)</h3><p>这是一个 <strong>最终操作</strong> ，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规约后的结果是通过Optional 接口表示的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试 Reduce (规约)操作</span></span><br><span class="line">Optional&lt;String&gt; reduced =</span><br><span class="line">        stringList</span><br><span class="line">                .stream()</span><br><span class="line">                .sorted()</span><br><span class="line">                .reduce((s1, s2) -&gt; s1 + <span class="string">"#"</span> + s2);</span><br><span class="line"></span><br><span class="line">reduced.ifPresent(System.out::println);<span class="comment">//aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2</span></span><br></pre></td></tr></table></figure><p><strong>译者注：</strong> 这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于<code>Integer sum = integers.reduce(0, (a, b) -&gt; a+b);</code>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串连接，concat = "ABCD"</span></span><br><span class="line">String concat = Stream.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>).reduce(<span class="string">""</span>, String::concat); </span><br><span class="line"><span class="comment">// 求最小值，minValue = -3.0</span></span><br><span class="line"><span class="keyword">double</span> minValue = Stream.of(-<span class="number">1.5</span>, <span class="number">1.0</span>, -<span class="number">3.0</span>, -<span class="number">2.0</span>).reduce(Double.MAX_VALUE, Double::min); </span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 有起始值</span></span><br><span class="line"><span class="keyword">int</span> sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 无起始值</span></span><br><span class="line">sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(Integer::sum).get();</span><br><span class="line"><span class="comment">// 过滤，字符串连接，concat = "ace"</span></span><br><span class="line">concat = Stream.of(<span class="string">"a"</span>, <span class="string">"B"</span>, <span class="string">"c"</span>, <span class="string">"D"</span>, <span class="string">"e"</span>, <span class="string">"F"</span>).</span><br><span class="line"> filter(x -&gt; x.compareTo(<span class="string">"Z"</span>) &gt; <span class="number">0</span>).</span><br><span class="line"> reduce(<span class="string">""</span>, String::concat);</span><br></pre></td></tr></table></figure><p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。更多内容查看： <a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html" target="_blank" rel="noopener">IBM：Java 8 中的 Streams API 详解</a> </p><h2 id="Parallel-Streams-并行流"><a href="#Parallel-Streams-并行流" class="headerlink" title="Parallel Streams(并行流)"></a>Parallel Streams(并行流)</h2><p>前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。</p><p>下面的例子展示了是如何通过并行Stream来提升性能：</p><p>首先我们创建一个没有重复元素的大表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = <span class="number">1000000</span>;</span><br><span class="line">List&lt;String&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;(max);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">    UUID uuid = UUID.randomUUID();</span><br><span class="line">    values.add(uuid.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分别用串行和并行两种方式对其进行排序，最后看看所用时间的对比。</p><h3 id="Sequential-Sort-串行排序"><a href="#Sequential-Sort-串行排序" class="headerlink" title="Sequential Sort(串行排序)"></a>Sequential Sort(串行排序)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串行排序</span></span><br><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"><span class="keyword">long</span> count = values.stream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">"sequential sort took: %d ms"</span>, millis));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1000000</span><br><span class="line">sequential sort took: 709 ms&#x2F;&#x2F;串行排序所用的时间</span><br></pre></td></tr></table></figure><h3 id="Parallel-Sort-并行排序"><a href="#Parallel-Sort-并行排序" class="headerlink" title="Parallel Sort(并行排序)"></a>Parallel Sort(并行排序)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并行排序</span></span><br><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> count = values.parallelStream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">"parallel sort took: %d ms"</span>, millis));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000000</span></span><br><span class="line">parallel sort took: <span class="number">475</span> ms<span class="comment">//串行排序所用的时间</span></span><br></pre></td></tr></table></figure><p>上面两个代码几乎是一样的，但是并行版的快了 50% 左右，唯一需要做的改动就是将 <code>stream()</code> 改为<code>parallelStream()</code>。</p><h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p>前面提到过，Map 类型不支持 streams，不过Map提供了一些新的有用的方法来处理一些日常任务。Map接口本身没有可用的 <code>stream（）</code>方法，但是你可以在键，值上创建专门的流或者通过 <code>map.keySet().stream()</code>,<code>map.values().stream()</code>和<code>map.entrySet().stream()</code>。</p><p>此外,Maps 支持各种新的和有用的方法来执行常见任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    map.putIfAbsent(i, <span class="string">"val"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map.forEach((id, val) -&gt; System.out.println(val));<span class="comment">//val0 val1 val2 val3 val4 val5 val6 val7 val8 val9</span></span><br></pre></td></tr></table></figure><p><code>putIfAbsent</code> 阻止我们在null检查时写入额外的代码;<code>forEach</code>接受一个 consumer 来对 map 中的每个元素操作。</p><p>此示例显示如何使用函数在 map 上计算代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">map.computeIfPresent(<span class="number">3</span>, (num, val) -&gt; val + num);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></span><br><span class="line"></span><br><span class="line">map.computeIfPresent(<span class="number">9</span>, (num, val) -&gt; <span class="keyword">null</span>);</span><br><span class="line">map.containsKey(<span class="number">9</span>);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">map.computeIfAbsent(<span class="number">23</span>, num -&gt; <span class="string">"val"</span> + num);</span><br><span class="line">map.containsKey(<span class="number">23</span>);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">map.computeIfAbsent(<span class="number">3</span>, num -&gt; <span class="string">"bam"</span>);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></span><br></pre></td></tr></table></figure><p>接下来展示如何在Map里删除一个键值全都匹配的项：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.remove(<span class="number">3</span>, <span class="string">"val3"</span>);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></span><br><span class="line">map.remove(<span class="number">3</span>, <span class="string">"val33"</span>);</span><br><span class="line">map.get(<span class="number">3</span>);             <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>另外一个有用的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.getOrDefault(<span class="number">42</span>, <span class="string">"not found"</span>);  <span class="comment">// not found</span></span><br></pre></td></tr></table></figure><p>对Map的元素做合并也变得很容易了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.merge(<span class="number">9</span>, <span class="string">"val9"</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9</span></span><br><span class="line">map.merge(<span class="number">9</span>, <span class="string">"concat"</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9concat</span></span><br></pre></td></tr></table></figure><p>Merge 做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。</p><h2 id="Date-API-日期相关API"><a href="#Date-API-日期相关API" class="headerlink" title="Date API(日期相关API)"></a>Date API(日期相关API)</h2><p>Java 8在 <code>java.time</code> 包下包含一个全新的日期和时间API。新的Date API与Joda-Time库相似，但它们不一样。以下示例涵盖了此新 API 的最重要部分。译者对这部分内容参考相关书籍做了大部分修改。</p><p><strong>译者注(总结)：</strong></p><ul><li><p>Clock 类提供了访问当前日期和时间的方法，Clock 是时区敏感的，可以用来取代 <code>System.currentTimeMillis()</code> 来获取当前的微秒数。某一个特定的时间点也可以使用 <code>Instant</code> 类来表示，<code>Instant</code> 类也可以用来创建旧版本的<code>java.util.Date</code> 对象。</p></li><li><p>在新API中时区使用 ZoneId 来表示。时区可以很方便的使用静态方法of来获取到。 抽象类<code>ZoneId</code>（在<code>java.time</code>包中）表示一个区域标识符。 它有一个名为<code>getAvailableZoneIds</code>的静态方法，它返回所有区域标识符。</p></li><li><p>jdk1.8中新增了 LocalDate 与 LocalDateTime等类来解决日期处理方法，同时引入了一个新的类DateTimeFormatter 来解决日期格式化问题。可以使用Instant代替 Date，LocalDateTime代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat。</p></li></ul><h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p>Clock 类提供了访问当前日期和时间的方法，Clock 是时区敏感的，可以用来取代 <code>System.currentTimeMillis()</code> 来获取当前的微秒数。某一个特定的时间点也可以使用 <code>Instant</code> 类来表示，<code>Instant</code> 类也可以用来创建旧版本的<code>java.util.Date</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();</span><br><span class="line"><span class="keyword">long</span> millis = clock.millis();</span><br><span class="line">System.out.println(millis);<span class="comment">//1552379579043</span></span><br><span class="line">Instant instant = clock.instant();</span><br><span class="line">System.out.println(instant);</span><br><span class="line">Date legacyDate = Date.from(instant); <span class="comment">//2019-03-12T08:46:42.588Z</span></span><br><span class="line">System.out.println(legacyDate);<span class="comment">//Tue Mar 12 16:32:59 CST 2019</span></span><br></pre></td></tr></table></figure><h3 id="Timezones-时区"><a href="#Timezones-时区" class="headerlink" title="Timezones(时区)"></a>Timezones(时区)</h3><p>在新API中时区使用 ZoneId 来表示。时区可以很方便的使用静态方法of来获取到。 抽象类<code>ZoneId</code>（在<code>java.time</code>包中）表示一个区域标识符。 它有一个名为<code>getAvailableZoneIds</code>的静态方法，它返回所有区域标识符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出所有区域标识符</span></span><br><span class="line">System.out.println(ZoneId.getAvailableZoneIds());</span><br><span class="line"></span><br><span class="line">ZoneId zone1 = ZoneId.of(<span class="string">"Europe/Berlin"</span>);</span><br><span class="line">ZoneId zone2 = ZoneId.of(<span class="string">"Brazil/East"</span>);</span><br><span class="line">System.out.println(zone1.getRules());<span class="comment">// ZoneRules[currentStandardOffset=+01:00]</span></span><br><span class="line">System.out.println(zone2.getRules());<span class="comment">// ZoneRules[currentStandardOffset=-03:00]</span></span><br></pre></td></tr></table></figure><h3 id="LocalTime-本地时间"><a href="#LocalTime-本地时间" class="headerlink" title="LocalTime(本地时间)"></a>LocalTime(本地时间)</h3><p>LocalTime 定义了一个没有时区信息的时间，例如 晚上10点或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LocalTime now1 = LocalTime.now(zone1);</span><br><span class="line">LocalTime now2 = LocalTime.now(zone2);</span><br><span class="line">System.out.println(now1.isBefore(now2));  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> hoursBetween = ChronoUnit.HOURS.between(now1, now2);</span><br><span class="line"><span class="keyword">long</span> minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</span><br><span class="line"></span><br><span class="line">System.out.println(hoursBetween);       <span class="comment">// -3</span></span><br><span class="line">System.out.println(minutesBetween);     <span class="comment">// -239</span></span><br></pre></td></tr></table></figure><p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LocalTime late = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line">System.out.println(late);       <span class="comment">// 23:59:59</span></span><br><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedTime(FormatStyle.SHORT)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line">LocalTime leetTime = LocalTime.parse(<span class="string">"13:37"</span>, germanFormatter);</span><br><span class="line">System.out.println(leetTime);   <span class="comment">// 13:37</span></span><br></pre></td></tr></table></figure><h3 id="LocalDate-本地日期"><a href="#LocalDate-本地日期" class="headerlink" title="LocalDate(本地日期)"></a>LocalDate(本地日期)</h3><p>LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();<span class="comment">//获取现在的日期</span></span><br><span class="line">System.out.println(<span class="string">"今天的日期: "</span>+today);<span class="comment">//2019-03-12</span></span><br><span class="line">LocalDate tomorrow = today.plus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line">System.out.println(<span class="string">"明天的日期: "</span>+tomorrow);<span class="comment">//2019-03-13</span></span><br><span class="line">LocalDate yesterday = tomorrow.minusDays(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"昨天的日期: "</span>+yesterday);<span class="comment">//2019-03-11</span></span><br><span class="line">LocalDate independenceDay = LocalDate.of(<span class="number">2019</span>, Month.MARCH, <span class="number">12</span>);</span><br><span class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</span><br><span class="line">System.out.println(<span class="string">"今天是周几:"</span>+dayOfWeek);<span class="comment">//TUESDAY</span></span><br></pre></td></tr></table></figure><p>从字符串解析一个 LocalDate 类型和解析 LocalTime 一样简单,下面是使用  <code>DateTimeFormatter</code> 解析字符串的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"2014==04==12 01时06分09秒"</span>;</span><br><span class="line">    <span class="comment">// 根据需要解析的日期、时间字符串定义解析所用的格式器</span></span><br><span class="line">    DateTimeFormatter fomatter1 = DateTimeFormatter</span><br><span class="line">            .ofPattern(<span class="string">"yyyy==MM==dd HH时mm分ss秒"</span>);</span><br><span class="line"></span><br><span class="line">    LocalDateTime dt1 = LocalDateTime.parse(str1, fomatter1);</span><br><span class="line">    System.out.println(dt1); <span class="comment">// 输出 2014-04-12T01:06:09</span></span><br><span class="line"></span><br><span class="line">    String str2 = <span class="string">"2014$$$四月$$$13 20小时"</span>;</span><br><span class="line">    DateTimeFormatter fomatter2 = DateTimeFormatter</span><br><span class="line">            .ofPattern(<span class="string">"yyy$$$MMM$$$dd HH小时"</span>);</span><br><span class="line">    LocalDateTime dt2 = LocalDateTime.parse(str2, fomatter2);</span><br><span class="line">    System.out.println(dt2); <span class="comment">// 输出 2014-04-13T20:00</span></span><br></pre></td></tr></table></figure><p>再来看一个使用 <code>DateTimeFormatter</code> 格式化日期的示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime rightNow=LocalDateTime.now();</span><br><span class="line">String date=DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(rightNow);</span><br><span class="line">System.out.println(date);<span class="comment">//2019-03-12T16:26:48.29</span></span><br><span class="line">DateTimeFormatter formatter=DateTimeFormatter.ofPattern(<span class="string">"YYYY-MM-dd HH:mm:ss"</span>);</span><br><span class="line">System.out.println(formatter.format(rightNow));<span class="comment">//2019-03-12 16:26:48</span></span><br></pre></td></tr></table></figure><h3 id="LocalDateTime-本地日期时间"><a href="#LocalDateTime-本地日期时间" class="headerlink" title="LocalDateTime(本地日期时间)"></a>LocalDateTime(本地日期时间)</h3><p>LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime 和 LocalTime还有 LocalDate 一样，都是不可变的。LocalDateTime 提供了一些能访问具体字段的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime sylvester = LocalDateTime.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);      <span class="comment">// WEDNESDAY</span></span><br><span class="line"></span><br><span class="line">Month month = sylvester.getMonth();</span><br><span class="line">System.out.println(month);          <span class="comment">// DECEMBER</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</span><br><span class="line">System.out.println(minuteOfDay);    <span class="comment">// 1439</span></span><br></pre></td></tr></table></figure><p>只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的<code>java.util.Date</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Instant instant = sylvester</span><br><span class="line">        .atZone(ZoneId.systemDefault())</span><br><span class="line">        .toInstant();</span><br><span class="line"></span><br><span class="line">Date legacyDate = Date.from(instant);</span><br><span class="line">System.out.println(legacyDate);     <span class="comment">// Wed Dec 31 23:59:59 CET 2014</span></span><br></pre></td></tr></table></figure><p>格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofPattern(<span class="string">"MMM dd, yyyy - HH:mm"</span>);</span><br><span class="line">LocalDateTime parsed = LocalDateTime.parse(<span class="string">"Nov 03, 2014 - 07:13"</span>, formatter);</span><br><span class="line">String string = formatter.format(parsed);</span><br><span class="line">System.out.println(string);     <span class="comment">// Nov 03, 2014 - 07:13</span></span><br></pre></td></tr></table></figure><p>和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。<br>关于时间日期格式的详细信息在<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html" target="_blank" rel="noopener">这里</a>。</p><h2 id="Annotations-注解"><a href="#Annotations-注解" class="headerlink" title="Annotations(注解)"></a>Annotations(注解)</h2><p>在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。<br>首先定义一个包装类Hints注解用来放置一组具体的Hint注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Hints &#123;</span><br><span class="line">    Hint[] value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repeatable</span>(Hints<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">interface</span> <span class="title">Hint</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下<code>@Repeatable</code>即可。</p><p>例 1: 使用包装类当容器来存多个注解（老方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Hints</span>(&#123;<span class="meta">@Hint</span>(<span class="string">"hint1"</span>), <span class="meta">@Hint</span>(<span class="string">"hint2"</span>)&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>例 2：使用多重注解（新方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Hint</span>(<span class="string">"hint1"</span>)</span><br><span class="line"><span class="meta">@Hint</span>(<span class="string">"hint2"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hint hint = Person<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotation</span>(<span class="title">Hint</span>.<span class="title">class</span>)</span>;</span><br><span class="line">System.out.println(hint);                   <span class="comment">// null</span></span><br><span class="line">Hints hints1 = Person<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotation</span>(<span class="title">Hints</span>.<span class="title">class</span>)</span>;</span><br><span class="line">System.out.println(hints1.value().length);  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">Hint[] hints2 = Person<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotationsByType</span>(<span class="title">Hint</span>.<span class="title">class</span>)</span>;</span><br><span class="line">System.out.println(hints2.length);          <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>即便我们没有在 <code>Person</code>类上定义 <code>@Hints</code>注解，我们还是可以通过 <code>getAnnotation(Hints.class)</code>来获取 <code>@Hints</code>注解，更加方便的方法是使用 <code>getAnnotationsByType</code> 可以直接获取到所有的<code>@Hint</code>注解。<br>另外Java 8的注解还增加到两种新的target上了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="Where-to-go-from-here"><a href="#Where-to-go-from-here" class="headerlink" title="Where to go from here?"></a>Where to go from here?</h2><p>关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如<code>Arrays.parallelSort</code>, <code>StampedLock</code>和<code>CompletableFuture</code>等等。</p><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p><p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源<a href="#公众号">公众号</a>后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。 </p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/qrcode_for_gh_ea338256af79_258.jpg" alt="我的公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8教程推荐</title>
      <link href="/posts/9b646b54/"/>
      <url>/posts/9b646b54/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul><li><strong>《Java8 In Action》</strong></li><li><strong>《写给大忙人看的Java SE 8》</strong></li></ul><p>上述书籍的PDF版本见 <a href="https://shimo.im/docs/CPB0PK05rP4CFmI2/" target="_blank" rel="noopener">https://shimo.im/docs/CPB0PK05rP4CFmI2/</a> 中的 “Java 书籍推荐”。</p><h3 id="开源文档"><a href="#开源文档" class="headerlink" title="开源文档"></a>开源文档</h3><ul><li><strong>【译】Java 8 简明教程</strong>：<a href="https://github.com/wizardforcel/modern-java-zh" target="_blank" rel="noopener">https://github.com/wizardforcel/modern-java-zh</a></li><li><strong>30 seconds of java8:</strong>  <a href="https://github.com/biezhi/30-seconds-of-java8" target="_blank" rel="noopener">https://github.com/biezhi/30-seconds-of-java8</a></li></ul><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><ul><li><strong>尚硅谷 Java 8 新特性</strong></li></ul><p>视频资源见： <a href="https://shimo.im/docs/CPB0PK05rP4CFmI2/" target="_blank" rel="noopener">https://shimo.im/docs/CPB0PK05rP4CFmI2/</a> 。</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8foreach指南</title>
      <link href="/posts/aeb3c91b/"/>
      <url>/posts/aeb3c91b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>本文由 <a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">JavaGuide</a> 翻译，原文地址：<a href="https://www.baeldung.com/foreach-java" target="_blank" rel="noopener">https://www.baeldung.com/foreach-java</a></p></blockquote><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>在Java 8中引入的<em>forEach</em>循环为程序员提供了一种新的，简洁而有趣的迭代集合的方式。</p><p>在本文中，我们将看到如何将<em>forEach</em>与集合<em>一起</em>使用，它采用何种参数以及此循环与增强的<em>for</em>循环的不同之处。</p><h2 id="2-基础知识"><a href="#2-基础知识" class="headerlink" title="2 基础知识"></a>2 基础知识</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Collection 接口实现了 Iterable 接口，而 Iterable 接口在 Java 8开始具有一个新的 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span><span class="comment">//对 Iterable的每个元素执行给定的操作，直到所有元素都被处理或动作引发异常。</span></span></span><br></pre></td></tr></table></figure><p>使用<em>forEach<em>，我们可以迭代一个集合并对每个元素执行给定的操作，就像任何其他</em>迭代器一样。</em></p><p>例如，迭代和打印字符串集合<em>的</em>for循环版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用<em>forEach</em>写这个 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names.forEach(name -&gt; &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-使用forEach方法"><a href="#3-使用forEach方法" class="headerlink" title="3.使用forEach方法"></a>3.使用forEach方法</h2><h3 id="3-1-匿名类"><a href="#3-1-匿名类" class="headerlink" title="3.1 匿名类"></a>3.1 匿名类</h3><p>我们使用  <em>forEach</em>迭代集合并对每个元素执行特定操作。<strong>要执行的操作包含在实现Consumer接口的类中，并作为参数传递给forEach 。</strong></p><p>所述<em>消费者</em>接口是一个功能接口(具有单个抽象方法的接口）。它接受输入并且不返回任何结果。</p><p>Consumer 接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何实现，例如，只是打印字符串的消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; printConsumer = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以作为参数传递给<em>forEach</em>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.forEach(printConsumer);</span><br></pre></td></tr></table></figure><p>但这不是通过消费者和使用<em>forEach</em> API 创建操作的唯一方法。让我们看看我们将使用<em>forEach</em>方法的另外2种最流行的方式：</p><h3 id="3-2-Lambda表达式"><a href="#3-2-Lambda表达式" class="headerlink" title="3.2 Lambda表达式"></a>3.2 Lambda表达式</h3><p>Java 8功能接口的主要优点是我们可以使用Lambda表达式来实例化它们，并避免使用庞大的匿名类实现。</p><p>由于 Consumer 接口属于函数式接口，我们可以通过以下形式在Lambda中表达它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(argument) -&gt; &#123; body &#125;</span><br><span class="line">name -&gt; System.out.println(name)</span><br><span class="line">names.forEach(name -&gt; System.out.println(name));</span><br></pre></td></tr></table></figure><h3 id="3-3-方法参考"><a href="#3-3-方法参考" class="headerlink" title="3.3 方法参考"></a>3.3 方法参考</h3><p>我们可以使用方法引用语法而不是普通的Lambda语法，其中已存在一个方法来对类执行操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="4-forEach在集合中的使用"><a href="#4-forEach在集合中的使用" class="headerlink" title="4.forEach在集合中的使用"></a>4.forEach在集合中的使用</h2><h3 id="4-1-迭代集合"><a href="#4-1-迭代集合" class="headerlink" title="4.1.迭代集合"></a>4.1.迭代集合</h3><p><strong>任何类型Collection的可迭代  - 列表，集合，队列 等都具有使用forEach的相同语法。</strong></p><p>因此，正如我们已经看到的，迭代列表的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"Larry"</span>, <span class="string">"Steve"</span>, <span class="string">"James"</span>);</span><br><span class="line"> </span><br><span class="line">names.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>同样对于一组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; uniqueNames = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">"Larry"</span>, <span class="string">"Steve"</span>, <span class="string">"James"</span>));</span><br><span class="line"> </span><br><span class="line">uniqueNames.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>或者让我们说一个<em>队列</em>也是一个<em>集合</em>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; namesQueue = <span class="keyword">new</span> ArrayDeque&lt;&gt;(Arrays.asList(<span class="string">"Larry"</span>, <span class="string">"Steve"</span>, <span class="string">"James"</span>));</span><br><span class="line"> </span><br><span class="line">namesQueue.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="4-2-迭代Map-使用Map的forEach"><a href="#4-2-迭代Map-使用Map的forEach" class="headerlink" title="4.2.迭代Map - 使用Map的forEach"></a>4.2.迭代Map - 使用Map的forEach</h3><p>Map没有实现Iterable接口，但它<strong>提供了自己的forEach 变体，它接受BiConsumer</strong>。* </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; namesMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">namesMap.put(<span class="number">1</span>, <span class="string">"Larry"</span>);</span><br><span class="line">namesMap.put(<span class="number">2</span>, <span class="string">"Steve"</span>);</span><br><span class="line">namesMap.put(<span class="number">3</span>, <span class="string">"James"</span>);</span><br><span class="line">namesMap.forEach((key, value) -&gt; System.out.println(key + <span class="string">" "</span> + value));</span><br></pre></td></tr></table></figure><h3 id="4-3-迭代一个Map-通过迭代entrySet"><a href="#4-3-迭代一个Map-通过迭代entrySet" class="headerlink" title="4.3.迭代一个Map - 通过迭代entrySet"></a>4.3.迭代一个Map - 通过迭代entrySet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namesMap.entrySet().forEach(entry -&gt; System.out.println(entry.getKey() + <span class="string">" "</span> + entry.getValue()));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS</title>
      <link href="/posts/f9be1680/"/>
      <url>/posts/f9be1680/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><blockquote><p>常见问题：AQS 原理？;CountDownLatch 和 CyclicBarrier 了解吗,两者的区别是什么？用过 Semaphore 吗？</p></blockquote><h3 id="1-AQS-简单介绍"><a href="#1-AQS-简单介绍" class="headerlink" title="1 AQS 简单介绍"></a>1 AQS 简单介绍</h3><p>AQS 的全称为（AbstractQueuedSynchronizer），这个类在 java.util.concurrent.locks 包下面。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/AQS.png" alt="enter image description here"></p><p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask(jdk1.7) 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p><h3 id="2-AQS-原理"><a href="#2-AQS-原理" class="headerlink" title="2 AQS 原理"></a>2 AQS 原理</h3><blockquote><p>在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于 AQS 原理的理解”。下面给大家一个示例供大家参考，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。</p></blockquote><p>下面大部分内容其实在 AQS 类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。</p><h4 id="2-1-AQS-原理概览"><a href="#2-1-AQS-原理概览" class="headerlink" title="2.1 AQS 原理概览"></a>2.1 AQS 原理概览</h4><p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p><blockquote><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p></blockquote><p>看个 AQS(AbstractQueuedSynchronizer)原理图：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/CLH.png" alt="enter image description here"></p><p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure><p>状态信息通过 protected 类型的<code>getState</code>，<code>setState</code>，<code>compareAndSetState</code>进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-AQS-对资源的共享方式"><a href="#2-2-AQS-对资源的共享方式" class="headerlink" title="2.2 AQS 对资源的共享方式"></a>2.2 AQS 对资源的共享方式</h4><p><strong>AQS 定义两种资源共享方式</strong></p><p><strong>1)Exclusive</strong>（独占）</p><p>只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁,ReentrantLock 同时支持两种锁,下面以 ReentrantLock 对这两种锁的定义做介绍：</p><ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。</li></ul><blockquote><p>说明：下面这部分关于 <code>ReentrantLock</code> 源代码内容节选自：<a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2" target="_blank" rel="noopener">https://www.javadoop.com/post/AbstractQueuedSynchronizer-2</a> ，这是一篇很不错文章，推荐阅读。</p></blockquote><p><strong>下面来看 ReentrantLock 中相关的源代码：</strong></p><p>ReentrantLock 默认采用非公平锁，因为考虑获得更好的性能，通过 boolean 来决定是否用公平锁（传入 true 用公平锁）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认非公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock 中公平锁的 <code>lock</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非公平锁的 lock 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里没有对阻塞队列进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：公平锁和非公平锁只有两处不同：</p><ol><li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li></ol><p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p><p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p><p><strong>2)Share</strong>（共享）</p><p>多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</p><p>ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在上层已经帮我们实现好了。</p><h4 id="2-3-AQS-底层使用了模板方法模式"><a href="#2-3-AQS-底层使用了模板方法模式" class="headerlink" title="2.3 AQS 底层使用了模板方法模式"></a>2.3 AQS 底层使用了模板方法模式</h4><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p><ol><li>使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li><li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li></ol><p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用，下面简单的给大家介绍一下模板方法模式，模板方法模式是一个很容易理解的设计模式之一。</p><blockquote><p>模板方法模式是基于”继承“的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码。举个很简单的例子假如我们要去一个地方的步骤是：购票<code>buyTicket()</code>-&gt;安检<code>securityCheck()</code>-&gt;乘坐某某工具回家<code>ride()</code>-&gt;到达目的地<code>arrive()</code>。我们可能乘坐不同的交通工具回家比如飞机或者火车，所以除了<code>ride()</code>方法，其他方法的实现几乎相同。我们可以定义一个包含了这些方法的抽象类，然后用户根据自己的需要继承该抽象类然后修改 <code>ride()</code>方法。</p></blockquote><p><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure><p>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p><p>以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</p><p>再以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state 会 CAS(Compare and Swap)减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p><p>推荐两篇 AQS 原理和相关源码分析的文章：</p><ul><li><a href="http://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">http://www.cnblogs.com/waterystone/p/4920797.html</a></li><li><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></li></ul><h3 id="3-Semaphore-信号量-允许多个线程同时访问"><a href="#3-Semaphore-信号量-允许多个线程同时访问" class="headerlink" title="3 Semaphore(信号量)-允许多个线程同时访问"></a>3 Semaphore(信号量)-允许多个线程同时访问</h3><p><strong>synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</strong> </p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Snailclimb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年9月30日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 需要一次性拿一个许可的情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample1</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">300</span>);</span><br><span class="line">    <span class="comment">// 一次只能允许执行的线程数量。</span></span><br><span class="line">    <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> threadnum = i;</span><br><span class="line">      threadPool.execute(() -&gt; &#123;<span class="comment">// Lambda 表达式的运用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          semaphore.acquire();<span class="comment">// 获取一个许可，所以可运行线程数量为20/1=20</span></span><br><span class="line">          test(threadnum);</span><br><span class="line">          semaphore.release();<span class="comment">// 释放一个许可</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">"finish"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">    System.out.println(<span class="string">"threadnum:"</span> + threadnum);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>acquire</code> 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 <code>release</code> 方法增加一个许可证，这可能会释放一个阻塞的 acquire 方法。然而，其实并没有实际的许可证这个对象，Semaphore 只是维持了一个可获得许可证的数量。 Semaphore 经常用于限制获取某种资源的线程数量。</p><p>当然一次也可以一次拿取和释放多个许可，不过一般没有必要这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">semaphore.acquire(<span class="number">5</span>);<span class="comment">// 获取5个许可，所以可运行线程数量为20/5=4</span></span><br><span class="line">test(threadnum);</span><br><span class="line">semaphore.release(<span class="number">5</span>);<span class="comment">// 获取5个许可，所以可运行线程数量为20/5=4</span></span><br></pre></td></tr></table></figure><p>除了 <code>acquire</code>方法之外，另一个比较常用的与之对应的方法是<code>tryAcquire</code>方法，该方法如果获取不到许可就立即返回 false。</p><p>Semaphore 有两种模式，公平模式和非公平模式。</p><ul><li><strong>公平模式：</strong> 调用 acquire 的顺序就是获取许可证的顺序，遵循 FIFO；</li><li><strong>非公平模式：</strong> 抢占式的。</li></ul><p><strong>Semaphore 对应的两个构造方法如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">     sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">     sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。</strong></p><p><a href="https://github.com/Snailclimb/JavaGuide/issues/645" target="_blank" rel="noopener">issue645补充内容</a> ：Semaphore与CountDownLatch一样，也是共享锁的一种实现。它默认构造AQS的state为permits。当执行任务的线程数量超出permits,那么多余的线程将会被放入阻塞队列Park,并自旋判断state是否大于0。只有当state大于0的时候，阻塞的线程才能继续执行,此时先前执行任务的线程继续执行release方法，release方法使得state的变量会加1，那么自旋的线程便会判断成功。<br>如此，每次只有最多不超过permits数量的线程能自旋成功，便限制了执行任务线程的数量。</p><p>由于篇幅问题，如果对 Semaphore 源码感兴趣的朋友可以看下这篇文章：<a href="https://juejin.im/post/5ae755366fb9a07ab508adc6" target="_blank" rel="noopener">https://juejin.im/post/5ae755366fb9a07ab508adc6</a></p><h3 id="4-CountDownLatch-（倒计时器）"><a href="#4-CountDownLatch-（倒计时器）" class="headerlink" title="4 CountDownLatch （倒计时器）"></a>4 CountDownLatch （倒计时器）</h3><p>CountDownLatch允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。在 Java 并发中，countdownlatch 的概念是一个常见的面试题，所以一定要确保你很好的理解了它。</p><p>CountDownLatch是共享锁的一种实现,它默认构造 AQS 的 state 值为 count。当线程使用countDown方法时,其实使用了<code>tryReleaseShared</code>方法以CAS的操作来减少state,直至state为0就代表所有的线程都调用了countDown方法。当调用await方法的时候，如果state不为0，就代表仍然有线程没有调用countDown方法，那么就把已经调用过countDown的线程都放入阻塞队列Park,并自旋CAS判断state == 0，直至最后一个线程调用了countDown，使得state == 0，于是阻塞的线程便判断成功，全部往下执行。</p><h4 id="4-1-CountDownLatch-的两种典型用法"><a href="#4-1-CountDownLatch-的两种典型用法" class="headerlink" title="4.1 CountDownLatch 的两种典型用法"></a>4.1 CountDownLatch 的两种典型用法</h4><ol><li>某一线程在开始运行前等待 n 个线程执行完毕。将 CountDownLatch 的计数器初始化为 n ：<code>new CountDownLatch(n)</code>，每当一个任务线程执行完毕，就将计数器减 1 <code>countdownlatch.countDown()</code>，当计数器的值变为 0 时，在<code>CountDownLatch上 await()</code> 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</li><li>实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 <code>CountDownLatch</code> 对象，将其计数器初始化为 1 ：<code>new CountDownLatch(1)</code>，多个线程在开始执行任务前首先 <code>coundownlatch.await()</code>，当主线程调用 countDown() 时，计数器变为 0，多个线程同时被唤醒。</li></ol><h4 id="4-2-CountDownLatch-的使用示例"><a href="#4-2-CountDownLatch-的使用示例" class="headerlink" title="4.2 CountDownLatch 的使用示例"></a>4.2 CountDownLatch 的使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> SnailClimb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年10月1日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: CountDownLatch 使用方法示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample1</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">300</span>);</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> threadnum = i;</span><br><span class="line">      threadPool.execute(() -&gt; &#123;<span class="comment">// Lambda 表达式的运用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          test(threadnum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          countDownLatch.countDown();<span class="comment">// 表示一个请求已经被完成</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">"finish"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">    System.out.println(<span class="string">"threadnum:"</span> + threadnum);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，我们定义了请求的数量为 550，当这 550 个请求被处理完成之后，才会执行<code>System.out.println(&quot;finish&quot;);</code>。</p><p>与 CountDownLatch 的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用 <code>CountDownLatch.await()</code> 方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p><p>其他 N 个线程必须引用闭锁对象，因为他们需要通知 <code>CountDownLatch</code> 对象，他们已经完成了各自的任务。这种通知机制是通过 <code>CountDownLatch.countDown()</code>方法来完成的；每调用一次这个方法，在构造函数中初始化的 count 值就减 1。所以当 N 个线程都调 用了这个方法，count 的值等于 0，然后主线程就能通过 <code>await()</code>方法，恢复执行自己的任务。</p><p>再插一嘴：<code>CountDownLatch</code> 的  <code>await()</code> 方法使用不当很容易产生死锁，比如我们上面代码中的 for 循环改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount-<span class="number">1</span>; i++) &#123;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就导致  <code>count</code> 的值没办法等于 0，然后就会导致一直等待。</p><p>如果对CountDownLatch源码感兴趣的朋友，可以查看： <a href="https://www.cnblogs.com/leesf456/p/5406191.html" target="_blank" rel="noopener">【JUC】JDK1.8源码分析之CountDownLatch（五）</a></p><h4 id="4-3-CountDownLatch-的不足"><a href="#4-3-CountDownLatch-的不足" class="headerlink" title="4.3 CountDownLatch 的不足"></a>4.3 CountDownLatch 的不足</h4><p>CountDownLatch 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。</p><h4 id="4-4-CountDownLatch-相常见面试题"><a href="#4-4-CountDownLatch-相常见面试题" class="headerlink" title="4.4 CountDownLatch 相常见面试题"></a>4.4 CountDownLatch 相常见面试题</h4><p>解释一下 CountDownLatch 概念？</p><p>CountDownLatch 和 CyclicBarrier 的不同之处？</p><p>给出一些 CountDownLatch 使用的例子？</p><p>CountDownLatch 类中主要的方法？</p><h3 id="5-CyclicBarrier-循环栅栏"><a href="#5-CyclicBarrier-循环栅栏" class="headerlink" title="5 CyclicBarrier(循环栅栏)"></a>5 CyclicBarrier(循环栅栏)</h3><p>CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。</p><blockquote><p>CountDownLatch的实现是基于AQS的，而CycliBarrier是基于 ReentrantLock(ReentrantLock也属于AQS同步器)和 Condition 的.</p></blockquote><p>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用<code>await</code>方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</p><p>再来看一下它的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，parties 就代表了有拦截的线程的数量，当拦截的线程数量达到这个值的时候就打开栅栏，让所有线程通过。</p><h4 id="5-1-CyclicBarrier-的应用场景"><a href="#5-1-CyclicBarrier-的应用场景" class="headerlink" title="5.1 CyclicBarrier 的应用场景"></a>5.1 CyclicBarrier 的应用场景</h4><p>CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。</p><h4 id="5-2-CyclicBarrier-的使用示例"><a href="#5-2-CyclicBarrier-的使用示例" class="headerlink" title="5.2 CyclicBarrier 的使用示例"></a>5.2 CyclicBarrier 的使用示例</h4><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Snailclimb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年10月1日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 测试 CyclicBarrier 类中带参数的 await() 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample2</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">550</span>;</span><br><span class="line">  <span class="comment">// 需要同步的线程数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      threadPool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          test(threadNum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"threadnum:"</span> + threadnum + <span class="string">"is ready"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">/**等待60秒，保证子线程完全执行结束*/</span></span><br><span class="line">      cyclicBarrier.await(<span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"-----CyclicBarrierException------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"threadnum:"</span> + threadnum + <span class="string">"is finish"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">threadnum:0is ready</span><br><span class="line">threadnum:1is ready</span><br><span class="line">threadnum:2is ready</span><br><span class="line">threadnum:3is ready</span><br><span class="line">threadnum:4is ready</span><br><span class="line">threadnum:4is finish</span><br><span class="line">threadnum:0is finish</span><br><span class="line">threadnum:1is finish</span><br><span class="line">threadnum:2is finish</span><br><span class="line">threadnum:3is finish</span><br><span class="line">threadnum:5is ready</span><br><span class="line">threadnum:6is ready</span><br><span class="line">threadnum:7is ready</span><br><span class="line">threadnum:8is ready</span><br><span class="line">threadnum:9is ready</span><br><span class="line">threadnum:9is finish</span><br><span class="line">threadnum:5is finish</span><br><span class="line">threadnum:8is finish</span><br><span class="line">threadnum:7is finish</span><br><span class="line">threadnum:6is finish</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>可以看到当线程数量也就是请求数量达到我们定义的 5 个的时候， <code>await</code>方法之后的方法才被执行。</p><p>另外，CyclicBarrier 还提供一个更高级的构造函数<code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在线程到达屏障时，优先执行<code>barrierAction</code>，方便处理更复杂的业务场景。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> SnailClimb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年10月1日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 新建 CyclicBarrier 的时候指定一个 Runnable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample3</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">550</span>;</span><br><span class="line">  <span class="comment">// 需要同步的线程数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"------当线程数达到之后，优先执行------"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      threadPool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          test(threadNum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"threadnum:"</span> + threadnum + <span class="string">"is ready"</span>);</span><br><span class="line">    cyclicBarrier.await();</span><br><span class="line">    System.out.println(<span class="string">"threadnum:"</span> + threadnum + <span class="string">"is finish"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">threadnum:0is ready</span><br><span class="line">threadnum:1is ready</span><br><span class="line">threadnum:2is ready</span><br><span class="line">threadnum:3is ready</span><br><span class="line">threadnum:4is ready</span><br><span class="line">------当线程数达到之后，优先执行------</span><br><span class="line">threadnum:4is finish</span><br><span class="line">threadnum:0is finish</span><br><span class="line">threadnum:2is finish</span><br><span class="line">threadnum:1is finish</span><br><span class="line">threadnum:3is finish</span><br><span class="line">threadnum:5is ready</span><br><span class="line">threadnum:6is ready</span><br><span class="line">threadnum:7is ready</span><br><span class="line">threadnum:8is ready</span><br><span class="line">threadnum:9is ready</span><br><span class="line">------当线程数达到之后，优先执行------</span><br><span class="line">threadnum:9is finish</span><br><span class="line">threadnum:5is finish</span><br><span class="line">threadnum:6is finish</span><br><span class="line">threadnum:8is finish</span><br><span class="line">threadnum:7is finish</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h4 id="5-3-CyclicBarrier源码分析"><a href="#5-3-CyclicBarrier源码分析" class="headerlink" title="5.3 CyclicBarrier源码分析"></a>5.3 <code>CyclicBarrier</code>源码分析</h4><p>当调用 <code>CyclicBarrier</code> 对象调用 <code>await()</code> 方法时，实际上调用的是<code>dowait(false, 0L)</code>方法。 <code>await()</code> 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 parties 的值时，栅栏才会打开，线程才得以通过执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dowait(false, 0L)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当线程数量或者请求数量达到 count 时 await 之后的方法才会被执行。上面的示例中 count 的值就为 5。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main barrier code, covering the various policies.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 锁住</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果线程中断了，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout减1</span></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="comment">// 当 count 数量减为 0 之后说明最后一个线程已经到达栅栏了，也就是达到了可以执行await 方法之后的条件</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 将 count 重置为 parties 属性的初始化值</span></span><br><span class="line">                <span class="comment">// 唤醒之前等待的线程</span></span><br><span class="line">                <span class="comment">// 下一波执行开始</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：<code>CyclicBarrier</code> 内部通过一个 count 变量作为计数器，cout 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减一。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p><h4 id="5-4-CyclicBarrier-和-CountDownLatch-的区别"><a href="#5-4-CyclicBarrier-和-CountDownLatch-的区别" class="headerlink" title="5.4 CyclicBarrier 和 CountDownLatch 的区别"></a>5.4 CyclicBarrier 和 CountDownLatch 的区别</h4><p><strong>下面这个是国外一个大佬的回答：</strong></p><p>CountDownLatch 是计数器，只能使用一次，而 CyclicBarrier 的计数器提供 reset 功能，可以多次使用。但是我不那么认为它们之间的区别仅仅就是这么简单的一点。我们来从 jdk 作者设计的目的来看，javadoc 是这么描述它们的：</p><blockquote><p>CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.(CountDownLatch: 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；)<br>CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.(CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。)</p></blockquote><p>对于 CountDownLatch 来说，重点是“一个线程（多个线程）等待”，而其他的 N 个线程在完成“某件事情”之后，可以终止，也可以等待。而对于 CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。</p><p>CountDownLatch 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 CyclicBarrier 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。</p><h3 id="6-ReentrantLock-和-ReentrantReadWriteLock"><a href="#6-ReentrantLock-和-ReentrantReadWriteLock" class="headerlink" title="6 ReentrantLock 和 ReentrantReadWriteLock"></a>6 ReentrantLock 和 ReentrantReadWriteLock</h3><p>ReentrantLock 和 synchronized 的区别在上面已经讲过了这里就不多做讲解。另外，需要注意的是：读写锁 ReentrantReadWriteLock 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://juejin.im/post/5ae755256fb9a07ac3634067" target="_blank" rel="noopener">https://juejin.im/post/5ae755256fb9a07ac3634067</a></li><li><a href="https://blog.csdn.net/u010185262/article/details/54692886" target="_blank" rel="noopener">https://blog.csdn.net/u010185262/article/details/54692886</a></li><li><a href="https://blog.csdn.net/tolcf/article/details/50925145?utm_source=blogxgwz0" target="_blank" rel="noopener">https://blog.csdn.net/tolcf/article/details/50925145?utm_source=blogxgwz0</a></li></ul><h3 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h3><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p><p><strong>《Java 面试突击》:</strong> 由本文档衍生的专为面试而生的《Java 面试突击》V2.0 PDF 版本<a href="#公众号" title="公众号">公众号</a>后台回复 <strong>“面试突击”</strong> 即可免费领取！</p><p><strong>Java 工程师必备学习资源:</strong> 一些 Java 工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/qrcode_for_gh_ea338256af79_258.jpg" alt="我的公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atomic</title>
      <link href="/posts/bd62b625/"/>
      <url>/posts/bd62b625/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><blockquote><p>个人觉得这一节掌握基本的使用即可！</p></blockquote><h3 id="1-Atomic-原子类介绍"><a href="#1-Atomic-原子类介绍" class="headerlink" title="1 Atomic 原子类介绍"></a>1 Atomic 原子类介绍</h3><p>Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p><p>所以，所谓原子类说简单点就是具有原子/原子操作特征的类。</p><p>并发包 <code>java.util.concurrent</code> 的原子类都存放在<code>java.util.concurrent.atomic</code>下,如下图所示。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/JUC%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%A6%82%E8%A7%88.png" alt="JUC原子类概览"></p><p>根据操作的数据类型，可以将JUC包中的原子类分为4类</p><p><strong>基本类型</strong> </p><p>使用原子的方式更新基本类型</p><ul><li>AtomicInteger：整型原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean ：布尔型原子类</li></ul><p><strong>数组类型</strong></p><p>使用原子的方式更新数组里的某个元素</p><ul><li>AtomicIntegerArray：整型数组原子类</li><li>AtomicLongArray：长整型数组原子类</li><li>AtomicReferenceArray ：引用类型数组原子类</li></ul><p><strong>引用类型</strong></p><ul><li>AtomicReference：引用类型原子类</li><li>AtomicMarkableReference：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，<del>也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</del></li><li>AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li></ul><p><strong>对象的属性修改类型</strong></p><ul><li>AtomicIntegerFieldUpdater:原子更新整型字段的更新器</li><li>AtomicLongFieldUpdater：原子更新长整型字段的更新器</li><li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段</li></ul><blockquote><p>修正: <strong>AtomicMarkableReference 不能解决ABA问题</strong>   <strong><a href="https://github.com/Snailclimb/JavaGuide/issues/626" target="_blank" rel="noopener">issue#626</a></strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">AtomicMarkableReference是将一个boolean值作是否有更改的标记，本质就是它的版本号只有两个，true和false，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">修改的时候在这两个版本号之间来回切换，这样做并不能解决ABA的问题，只是会降低ABA问题发生的几率而已</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> : mazh</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">@Date</span> : 2020/1/17 14:41</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SolveABAByAtomicMarkableReference</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> AtomicMarkableReference atomicMarkableReference = <span class="keyword">new</span> AtomicMarkableReference(<span class="number">100</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            Thread refT1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                atomicMarkableReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicMarkableReference.isMarked(), !atomicMarkableReference.isMarked());</span><br><span class="line">                atomicMarkableReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicMarkableReference.isMarked(), !atomicMarkableReference.isMarked());</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            Thread refT2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">boolean</span> marked = atomicMarkableReference.isMarked();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> c3 = atomicMarkableReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, marked, !marked);</span><br><span class="line">                System.out.println(c3); <span class="comment">// 返回true,实际应该返回false</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            refT1.start();</span><br><span class="line">            refT2.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>CAS ABA 问题</strong></p><ul><li>描述: 第一个线程取到了变量 x 的值 A，然后巴拉巴拉干别的事，总之就是只拿到了变量 x 的值 A。这段时间内第二个线程也取到了变量 x 的值 A，然后把变量 x 的值改为 B，然后巴拉巴拉干别的事，最后又把变量 x 的值变为 A （相当于还原了）。在这之后第一个线程终于进行了变量 x 的操作，但是此时变量 x 的值还是 A，所以 compareAndSet 操作是成功。</li><li>例子描述(可能不太合适，但好理解): 年初，现金为零，然后通过正常劳动赚了三百万，之后正常消费了（比如买房子）三百万。年末，虽然现金零收入（可能变成其他形式了），但是赚了钱是事实，还是得交税的！</li><li>代码例子（以<code>AtomicInteger</code>为例）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerDefectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        defectOfABA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">defectOfABA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread coreThread = <span class="keyword">new</span> Thread(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> currentValue = atomicInteger.get();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" ------ currentValue="</span> + currentValue);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 这段目的：模拟处理其他业务花费的时间</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">boolean</span> casResult = atomicInteger.compareAndSet(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">" ------ currentValue="</span> + currentValue</span><br><span class="line">                            + <span class="string">", finalValue="</span> + atomicInteger.get()</span><br><span class="line">                            + <span class="string">", compareAndSet Result="</span> + casResult);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        coreThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这段目的：为了让 coreThread 线程先跑起来</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread amateurThread = <span class="keyword">new</span> Thread(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">int</span> currentValue = atomicInteger.get();</span><br><span class="line">                    <span class="keyword">boolean</span> casResult = atomicInteger.compareAndSet(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">" ------ currentValue="</span> + currentValue</span><br><span class="line">                            + <span class="string">", finalValue="</span> + atomicInteger.get()</span><br><span class="line">                            + <span class="string">", compareAndSet Result="</span> + casResult);</span><br><span class="line"></span><br><span class="line">                    currentValue = atomicInteger.get();</span><br><span class="line">                    casResult = atomicInteger.compareAndSet(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">" ------ currentValue="</span> + currentValue</span><br><span class="line">                            + <span class="string">", finalValue="</span> + atomicInteger.get()</span><br><span class="line">                            + <span class="string">", compareAndSet Result="</span> + casResult);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        amateurThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 ------ currentValue&#x3D;1</span><br><span class="line">Thread-1 ------ currentValue&#x3D;1, finalValue&#x3D;2, compareAndSet Result&#x3D;true</span><br><span class="line">Thread-1 ------ currentValue&#x3D;2, finalValue&#x3D;1, compareAndSet Result&#x3D;true</span><br><span class="line">Thread-0 ------ currentValue&#x3D;1, finalValue&#x3D;2, compareAndSet Result&#x3D;true</span><br></pre></td></tr></table></figure><p>下面我们来详细介绍一下这些原子类。</p><h3 id="2-基本类型原子类"><a href="#2-基本类型原子类" class="headerlink" title="2 基本类型原子类"></a>2 基本类型原子类</h3><h4 id="2-1-基本类型原子类介绍"><a href="#2-1-基本类型原子类介绍" class="headerlink" title="2.1 基本类型原子类介绍"></a>2.1 基本类型原子类介绍</h4><p>使用原子的方式更新基本类型</p><ul><li>AtomicInteger：整型原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean ：布尔型原子类</li></ul><p>上面三个类提供的方法几乎相同，所以我们这里以 AtomicInteger 为例子来介绍。</p><p> <strong>AtomicInteger 类常用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span></span><br></pre></td></tr></table></figure><h4 id="2-2-AtomicInteger-常见方法使用"><a href="#2-2-AtomicInteger-常见方法使用" class="headerlink" title="2.2 AtomicInteger 常见方法使用"></a>2.2 AtomicInteger 常见方法使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> temvalue = <span class="number">0</span>;</span><br><span class="line">AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">temvalue = i.getAndSet(<span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">"temvalue:"</span> + temvalue + <span class="string">";  i:"</span> + i);<span class="comment">//temvalue:0;  i:3</span></span><br><span class="line">temvalue = i.getAndIncrement();</span><br><span class="line">System.out.println(<span class="string">"temvalue:"</span> + temvalue + <span class="string">";  i:"</span> + i);<span class="comment">//temvalue:3;  i:4</span></span><br><span class="line">temvalue = i.getAndAdd(<span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"temvalue:"</span> + temvalue + <span class="string">";  i:"</span> + i);<span class="comment">//temvalue:4;  i:9</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-基本数据类型原子类的优势"><a href="#2-3-基本数据类型原子类的优势" class="headerlink" title="2.3 基本数据类型原子类的优势"></a>2.3 基本数据类型原子类的优势</h4><p>通过一个简单例子带大家看一下基本数据类型原子类的优势</p><p><strong>①多线程环境不使用原子类保证线程安全（基本数据类型）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//若要线程安全执行执行count++，需要加锁</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  count++; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>②多线程环境使用原子类保证线程安全（基本数据类型）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  count.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//使用AtomicInteger之后，不需要加锁，也可以实现线程安全。</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-AtomicInteger-线程安全原理简单分析"><a href="#2-4-AtomicInteger-线程安全原理简单分析" class="headerlink" title="2.4 AtomicInteger 线程安全原理简单分析"></a>2.4 AtomicInteger 线程安全原理简单分析</h4><p>AtomicInteger 类的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p><h3 id="3-数组类型原子类"><a href="#3-数组类型原子类" class="headerlink" title="3 数组类型原子类"></a>3 数组类型原子类</h3><h4 id="3-1-数组类型原子类介绍"><a href="#3-1-数组类型原子类介绍" class="headerlink" title="3.1 数组类型原子类介绍"></a>3.1 数组类型原子类介绍</h4><p>使用原子的方式更新数组里的某个元素</p><ul><li>AtomicIntegerArray：整形数组原子类</li><li>AtomicLongArray：长整形数组原子类</li><li>AtomicReferenceArray ：引用类型数组原子类</li></ul><p>上面三个类提供的方法几乎相同，所以我们这里以 AtomicIntegerArray 为例子来介绍。</p><p><strong>AtomicIntegerArray 类常用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span><span class="comment">//返回 index=i 位置的当前的值，并将其设置为新值：newValue</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">(<span class="keyword">int</span> i)</span><span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> <span class="comment">//获取 index=i 位置元素的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span><span class="comment">//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span></span><br></pre></td></tr></table></figure><h4 id="3-2-AtomicIntegerArray-常见方法使用"><a href="#3-2-AtomicIntegerArray-常见方法使用" class="headerlink" title="3.2 AtomicIntegerArray 常见方法使用"></a>3.2 AtomicIntegerArray 常见方法使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArrayTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> temvalue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">AtomicIntegerArray i = <span class="keyword">new</span> AtomicIntegerArray(nums);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">System.out.println(i.get(j));</span><br><span class="line">&#125;</span><br><span class="line">temvalue = i.getAndSet(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"temvalue:"</span> + temvalue + <span class="string">";  i:"</span> + i);</span><br><span class="line">temvalue = i.getAndIncrement(<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">"temvalue:"</span> + temvalue + <span class="string">";  i:"</span> + i);</span><br><span class="line">temvalue = i.getAndAdd(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"temvalue:"</span> + temvalue + <span class="string">";  i:"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-引用类型原子类"><a href="#4-引用类型原子类" class="headerlink" title="4 引用类型原子类"></a>4 引用类型原子类</h3><h4 id="4-1-引用类型原子类介绍"><a href="#4-1-引用类型原子类介绍" class="headerlink" title="4.1  引用类型原子类介绍"></a>4.1  引用类型原子类介绍</h4><p>基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用 引用类型原子类。</p><ul><li>AtomicReference：引用类型原子类</li><li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li><li>AtomicMarkableReference ：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，<del>也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</del></li></ul><p>上面三个类提供的方法几乎相同，所以我们这里以 AtomicReference 为例子来介绍。</p><h4 id="4-2-AtomicReference-类使用示例"><a href="#4-2-AtomicReference-类使用示例" class="headerlink" title="4.2 AtomicReference 类使用示例"></a>4.2 AtomicReference 类使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">AtomicReference&lt;Person&gt; ar = <span class="keyword">new</span> AtomicReference&lt;Person&gt;();</span><br><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">"SnailClimb"</span>, <span class="number">22</span>);</span><br><span class="line">ar.set(person);</span><br><span class="line">Person updatePerson = <span class="keyword">new</span> Person(<span class="string">"Daisy"</span>, <span class="number">20</span>);</span><br><span class="line">ar.compareAndSet(person, updatePerson);</span><br><span class="line"></span><br><span class="line">System.out.println(ar.get().getName());</span><br><span class="line">System.out.println(ar.get().getAge());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先创建了一个 Person 对象，然后把 Person 对象设置进 AtomicReference 对象中，然后调用 compareAndSet 方法，该方法就是通过 CAS 操作设置 ar。如果 ar 的值为 person 的话，则将其设置为 updatePerson。实现原理与 AtomicInteger 类中的 compareAndSet 方法相同。运行上面的代码后的输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Daisy</span><br><span class="line">20</span><br></pre></td></tr></table></figure><h4 id="4-3-AtomicStampedReference-类使用示例"><a href="#4-3-AtomicStampedReference-类使用示例" class="headerlink" title="4.3 AtomicStampedReference 类使用示例"></a>4.3 AtomicStampedReference 类使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化、取当前值和 stamp 值</span></span><br><span class="line">        <span class="keyword">final</span> Integer initialRef = <span class="number">0</span>, initialStamp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> AtomicStampedReference&lt;Integer&gt; asr = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(initialRef, initialStamp);</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + asr.getReference() + <span class="string">", currentStamp="</span> + asr.getStamp());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compare and set</span></span><br><span class="line">        <span class="keyword">final</span> Integer newReference = <span class="number">666</span>, newStamp = <span class="number">999</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> casResult = asr.compareAndSet(initialRef, newReference, initialStamp, newStamp);</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + asr.getReference()</span><br><span class="line">                + <span class="string">", currentStamp="</span> + asr.getStamp()</span><br><span class="line">                + <span class="string">", casResult="</span> + casResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前的值和当前的 stamp 值</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">final</span> Integer currentValue = asr.get(arr);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> currentStamp = arr[<span class="number">0</span>];</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + currentValue + <span class="string">", currentStamp="</span> + currentStamp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单独设置 stamp 值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> attemptStampResult = asr.attemptStamp(newReference, <span class="number">88</span>);</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + asr.getReference()</span><br><span class="line">                + <span class="string">", currentStamp="</span> + asr.getStamp()</span><br><span class="line">                + <span class="string">", attemptStampResult="</span> + attemptStampResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新设置当前值和 stamp 值</span></span><br><span class="line">        asr.set(initialRef, initialStamp);</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + asr.getReference() + <span class="string">", currentStamp="</span> + asr.getStamp());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [不推荐使用，除非搞清楚注释的意思了] weak compare and set</span></span><br><span class="line">        <span class="comment">// 困惑！weakCompareAndSet 这个方法最终还是调用 compareAndSet 方法。[版本: jdk-8u191]</span></span><br><span class="line">        <span class="comment">// 但是注释上写着 "May fail spuriously and does not provide ordering guarantees,</span></span><br><span class="line">        <span class="comment">// so is only rarely an appropriate alternative to compareAndSet."</span></span><br><span class="line">        <span class="comment">// todo 感觉有可能是 jvm 通过方法名在 native 方法里面做了转发</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> wCasResult = asr.weakCompareAndSet(initialRef, newReference, initialStamp, newStamp);</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + asr.getReference()</span><br><span class="line">                + <span class="string">", currentStamp="</span> + asr.getStamp()</span><br><span class="line">                + <span class="string">", wCasResult="</span> + wCasResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">currentValue&#x3D;0, currentStamp&#x3D;0</span><br><span class="line">currentValue&#x3D;666, currentStamp&#x3D;999, casResult&#x3D;true</span><br><span class="line">currentValue&#x3D;666, currentStamp&#x3D;999</span><br><span class="line">currentValue&#x3D;666, currentStamp&#x3D;88, attemptStampResult&#x3D;true</span><br><span class="line">currentValue&#x3D;0, currentStamp&#x3D;0</span><br><span class="line">currentValue&#x3D;666, currentStamp&#x3D;999, wCasResult&#x3D;true</span><br></pre></td></tr></table></figure><h4 id="4-4-AtomicMarkableReference-类使用示例"><a href="#4-4-AtomicMarkableReference-类使用示例" class="headerlink" title="4.4 AtomicMarkableReference 类使用示例"></a>4.4 AtomicMarkableReference 类使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicMarkableReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicMarkableReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化、取当前值和 mark 值</span></span><br><span class="line">        <span class="keyword">final</span> Boolean initialRef = <span class="keyword">null</span>, initialMark = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> AtomicMarkableReference&lt;Boolean&gt; amr = <span class="keyword">new</span> AtomicMarkableReference&lt;&gt;(initialRef, initialMark);</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + amr.getReference() + <span class="string">", currentMark="</span> + amr.isMarked());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compare and set</span></span><br><span class="line">        <span class="keyword">final</span> Boolean newReference1 = <span class="keyword">true</span>, newMark1 = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> casResult = amr.compareAndSet(initialRef, newReference1, initialMark, newMark1);</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + amr.getReference()</span><br><span class="line">                + <span class="string">", currentMark="</span> + amr.isMarked()</span><br><span class="line">                + <span class="string">", casResult="</span> + casResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前的值和当前的 mark 值</span></span><br><span class="line">        <span class="keyword">boolean</span>[] arr = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">final</span> Boolean currentValue = amr.get(arr);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> currentMark = arr[<span class="number">0</span>];</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + currentValue + <span class="string">", currentMark="</span> + currentMark);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单独设置 mark 值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> attemptMarkResult = amr.attemptMark(newReference1, <span class="keyword">false</span>);</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + amr.getReference()</span><br><span class="line">                + <span class="string">", currentMark="</span> + amr.isMarked()</span><br><span class="line">                + <span class="string">", attemptMarkResult="</span> + attemptMarkResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新设置当前值和 mark 值</span></span><br><span class="line">        amr.set(initialRef, initialMark);</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + amr.getReference() + <span class="string">", currentMark="</span> + amr.isMarked());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [不推荐使用，除非搞清楚注释的意思了] weak compare and set</span></span><br><span class="line">        <span class="comment">// 困惑！weakCompareAndSet 这个方法最终还是调用 compareAndSet 方法。[版本: jdk-8u191]</span></span><br><span class="line">        <span class="comment">// 但是注释上写着 "May fail spuriously and does not provide ordering guarantees,</span></span><br><span class="line">        <span class="comment">// so is only rarely an appropriate alternative to compareAndSet."</span></span><br><span class="line">        <span class="comment">// todo 感觉有可能是 jvm 通过方法名在 native 方法里面做了转发</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> wCasResult = amr.weakCompareAndSet(initialRef, newReference1, initialMark, newMark1);</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + amr.getReference()</span><br><span class="line">                + <span class="string">", currentMark="</span> + amr.isMarked()</span><br><span class="line">                + <span class="string">", wCasResult="</span> + wCasResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">currentValue&#x3D;null, currentMark&#x3D;false</span><br><span class="line">currentValue&#x3D;true, currentMark&#x3D;true, casResult&#x3D;true</span><br><span class="line">currentValue&#x3D;true, currentMark&#x3D;true</span><br><span class="line">currentValue&#x3D;true, currentMark&#x3D;false, attemptMarkResult&#x3D;true</span><br><span class="line">currentValue&#x3D;null, currentMark&#x3D;false</span><br><span class="line">currentValue&#x3D;true, currentMark&#x3D;true, wCasResult&#x3D;true</span><br></pre></td></tr></table></figure><h3 id="5-对象的属性修改类型原子类"><a href="#5-对象的属性修改类型原子类" class="headerlink" title="5 对象的属性修改类型原子类"></a>5 对象的属性修改类型原子类</h3><h4 id="5-1-对象的属性修改类型原子类介绍"><a href="#5-1-对象的属性修改类型原子类介绍" class="headerlink" title="5.1 对象的属性修改类型原子类介绍"></a>5.1 对象的属性修改类型原子类介绍</h4><p>如果需要原子更新某个类里的某个字段时，需要用到对象的属性修改类型原子类。</p><ul><li>AtomicIntegerFieldUpdater:原子更新整形字段的更新器</li><li>AtomicLongFieldUpdater：原子更新长整形字段的更新器</li><li>AtomicReferenceFieldUpdater ：原子更新引用类型里的字段的更新器</li></ul><p>要想原子地更新对象的属性需要两步。第一步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新的对象属性必须使用 public volatile 修饰符。</p><p>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicIntegerFieldUpdater</code>为例子来介绍。</p><h4 id="5-2-AtomicIntegerFieldUpdater-类使用示例"><a href="#5-2-AtomicIntegerFieldUpdater-类使用示例" class="headerlink" title="5.2 AtomicIntegerFieldUpdater 类使用示例"></a>5.2 AtomicIntegerFieldUpdater 类使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class, "age");</span><br><span class="line"></span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="string">"Java"</span>, <span class="number">22</span>);</span><br><span class="line">System.out.println(a.getAndIncrement(user));<span class="comment">// 22</span></span><br><span class="line">System.out.println(a.get(user));<span class="comment">// 23</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">22</span><br><span class="line">23</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>《Java并发编程的艺术》</li></ul><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p><p><strong>《Java面试突击》:</strong> 由本文档衍生的专为面试而生的《Java面试突击》V2.0 PDF 版本<a href="#公众号">公众号</a>后台回复 <strong>“面试突击”</strong> 即可免费领取！</p><p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。 </p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/qrcode_for_gh_ea338256af79_258.jpg" alt="我的公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发进阶常见面试题总结</title>
      <link href="/posts/109c009a/"/>
      <url>/posts/109c009a/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><h1 id="Java-并发进阶常见面试题总结"><a href="#Java-并发进阶常见面试题总结" class="headerlink" title="Java 并发进阶常见面试题总结"></a>Java 并发进阶常见面试题总结</h1><h2 id="1-synchronized-关键字"><a href="#1-synchronized-关键字" class="headerlink" title="1. synchronized 关键字"></a>1. synchronized 关键字</h2><h3 id="1-1-说一说自己对于-synchronized-关键字的了解"><a href="#1-1-说一说自己对于-synchronized-关键字的了解" class="headerlink" title="1.1. 说一说自己对于 synchronized 关键字的了解"></a>1.1. 说一说自己对于 synchronized 关键字的了解</h3><p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><p>另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><h3 id="1-2-说说自己是怎么使用-synchronized-关键字，在项目中用到了吗"><a href="#1-2-说说自己是怎么使用-synchronized-关键字，在项目中用到了吗" class="headerlink" title="1.2. 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗"></a>1.2. 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</h3><p><strong>synchronized关键字最主要的三种使用方式：</strong></p><ul><li><strong>修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li><li><strong>修饰静态方法:</strong> 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li><li><strong>修饰代码块:</strong> 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li></ul><p><strong>总结：</strong> synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！</p><p>下面我以一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。</p><p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p><p><strong>双重校验锁实现对象单例（线程安全）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。</p><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h3 id="1-3-讲一下-synchronized-关键字的底层原理"><a href="#1-3-讲一下-synchronized-关键字的底层原理" class="headerlink" title="1.3. 讲一下 synchronized 关键字的底层原理"></a>1.3. 讲一下 synchronized 关键字的底层原理</h3><p><strong>synchronized 关键字底层原理属于 JVM 层面。</strong></p><p><strong>① synchronized 同步语句块的情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"synchronized 代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 <code>javac SynchronizedDemo.java</code> 命令生成编译后的 .class 文件，然后执行<code>javap -c -s -v -l SynchronizedDemo.class</code>。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86.png" alt="synchronized关键字原理"></p><p>从上面我们可以看出：</p><p><strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><p><strong>② synchronized 修饰方法的的情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"synchronized 方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%862.png" alt="synchronized关键字原理"></p><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><h3 id="1-4-说说-JDK1-6-之后的synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗"><a href="#1-4-说说-JDK1-6-之后的synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗" class="headerlink" title="1.4. 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗"></a>1.4. 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗</h3><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><p>关于这几种优化的详细信息可以查看笔主的这篇文章：<a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Multithread/synchronized.md" target="_blank" rel="noopener">https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Multithread/synchronized.md</a></p><h3 id="1-5-谈谈-synchronized和ReentrantLock-的区别"><a href="#1-5-谈谈-synchronized和ReentrantLock-的区别" class="headerlink" title="1.5. 谈谈 synchronized和ReentrantLock 的区别"></a>1.5. 谈谈 synchronized和ReentrantLock 的区别</h3><p><strong>① 两者都是可重入锁</strong></p><p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p><p><strong>② synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong></p><p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><p><strong>③ ReentrantLock 比 synchronized 增加了一些高级功能</strong></p><p>相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</strong></p><ul><li><strong>ReentrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li><li>synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li></ul><p>如果你想使用上述功能，那么选择ReentrantLock是一个不错的选择。</p><p><strong>④ 性能已不是选择标准</strong></p><h2 id="2-volatile关键字"><a href="#2-volatile关键字" class="headerlink" title="2. volatile关键字"></a>2. volatile关键字</h2><h3 id="2-1-讲一下Java内存模型"><a href="#2-1-讲一下Java内存模型" class="headerlink" title="2.1. 讲一下Java内存模型"></a>2.1. 讲一下Java内存模型</h3><p>在 JDK1.2 之前，Java的内存模型实现总是从<strong>主存</strong>（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4.png" alt="数据不一致"></p><p>要解决这个问题，就需要把变量声明为<strong>volatile</strong>，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。</p><p>说白了， <strong>volatile</strong> 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7.png" alt="volatile关键字的可见性"></p><h3 id="2-2-并发编程的三个重要特性"><a href="#2-2-并发编程的三个重要特性" class="headerlink" title="2.2 并发编程的三个重要特性"></a>2.2 并发编程的三个重要特性</h3><ol><li><strong>原子性</strong> : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</li><li><strong>可见性</strong>  ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</li><li><strong>有序性</strong> ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li></ol><h3 id="2-3-说说-synchronized-关键字和-volatile-关键字的区别"><a href="#2-3-说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="2.3. 说说 synchronized 关键字和 volatile 关键字的区别"></a>2.3. 说说 synchronized 关键字和 volatile 关键字的区别</h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在：</p><ul><li><strong>volatile关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile性能肯定比synchronized关键字要好</strong>。但是<strong>volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块</strong>。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，<strong>实际开发中使用 synchronized 关键字的场景还是更多一些</strong>。</li><li><strong>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</strong></li><li><strong>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</strong></li><li><strong>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</strong></li></ul><h2 id="3-ThreadLocal"><a href="#3-ThreadLocal" class="headerlink" title="3. ThreadLocal"></a>3. ThreadLocal</h2><h3 id="3-1-ThreadLocal简介"><a href="#3-1-ThreadLocal简介" class="headerlink" title="3.1. ThreadLocal简介"></a>3.1. ThreadLocal简介</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong> JDK中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p><p><strong>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get（）</code> 和 <code>set（）</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</strong></p><p>再举个简单的例子： </p><p>比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么ThreadLocal就是用来避免这两个线程竞争的。</p><h3 id="3-2-ThreadLocal示例"><a href="#3-2-ThreadLocal示例" class="headerlink" title="3.2. ThreadLocal示例"></a>3.2. ThreadLocal示例</h3><p>相信看了上面的解释，大家已经搞懂 ThreadLocal 类是个什么东西了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd HHmm"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadLocalExample obj = <span class="keyword">new</span> ThreadLocalExample();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(obj, <span class="string">""</span>+i);</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread Name= "</span>+Thread.currentThread().getName()+<span class="string">" default Formatter = "</span>+formatter.get().toPattern());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//formatter pattern is changed here by thread, but it won't reflect to other threads</span></span><br><span class="line">        formatter.set(<span class="keyword">new</span> SimpleDateFormat());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread Name= "</span>+Thread.currentThread().getName()+<span class="string">" formatter = "</span>+formatter.get().toPattern());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread Name&#x3D; 0 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 0 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 1 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 2 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 1 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 3 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 2 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 4 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 3 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 4 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 5 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 5 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 6 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 6 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 7 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 7 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 8 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 9 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 8 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 9 formatter &#x3D; yy-M-d ah:mm</span><br></pre></td></tr></table></figure><p>从输出中可以看出，Thread-0已经改变了formatter的值，但仍然是thread-2默认格式化程序与初始化值相同，其他线程也一样。</p><p>上面有一段代码用到了创建 <code>ThreadLocal</code> 变量的那段代码用到了 Java8 的知识，它等于下面这段代码，如果你写了下面这段代码的话，IDEA会提示你转换为Java8的格式(IDEA真的不错！)。因为ThreadLocal类在Java 8中扩展，使用一个新的方法<code>withInitial()</code>，将Supplier功能接口作为参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;()&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd HHmm"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><h3 id="3-3-ThreadLocal原理"><a href="#3-3-ThreadLocal原理" class="headerlink" title="3.3. ThreadLocal原理"></a>3.3. ThreadLocal原理</h3><p>从 <code>Thread</code>类源代码入手。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line"><span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面<code>Thread</code>类 源代码可以看出<code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个  <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code>  类型的变量,我们可以把 <code>ThreadLocalMap</code>  理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p><p><code>ThreadLocal</code>类的<code>set()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面这些内容，我们足以通过猜测得出结论：<strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p><p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为key ，Object 对象为 value的键值对。</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话，会使用 <code>Thread</code>内部都是使用仅有那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code>的 key 就是 <code>ThreadLocal</code>对象，value 就是 <code>ThreadLocal</code> 对象调用<code>set</code>方法设置的值。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://upload-images.jianshu.io/upload_images/7432604-ad2ff581127ba8cc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/806" alt="ThreadLocal数据结构"></p><p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ThreadLocal%E5%86%85%E9%83%A8%E7%B1%BB.png" alt="ThreadLocal内部类"></p><h3 id="3-4-ThreadLocal-内存泄露问题"><a href="#3-4-ThreadLocal-内存泄露问题" class="headerlink" title="3.4. ThreadLocal 内存泄露问题"></a>3.4. ThreadLocal 内存泄露问题</h3><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">      <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">      Object value;</span><br><span class="line"></span><br><span class="line">      Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">          <span class="keyword">super</span>(k);</span><br><span class="line">          value = v;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>弱引用介绍：</strong></p><blockquote><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p></blockquote><h2 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4. 线程池"></a>4. 线程池</h2><h3 id="4-1-为什么要用线程池？"><a href="#4-1-为什么要用线程池？" class="headerlink" title="4.1. 为什么要用线程池？"></a>4.1. 为什么要用线程池？</h3><blockquote><p><strong>池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</strong></p></blockquote><p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p><p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="4-2-实现Runnable接口和Callable接口的区别"><a href="#4-2-实现Runnable接口和Callable接口的区别" class="headerlink" title="4.2. 实现Runnable接口和Callable接口的区别"></a>4.2. 实现Runnable接口和Callable接口的区别</h3><p><code>Runnable</code>自Java 1.0以来一直存在，但<code>Callable</code>仅在Java 1.5中引入,目的就是为了来处理<code>Runnable</code>不支持的用例。<strong><code>Runnable</code> 接口</strong>不会返回结果或抛出检查异常，但是<strong><code>Callable</code> 接口</strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <strong><code>Runnable</code> 接口</strong>，这样代码看起来会更加简洁。</p><p>工具类 <code>Executors</code> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。（<code>Executors.callable（Runnable task</code>）或 <code>Executors.callable（Runnable task，Object resule）</code>）。</p><p><code>Runnable.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Callable.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，或在无法这样做时抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-执行execute-方法和submit-方法的区别是什么呢？"><a href="#4-3-执行execute-方法和submit-方法的区别是什么呢？" class="headerlink" title="4.3. 执行execute()方法和submit()方法的区别是什么呢？"></a>4.3. 执行execute()方法和submit()方法的区别是什么呢？</h3><ol><li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li><li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ol><p>我们以<strong><code>AbstractExecutorService</code></strong>接口中的一个 <code>submit</code> 方法为例子来看看源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法调用的 <code>newTaskFor</code> 方法返回了一个 <code>FutureTask</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看看<code>execute()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-如何创建线程池"><a href="#4-4-如何创建线程池" class="headerlink" title="4.4. 如何创建线程池"></a>4.4. 如何创建线程池</h3><p>《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><blockquote><p>Executors 返回线程池对象的弊端如下：</p><ul><li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致OOM。</li><li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li></ul></blockquote><p><strong>方式一：通过构造方法实现</strong><br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ThreadPoolExecutor%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png" alt="ThreadPoolExecutor构造方法"><br><strong>方式二：通过Executor 框架的工具类Executors来实现</strong><br>我们可以创建三种类型的ThreadPoolExecutor：</p><ul><li><strong>FixedThreadPool</strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong>SingleThreadExecutor：</strong> 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li></ul><p>对应Executors工具类中的方法如图所示：<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/Executor%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB.png" alt="Executor框架的工具类"></p><h3 id="4-5-ThreadPoolExecutor-类分析"><a href="#4-5-ThreadPoolExecutor-类分析" class="headerlink" title="4.5 ThreadPoolExecutor 类分析"></a>4.5 ThreadPoolExecutor 类分析</h3><p><code>ThreadPoolExecutor</code> 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么），这里就不贴代码讲了，比较简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>下面这些对创建 非常重要，在后面使用线程池的过程中你一定会用到！所以，务必拿着小本本记清楚。</strong></p><h4 id="4-5-1-ThreadPoolExecutor构造函数重要参数分析"><a href="#4-5-1-ThreadPoolExecutor构造函数重要参数分析" class="headerlink" title="4.5.1 ThreadPoolExecutor构造函数重要参数分析"></a>4.5.1 <code>ThreadPoolExecutor</code>构造函数重要参数分析</h4><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数:</p><ol><li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li></ol><h4 id="4-5-2-ThreadPoolExecutor-饱和策略"><a href="#4-5-2-ThreadPoolExecutor-饱和策略" class="headerlink" title="4.5.2 ThreadPoolExecutor 饱和策略"></a>4.5.2 <code>ThreadPoolExecutor</code> 饱和策略</h4><p><strong><code>ThreadPoolExecutor</code> 饱和策略定义:</strong></p><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p><ul><li><strong><code>ThreadPoolExecutor.AbortPolicy</code></strong>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li><li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code></strong>：调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li></ul><p>举个例子： Spring 通过 <code>ThreadPoolTaskExecutor</code> 或者我们直接通过 <code>ThreadPoolExecutor</code> 的构造函数创建线程池的时候，当我们不指定 <code>RejectedExecutionHandler</code> 饱和策略的话来配置线程池的时候默认使用的是 <code>ThreadPoolExecutor.AbortPolicy</code>。在默认情况下，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 <code>ThreadPoolExecutor.CallerRunsPolicy</code>。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 <code>ThreadPoolExecutor</code> 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）</p><h3 id="4-6-一个简单的线程池Demo-Runnable-ThreadPoolExecutor"><a href="#4-6-一个简单的线程池Demo-Runnable-ThreadPoolExecutor" class="headerlink" title="4.6 一个简单的线程池Demo:Runnable+ThreadPoolExecutor"></a>4.6 一个简单的线程池Demo:<code>Runnable</code>+<code>ThreadPoolExecutor</code></h3><p>为了让大家更清楚上面的面试题中的一些概念，我写了一个简单的线程池 Demo。</p><p>首先创建一个 <code>Runnable</code> 接口的实现类（当然也可以是 <code>Callable</code> 接口，我们上面也说了两者的区别。）</p><p><code>MyRunnable.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" Start. Time = "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" End. Time = "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试程序，我们这里以阿里巴巴推荐的使用 <code>ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</p><p><code>ThreadPoolExecutorDemo.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">            Runnable worker = <span class="keyword">new</span> MyRunnable(<span class="string">""</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Finished all threads"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们上面的代码指定了：</p><ol><li><code>corePoolSize</code>: 核心线程数为 5。</li><li><code>maximumPoolSize</code> ：最大线程数 10</li><li><code>keepAliveTime</code> : 等待时间为 1L。</li><li><code>unit</code>: 等待时间的单位为 TimeUnit.SECONDS。</li><li><code>workQueue</code>：任务队列为 <code>ArrayBlockingQueue</code>，并且容量为 100;</li><li><code>handler</code>:饱和策略为 <code>CallerRunsPolicy</code>。</li></ol><p><strong>Output：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-2 Start. Time &#x3D; Tue Nov 12 20:59:44 CST 2019</span><br><span class="line">pool-1-thread-5 Start. Time &#x3D; Tue Nov 12 20:59:44 CST 2019</span><br><span class="line">pool-1-thread-4 Start. Time &#x3D; Tue Nov 12 20:59:44 CST 2019</span><br><span class="line">pool-1-thread-1 Start. Time &#x3D; Tue Nov 12 20:59:44 CST 2019</span><br><span class="line">pool-1-thread-3 Start. Time &#x3D; Tue Nov 12 20:59:44 CST 2019</span><br><span class="line">pool-1-thread-5 End. Time &#x3D; Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">pool-1-thread-3 End. Time &#x3D; Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">pool-1-thread-2 End. Time &#x3D; Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">pool-1-thread-4 End. Time &#x3D; Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">pool-1-thread-1 End. Time &#x3D; Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">pool-1-thread-2 Start. Time &#x3D; Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">pool-1-thread-1 Start. Time &#x3D; Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">pool-1-thread-4 Start. Time &#x3D; Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">pool-1-thread-3 Start. Time &#x3D; Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">pool-1-thread-5 Start. Time &#x3D; Tue Nov 12 20:59:49 CST 2019</span><br><span class="line">pool-1-thread-2 End. Time &#x3D; Tue Nov 12 20:59:54 CST 2019</span><br><span class="line">pool-1-thread-3 End. Time &#x3D; Tue Nov 12 20:59:54 CST 2019</span><br><span class="line">pool-1-thread-4 End. Time &#x3D; Tue Nov 12 20:59:54 CST 2019</span><br><span class="line">pool-1-thread-5 End. Time &#x3D; Tue Nov 12 20:59:54 CST 2019</span><br><span class="line">pool-1-thread-1 End. Time &#x3D; Tue Nov 12 20:59:54 CST 2019</span><br></pre></td></tr></table></figure><h3 id="4-7-线程池原理分析"><a href="#4-7-线程池原理分析" class="headerlink" title="4.7 线程池原理分析"></a>4.7 线程池原理分析</h3><p>承接 4.6 节，我们通过代码输出结果可以看出：<strong>线程池每次会同时执行 5 个任务，这 5 个任务执行完之后，剩余的 5 个任务才会被执行。</strong> 大家可以先通过上面讲解的内容，分析一下到底是咋回事？（自己独立思考一会）</p><p>现在，我们就分析上面的输出内容来简单分析一下线程池原理。</p><p><strong>为了搞懂线程池的原理，我们需要首先分析一下 <code>execute</code>方法。</strong>在 4.6 节中的 Demo 中我们使用 <code>executor.execute(worker)</code>来提交一个任务到线程池中去，这个方法非常重要，下面我们来看看它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">     <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">     <span class="comment">// ctl 中保存的线程池当前的一些状态信息</span></span><br><span class="line">     <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//  下面会涉及到 3 步 操作</span></span><br><span class="line">     <span class="comment">// 1.首先判断当前线程池中之行的任务数量是否小于 corePoolSize</span></span><br><span class="line">     <span class="comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">     <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">         <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         c = ctl.get();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 2.如果当前之行的任务数量大于等于 corePoolSize 的时候就会走到这里</span></span><br><span class="line">     <span class="comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去</span></span><br><span class="line">     <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">         <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">         <span class="comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></span><br><span class="line">         <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">             reject(command);</span><br><span class="line">             <span class="comment">// 如果当前线程池为空就新创建一个线程并执行。</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">             addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">     <span class="comment">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">         reject(command);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过下图可以更好的对上面这 3 步做一个展示，下图是我为了省事直接从网上找到，原地址不明。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="图解线程池实现原理"></p><p>现在，让我们在回到 4.6 节我们写的 Demo， 现在应该是不是很容易就可以搞懂它的原理了呢？</p><p>没搞懂的话，也没关系，可以看看我的分析：</p><blockquote><p>我们在代码中模拟了 10 个任务，我们配置的核心线程数为 5 、等待队列容量为 100 ，所以每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的 5 个任务之行完成后，才会之行剩下的 5 个任务。</p></blockquote><h2 id="5-Atomic-原子类"><a href="#5-Atomic-原子类" class="headerlink" title="5. Atomic 原子类"></a>5. Atomic 原子类</h2><h3 id="5-1-介绍一下Atomic-原子类"><a href="#5-1-介绍一下Atomic-原子类" class="headerlink" title="5.1. 介绍一下Atomic 原子类"></a>5.1. 介绍一下Atomic 原子类</h3><p>Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p><p>所以，所谓原子类说简单点就是具有原子/原子操作特征的类。</p><p>并发包 <code>java.util.concurrent</code> 的原子类都存放在<code>java.util.concurrent.atomic</code>下,如下图所示。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/JUC%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%A6%82%E8%A7%88.png" alt="JUC原子类概览"></p><h3 id="5-2-JUC-包中的原子类是哪4类"><a href="#5-2-JUC-包中的原子类是哪4类" class="headerlink" title="5.2. JUC 包中的原子类是哪4类?"></a>5.2. JUC 包中的原子类是哪4类?</h3><p><strong>基本类型</strong> </p><p>使用原子的方式更新基本类型</p><ul><li>AtomicInteger：整形原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean：布尔型原子类</li></ul><p><strong>数组类型</strong></p><p>使用原子的方式更新数组里的某个元素</p><ul><li>AtomicIntegerArray：整形数组原子类</li><li>AtomicLongArray：长整形数组原子类</li><li>AtomicReferenceArray：引用类型数组原子类</li></ul><p><strong>引用类型</strong></p><ul><li>AtomicReference：引用类型原子类</li><li>AtomicStampedReference：原子更新引用类型里的字段原子类</li><li>AtomicMarkableReference ：原子更新带有标记位的引用类型</li></ul><p><strong>对象的属性修改类型</strong></p><ul><li>AtomicIntegerFieldUpdater：原子更新整形字段的更新器</li><li>AtomicLongFieldUpdater：原子更新长整形字段的更新器</li><li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li></ul><h3 id="5-3-讲讲-AtomicInteger-的使用"><a href="#5-3-讲讲-AtomicInteger-的使用" class="headerlink" title="5.3. 讲讲 AtomicInteger 的使用"></a>5.3. 讲讲 AtomicInteger 的使用</h3><p> <strong>AtomicInteger 类常用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span></span><br></pre></td></tr></table></figure><p> <strong>AtomicInteger 类的使用示例</strong></p><p>使用 AtomicInteger 之后，不用对 increment() 方法加锁也可以保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">      <span class="comment">//使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  count.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-能不能给我简单介绍一下-AtomicInteger-类的原理"><a href="#5-4-能不能给我简单介绍一下-AtomicInteger-类的原理" class="headerlink" title="5.4. 能不能给我简单介绍一下 AtomicInteger 类的原理"></a>5.4. 能不能给我简单介绍一下 AtomicInteger 类的原理</h3><p>AtomicInteger 线程安全原理简单分析</p><p>AtomicInteger 类的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p><p>关于 Atomic 原子类这部分更多内容可以查看我的这篇文章：并发编程面试必备：<a href="https://mp.weixin.qq.com/s/joa-yOiTrYF67bElj8xqvg" target="_blank" rel="noopener">JUC 中的 Atomic 原子类总结</a></p><h2 id="6-AQS"><a href="#6-AQS" class="headerlink" title="6. AQS"></a>6. AQS</h2><h3 id="6-1-AQS-介绍"><a href="#6-1-AQS-介绍" class="headerlink" title="6.1. AQS 介绍"></a>6.1. AQS 介绍</h3><p>AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/AQS%E7%B1%BB.png" alt="AQS类"></p><p>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。</p><h3 id="6-2-AQS-原理分析"><a href="#6-2-AQS-原理分析" class="headerlink" title="6.2. AQS 原理分析"></a>6.2. AQS 原理分析</h3><p>AQS 原理这部分参考了部分博客，在5.2节末尾放了链接。</p><blockquote><p>在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于AQS原理的理解”。下面给大家一个示例供大家参加，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。</p></blockquote><p>下面大部分内容其实在AQS类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。</p><h4 id="6-2-1-AQS-原理概览"><a href="#6-2-1-AQS-原理概览" class="headerlink" title="6.2.1. AQS 原理概览"></a>6.2.1. AQS 原理概览</h4><p><strong>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p><blockquote><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</p></blockquote><p>看个AQS(AbstractQueuedSynchronizer)原理图：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/AQS%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="AQS原理图"></p><p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure><p>状态信息通过protected类型的getState，setState，compareAndSetState进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123; </span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-2-AQS-对资源的共享方式"><a href="#6-2-2-AQS-对资源的共享方式" class="headerlink" title="6.2.2. AQS 对资源的共享方式"></a>6.2.2. AQS 对资源的共享方式</h4><p><strong>AQS定义两种资源共享方式</strong></p><ul><li><strong>Exclusive</strong>（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：<ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li><li><strong>Share</strong>（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</li></ul><p>ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。</p><h4 id="6-2-3-AQS底层使用了模板方法模式"><a href="#6-2-3-AQS底层使用了模板方法模式" class="headerlink" title="6.2.3. AQS底层使用了模板方法模式"></a>6.2.3. AQS底层使用了模板方法模式</h4><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p><ol><li>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</li><li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li></ol><p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p><p><strong>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure><p>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。 </p><p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p><p>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p><p>推荐两篇 AQS 原理和相关源码分析的文章：</p><ul><li><a href="http://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">http://www.cnblogs.com/waterystone/p/4920797.html</a></li><li><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></li></ul><h3 id="6-3-AQS-组件总结"><a href="#6-3-AQS-组件总结" class="headerlink" title="6.3. AQS 组件总结"></a>6.3. AQS 组件总结</h3><ul><li><strong>Semaphore(信号量)-允许多个线程同时访问：</strong> synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li><li><strong>CountDownLatch （倒计时器）：</strong> CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li><li><strong>CyclicBarrier(循环栅栏)：</strong> CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li></ul><h2 id="7-Reference"><a href="#7-Reference" class="headerlink" title="7 Reference"></a>7 Reference</h2><ul><li>《深入理解 Java 虚拟机》</li><li>《实战 Java 高并发程序设计》</li><li>《Java并发编程的艺术》</li><li><a href="http://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">http://www.cnblogs.com/waterystone/p/4920797.html</a></li><li><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></li><li><a href="https://www.journaldev.com/1076/java-threadlocal-example" target="_blank" rel="noopener">https://www.journaldev.com/1076/java-threadlocal-example</a></li></ul><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p><p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。 </p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/qrcode_for_gh_ea338256af79_258.jpg" alt="我的公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发基础常见面试题总结</title>
      <link href="/posts/e7de409f/"/>
      <url>/posts/e7de409f/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><h1 id="Java-并发基础常见面试题总结"><a href="#Java-并发基础常见面试题总结" class="headerlink" title="Java 并发基础常见面试题总结"></a>Java 并发基础常见面试题总结</h1><h2 id="1-什么是线程和进程"><a href="#1-什么是线程和进程" class="headerlink" title="1. 什么是线程和进程?"></a>1. 什么是线程和进程?</h2><h3 id="1-1-何为进程"><a href="#1-1-何为进程" class="headerlink" title="1.1. 何为进程?"></a>1.1. 何为进程?</h3><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><p>如下图所示，在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe 文件的运行）。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E8%BF%9B%E7%A8%8B%E7%A4%BA%E4%BE%8B%E5%9B%BE%E7%89%87-Windows.png" alt="进程示例图片-Windows"></p><h3 id="1-2-何为线程"><a href="#1-2-何为线程" class="headerlink" title="1.2. 何为线程?"></a>1.2. 何为线程?</h3><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p>Java 程序天生就是多线程程序，我们可以通过 JMX 来看一下一个普通的 Java 程序有哪些线程，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取 Java 线程管理 MXBean</span></span><br><span class="line">ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line"><span class="comment">// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span></span><br><span class="line">ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 遍历线程信息，仅打印线程 ID 和线程名称信息</span></span><br><span class="line"><span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">System.out.println(<span class="string">"["</span> + threadInfo.getThreadId() + <span class="string">"] "</span> + threadInfo.getThreadName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[5] Attach Listener &#x2F;&#x2F;添加事件</span><br><span class="line">[4] Signal Dispatcher &#x2F;&#x2F; 分发处理给 JVM 信号的线程</span><br><span class="line">[3] Finalizer &#x2F;&#x2F;调用对象 finalize 方法的线程</span><br><span class="line">[2] Reference Handler &#x2F;&#x2F;清除 reference 线程</span><br><span class="line">[1] main &#x2F;&#x2F;main 线程,程序入口</span><br></pre></td></tr></table></figure><p>从上面的输出内容可以看出：<strong>一个 Java 程序的运行是 main 线程和多个其他线程同时运行</strong>。</p><h2 id="2-请简要描述线程与进程的关系-区别及优缺点？"><a href="#2-请简要描述线程与进程的关系-区别及优缺点？" class="headerlink" title="2. 请简要描述线程与进程的关系,区别及优缺点？"></a>2. 请简要描述线程与进程的关系,区别及优缺点？</h2><p><strong>从 JVM 角度说进程和线程之间的关系</strong></p><h3 id="2-1-图解进程和线程的关系"><a href="#2-1-图解进程和线程的关系" class="headerlink" title="2.1. 图解进程和线程的关系"></a>2.1. 图解进程和线程的关系</h3><p>下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。如果你对 Java 内存区域 (运行时数据区) 这部分知识不太了解的话可以阅读一下这篇文章：<a href="https://github.com/Snailclimb/JavaGuide/blob/3965c02cc0f294b0bd3580df4868d5e396959e2e/Java%E7%9B%B8%E5%85%B3/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%8A%8AJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AE%B2%E7%9A%84%E6%9C%80%E6%B8%85%E6%A5%9A%E7%9A%84%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0.md" target="_blank" rel="noopener" title="《可能是把 Java 内存区域讲的最清楚的一篇文章》">《可能是把 Java 内存区域讲的最清楚的一篇文章》</a></p><div align="center">  <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/JVM运行时数据区域.png" width="600px"/></div><p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)</strong>资源，但是每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p><p><strong>总结：</strong> 线程 是 进程 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反</p><p>下面是该知识点的扩展内容！</p><p>下面来思考这样一个问题：为什么<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>是线程私有的呢？为什么堆和方法区是线程共享的呢？</p><h3 id="2-2-程序计数器为什么是私有的"><a href="#2-2-程序计数器为什么是私有的" class="headerlink" title="2.2. 程序计数器为什么是私有的?"></a>2.2. 程序计数器为什么是私有的?</h3><p>程序计数器主要有下面两个作用：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p><h3 id="2-3-虚拟机栈和本地方法栈为什么是私有的"><a href="#2-3-虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="2.3. 虚拟机栈和本地方法栈为什么是私有的?"></a>2.3. 虚拟机栈和本地方法栈为什么是私有的?</h3><ul><li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p><h3 id="2-4-一句话简单了解堆和方法区"><a href="#2-4-一句话简单了解堆和方法区" class="headerlink" title="2.4. 一句话简单了解堆和方法区"></a>2.4. 一句话简单了解堆和方法区</h3><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h2 id="3-说说并发与并行的区别"><a href="#3-说说并发与并行的区别" class="headerlink" title="3. 说说并发与并行的区别?"></a>3. 说说并发与并行的区别?</h2><ul><li><strong>并发：</strong> 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；</li><li><strong>并行：</strong> 单位时间内，多个任务同时执行。</li></ul><h2 id="4-为什么要使用多线程呢"><a href="#4-为什么要使用多线程呢" class="headerlink" title="4. 为什么要使用多线程呢?"></a>4. 为什么要使用多线程呢?</h2><p>先从总体上来说：</p><ul><li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li><li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li></ul><p>再深入到计算机底层来探讨：</p><ul><li><strong>单核时代：</strong> 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。</li><li><strong>多核时代:</strong> 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</li></ul><h2 id="5-使用多线程可能带来什么问题"><a href="#5-使用多线程可能带来什么问题" class="headerlink" title="5. 使用多线程可能带来什么问题?"></a>5. 使用多线程可能带来什么问题?</h2><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。</p><h2 id="6-说说线程的生命周期和状态"><a href="#6-说说线程的生命周期和状态" class="headerlink" title="6. 说说线程的生命周期和状态?"></a>6. 说说线程的生命周期和状态?</h2><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="Java 线程的状态 "></p><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java+%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png" alt="Java 线程状态变迁 "></p><blockquote><p>订正(来自<a href="https://github.com/Snailclimb/JavaGuide/issues/736" target="_blank" rel="noopener">issue736</a>)：原图中 wait到 runnable状态的转换中，<code>join</code>实际上是<code>Thread</code>类的方法，但这里写成了<code>Object</code>。</p></blockquote><p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><blockquote><p>操作系统隐藏 Java 虚拟机（JVM）中的 RUNNABLE 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/" target="_blank" rel="noopener" title="HowToDoInJava">HowToDoInJava</a>：<a href="https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/" target="_blank" rel="noopener" title="Java Thread Life Cycle and Thread States">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/RUNNABLE-VS-RUNNING.png" alt="RUNNABLE-VS-RUNNING"></p><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p><h2 id="7-什么是上下文切换"><a href="#7-什么是上下文切换" class="headerlink" title="7. 什么是上下文切换?"></a>7. 什么是上下文切换?</h2><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p><p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p><p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p><h2 id="8-什么是线程死锁-如何避免死锁"><a href="#8-什么是线程死锁-如何避免死锁" class="headerlink" title="8. 什么是线程死锁?如何避免死锁?"></a>8. 什么是线程死锁?如何避免死锁?</h2><h3 id="8-1-认识线程死锁"><a href="#8-1-认识线程死锁" class="headerlink" title="8.1. 认识线程死锁"></a>8.1. 认识线程死锁</h3><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-4/2019-4%E6%AD%BB%E9%94%811.png" alt="线程死锁示意图 "></p><p>下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource1 = <span class="keyword">new</span> Object();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource2 = <span class="keyword">new</span> Object();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource2"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程 1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource1"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程 2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]waiting get resource1</span><br></pre></td></tr></table></figure><p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。</p><p>学过操作系统的朋友都知道产生死锁必须具备以下四个条件：</p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><h3 id="8-2-如何避免线程死锁"><a href="#8-2-如何避免线程死锁" class="headerlink" title="8.2. 如何避免线程死锁?"></a>8.2. 如何避免线程死锁?</h3><p>我上面说了产生死锁的四个必要条件，为了避免死锁，我们只要破坏产生死锁的四个条件中的其中一个就可以了。现在我们来挨个分析一下：</p><ol><li><strong>破坏互斥条件</strong> ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</li><li><strong>破坏请求与保持条件</strong>  ：一次性申请所有的资源。</li><li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ol><p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">"waiting get resource2"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">"线程 2"</span>).start();</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 1,5,main]get resource2</span><br><span class="line">Thread[线程 2,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>我们分析一下上面的代码为什么避免了死锁的发生?</p><p>线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p><h2 id="9-说说-sleep-方法和-wait-方法区别和共同点"><a href="#9-说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="9. 说说 sleep() 方法和 wait() 方法区别和共同点?"></a>9. 说说 sleep() 方法和 wait() 方法区别和共同点?</h2><ul><li>两者最主要的区别在于：<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong> 。</li><li>两者都可以暂停线程的执行。</li><li>Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。</li><li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。</li></ul><h2 id="10-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#10-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="10. 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>10. 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h2><p>这是另一个非常经典的 java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p><p>new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong></p><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p><p><strong>《Java 面试突击》:</strong> 由本文档衍生的专为面试而生的《Java 面试突击》V2.0 PDF 版本<a href="#公众号" title="公众号">公众号</a>后台回复 <strong>“面试突击”</strong> 即可免费领取！</p><p><strong>Java 工程师必备学习资源:</strong> 一些 Java 工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/167598cd2e17b8ec.png" alt="我的公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程池学习</title>
      <link href="/posts/bd62b625/"/>
      <url>/posts/bd62b625/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><h2 id="一-使用线程池的好处"><a href="#一-使用线程池的好处" class="headerlink" title="一 使用线程池的好处"></a>一 使用线程池的好处</h2><blockquote><p><strong>池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</strong></p></blockquote><p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p><p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h2 id="二-Executor-框架"><a href="#二-Executor-框架" class="headerlink" title="二 Executor 框架"></a>二 Executor 框架</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>Executor 框架是 Java5 之后引进的，在 Java 5 之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。</p><blockquote><p>补充：this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p></blockquote><p>Executor 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor 框架让并发编程变得更加简单。</p><h3 id="2-2-Executor-框架结构-主要由三大部分组成"><a href="#2-2-Executor-框架结构-主要由三大部分组成" class="headerlink" title="2.2 Executor 框架结构(主要由三大部分组成)"></a>2.2 Executor 框架结构(主要由三大部分组成)</h3><h4 id="1-任务-Runnable-Callable"><a href="#1-任务-Runnable-Callable" class="headerlink" title="1) 任务(Runnable /Callable)"></a>1) 任务(<code>Runnable</code> /<code>Callable</code>)</h4><p>执行任务需要实现的 <strong><code>Runnable</code> 接口</strong> 或 <strong><code>Callable</code>接口</strong>。<strong><code>Runnable</code> 接口</strong>或 <strong><code>Callable</code> 接口</strong> 实现类都可以被 <strong><code>ThreadPoolExecutor</code></strong> 或 <strong><code>ScheduledThreadPoolExecutor</code></strong> 执行。</p><h4 id="2-任务的执行-Executor"><a href="#2-任务的执行-Executor" class="headerlink" title="2) 任务的执行(Executor)"></a>2) 任务的执行(<code>Executor</code>)</h4><p>如下图所示，包括任务执行机制的核心接口 <strong><code>Executor</code></strong> ，以及继承自 <code>Executor</code> 接口的 <strong><code>ExecutorService</code> 接口。<code>ThreadPoolExecutor</code></strong> 和 <strong><code>ScheduledThreadPoolExecutor</code></strong> 这两个关键类实现了 <strong>ExecutorService 接口</strong>。</p><p><strong>这里提了很多底层的类关系，但是，实际上我们需要更多关注的是 <code>ThreadPoolExecutor</code> 这个类，这个类在我们实际使用线程池的过程中，使用频率还是非常高的。</strong></p><blockquote><p><strong>注意：</strong> 通过查看 <code>ScheduledThreadPoolExecutor</code> 源代码我们发现 <code>ScheduledThreadPoolExecutor</code> 实际上是继承了 <code>ThreadPoolExecutor</code> 并实现了 ScheduledExecutorService ，而 <code>ScheduledExecutorService</code> 又实现了 <code>ExecutorService</code>，正如我们下面给出的类关系图显示的一样。</p></blockquote><p><strong><code>ThreadPoolExecutor</code> 类描述:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractExecutorService实现了ExecutorService接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span></span><br></pre></td></tr></table></figure><p><strong><code>ScheduledThreadPoolExecutor</code> 类描述:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ScheduledExecutorService实现了ExecutorService接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span></span></span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3.png" alt="任务的执行相关接口"></p><h4 id="3-异步计算的结果-Future"><a href="#3-异步计算的结果-Future" class="headerlink" title="3) 异步计算的结果(Future)"></a>3) 异步计算的结果(<code>Future</code>)</h4><p><strong><code>Future</code></strong> 接口以及 <code>Future</code> 接口的实现类 <strong><code>FutureTask</code></strong> 类都可以代表异步计算的结果。</p><p>当我们把 <strong><code>Runnable</code>接口</strong> 或 <strong><code>Callable</code> 接口</strong> 的实现类提交给 <strong><code>ThreadPoolExecutor</code></strong> 或 <strong><code>ScheduledThreadPoolExecutor</code></strong> 执行。（调用 <code>submit()</code> 方法时会返回一个 <strong><code>FutureTask</code></strong> 对象）</p><h3 id="2-3-Executor-框架的使用示意图"><a href="#2-3-Executor-框架的使用示意图" class="headerlink" title="2.3 Executor 框架的使用示意图"></a>2.3 Executor 框架的使用示意图</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://imgconvert.csdnimg.cn/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC01LTMwLzg0ODIzMzMwLmpwZw?x-oss-process=image/format,png" alt="Executor 框架的使用示意图"></p><ol><li><strong>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</strong></li><li><strong>把创建完成的实现 <code>Runnable</code>/<code>Callable</code>接口的 对象直接交给 <code>ExecutorService</code> 执行</strong>: <code>ExecutorService.execute（Runnable command）</code>）或者也可以把 <code>Runnable</code> 对象或<code>Callable</code> 对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit（Runnable task）</code>或 <code>ExecutorService.submit（Callable &lt;T&gt; task）</code>）。</li><li><strong>如果执行 <code>ExecutorService.submit（…）</code>，<code>ExecutorService</code> 将返回一个实现<code>Future</code>接口的对象</strong>（我们刚刚也提到过了执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，<code>submit()</code>会返回一个 <code>FutureTask 对象）。由于 FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</li><li><strong>最后，主线程可以执行 <code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行。</strong></li></ol><h2 id="三-重要-ThreadPoolExecutor-类简单介绍"><a href="#三-重要-ThreadPoolExecutor-类简单介绍" class="headerlink" title="三 (重要)ThreadPoolExecutor 类简单介绍"></a>三 (重要)ThreadPoolExecutor 类简单介绍</h2><p><strong>线程池实现类 <code>ThreadPoolExecutor</code> 是 <code>Executor</code> 框架最核心的类。</strong></p><h3 id="3-1-ThreadPoolExecutor-类分析"><a href="#3-1-ThreadPoolExecutor-类分析" class="headerlink" title="3.1 ThreadPoolExecutor 类分析"></a>3.1 ThreadPoolExecutor 类分析</h3><p><code>ThreadPoolExecutor</code> 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么），这里就不贴代码讲了，比较简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//线程池的核心线程数量</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,//线程池的最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,//时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span></span><br><span class="line"><span class="function"><span class="params">                           )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>下面这些对创建 非常重要，在后面使用线程池的过程中你一定会用到！所以，务必拿着小本本记清楚。</strong></p><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，信任就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数:</p><ol><li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li></ol><p>下面这张图可以加深你对线程池中各个参数的相互关系的理解（图片来源：《Java 性能调优实战》）：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt="线程池各个参数的关系"></p><p><strong><code>ThreadPoolExecutor</code> 饱和策略定义:</strong></p><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p><ul><li><strong><code>ThreadPoolExecutor.AbortPolicy</code></strong>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li><li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code></strong>：调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li></ul><p>举个例子：</p><blockquote><p>Spring 通过 <code>ThreadPoolTaskExecutor</code> 或者我们直接通过 <code>ThreadPoolExecutor</code> 的构造函数创建线程池的时候，当我们不指定 <code>RejectedExecutionHandler</code> 饱和策略的话来配置线程池的时候默认使用的是 <code>ThreadPoolExecutor.AbortPolicy</code>。在默认情况下，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 <code>ThreadPoolExecutor.CallerRunsPolicy</code>。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 <code>ThreadPoolExecutor</code> 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了。）</p></blockquote><h3 id="3-2-推荐使用-ThreadPoolExecutor-构造函数创建线程池"><a href="#3-2-推荐使用-ThreadPoolExecutor-构造函数创建线程池" class="headerlink" title="3.2 推荐使用 ThreadPoolExecutor 构造函数创建线程池"></a>3.2 推荐使用 <code>ThreadPoolExecutor</code> 构造函数创建线程池</h3><p><strong>在《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</strong></p><p><strong>为什么呢？</strong></p><blockquote><p><strong>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</strong></p></blockquote><p><strong>另外《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</strong></p><blockquote><p>Executors 返回线程池对象的弊端如下：</p><ul><li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM。</li><li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li></ul></blockquote><p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数实现（推荐）</strong><br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://imgconvert.csdnimg.cn/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC00LTE2LzE3ODU4MjMwLmpwZw?x-oss-process=image/format,png" alt="通过构造方法实现"><br><strong>方式二：通过 Executor 框架的工具类 Executors 来实现</strong><br>我们可以创建三种类型的 ThreadPoolExecutor：</p><ul><li><strong>FixedThreadPool</strong></li><li><strong>SingleThreadExecutor</strong></li><li><strong>CachedThreadPool</strong></li></ul><p>对应 Executors 工具类中的方法如图所示：<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/format,png.jpeg" alt="通过Executor 框架的工具类Executors来实现"></p><h2 id="四-重要-ThreadPoolExecutor-使用示例"><a href="#四-重要-ThreadPoolExecutor-使用示例" class="headerlink" title="四 (重要)ThreadPoolExecutor 使用示例"></a>四 (重要)ThreadPoolExecutor 使用示例</h2><p>我们上面讲解了 <code>Executor</code>框架以及 <code>ThreadPoolExecutor</code> 类，下面让我们实战一下，来通过写一个 <code>ThreadPoolExecutor</code> 的小 Demo 来回顾上面的内容。</p><h3 id="4-1-示例代码-Runnable-ThreadPoolExecutor"><a href="#4-1-示例代码-Runnable-ThreadPoolExecutor" class="headerlink" title="4.1 示例代码:Runnable+ThreadPoolExecutor"></a>4.1 示例代码:<code>Runnable</code>+<code>ThreadPoolExecutor</code></h3><p>首先创建一个 <code>Runnable</code> 接口的实现类（当然也可以是 <code>Callable</code> 接口，我们上面也说了两者的区别。）</p><p><code>MyRunnable.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" Start. Time = "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" End. Time = "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试程序，我们这里以阿里巴巴推荐的使用 <code>ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</p><p><code>ThreadPoolExecutorDemo.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">            Runnable worker = <span class="keyword">new</span> MyRunnable(<span class="string">""</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Finished all threads"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们上面的代码指定了：</p><ol><li><code>corePoolSize</code>: 核心线程数为 5。</li><li><code>maximumPoolSize</code> ：最大线程数 10</li><li><code>keepAliveTime</code> : 等待时间为 1L。</li><li><code>unit</code>: 等待时间的单位为 TimeUnit.SECONDS。</li><li><code>workQueue</code>：任务队列为 <code>ArrayBlockingQueue</code>，并且容量为 100;</li><li><code>handler</code>:饱和策略为 <code>CallerRunsPolicy</code>。</li></ol><p><strong>Output：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-3 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-5 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-2 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-1 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-4 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-3 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-4 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-1 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-5 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-1 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-2 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-5 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-4 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-3 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-2 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-1 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br><span class="line">pool-1-thread-4 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br><span class="line">pool-1-thread-5 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br><span class="line">pool-1-thread-3 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br><span class="line">pool-1-thread-2 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br></pre></td></tr></table></figure><h3 id="4-2-线程池原理分析"><a href="#4-2-线程池原理分析" class="headerlink" title="4.2 线程池原理分析"></a>4.2 线程池原理分析</h3><p>承接 4.1 节，我们通过代码输出结果可以看出：<strong>线程首先会先执行 5 个任务，然后这些任务有任务被执行完的话，就会去拿新的任务执行。</strong> 大家可以先通过上面讲解的内容，分析一下到底是咋回事？（自己独立思考一会）</p><p>现在，我们就分析上面的输出内容来简单分析一下线程池原理。</p><p><strong>为了搞懂线程池的原理，我们需要首先分析一下 <code>execute</code>方法。</strong>在 4.1 节中的 Demo 中我们使用 <code>executor.execute(worker)</code>来提交一个任务到线程池中去，这个方法非常重要，下面我们来看看它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//任务队列</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">     <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">     <span class="comment">// ctl 中保存的线程池当前的一些状态信息</span></span><br><span class="line">     <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//  下面会涉及到 3 步 操作</span></span><br><span class="line">     <span class="comment">// 1.首先判断当前线程池中之行的任务数量是否小于 corePoolSize</span></span><br><span class="line">     <span class="comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">     <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">         <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         c = ctl.get();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 2.如果当前之行的任务数量大于等于 corePoolSize 的时候就会走到这里</span></span><br><span class="line">     <span class="comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去</span></span><br><span class="line">     <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">         <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">         <span class="comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></span><br><span class="line">         <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">             reject(command);</span><br><span class="line">             <span class="comment">// 如果当前线程池为空就新创建一个线程并执行。</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">             addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">     <span class="comment">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">         reject(command);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过下图可以更好的对上面这 3 步做一个展示，下图是我为了省事直接从网上找到，原地址不明。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="图解线程池实现原理"></p><p><strong><code>addWorker</code> 这个方法主要用来创建新的工作线程，如果返回true说明创建和启动工作线程成功，否则的话返回的就是false。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 全局锁，并发操作必备</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> <span class="comment">// 跟踪线程池的最大大小，只有在持有全局锁mainLock的前提下才能访问此集合</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"> <span class="comment">// 工作线程集合，存放线程池中所有的（活跃的）工作线程，只有在持有全局锁mainLock的前提下才能访问此集合</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"> <span class="comment">//获取线程池状态</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"> <span class="comment">//判断线程池的状态是否为 Running</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 添加新的工作线程到线程池</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> firstTask 要执行</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> core参数为true的话表示使用线程池的基本大小，为false使用线程池最大大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 添加成功就返回true否则返回false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">     retry:</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="comment">//这两句用来获取线程池的状态</span></span><br><span class="line">         <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">         <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">         <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">             ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取线程池中线程的数量</span></span><br><span class="line">             <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">             <span class="comment">// core参数为true的话表明队列也满了，线程池大小变为 maximumPoolSize </span></span><br><span class="line">             <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                 wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//原子操作将workcount的数量加1</span></span><br><span class="line">             <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                 <span class="keyword">break</span> retry;</span><br><span class="line">             <span class="comment">// 如果线程的状态改变了就再次执行上述操作</span></span><br><span class="line">             c = ctl.get();  </span><br><span class="line">             <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                 <span class="keyword">continue</span> retry;</span><br><span class="line">             <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 标记工作线程是否启动成功</span></span><br><span class="line">     <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">     <span class="comment">// 标记工作线程是否创建成功</span></span><br><span class="line">     <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">     Worker w = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">     </span><br><span class="line">         w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">         <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">         <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 加锁</span></span><br><span class="line">             <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">             mainLock.lock();</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取线程池状态</span></span><br><span class="line">                 <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">//rs &lt; SHUTDOWN 如果线程池状态依然为RUNNING,并且线程的状态是存活的话，就会将工作线程添加到工作线程集合中</span></span><br><span class="line">               <span class="comment">//(rs=SHUTDOWN &amp;&amp; firstTask == null)如果线程池状态小于STOP，也就是RUNNING或者SHUTDOWN状态下，同时传入的任务实例firstTask为null，则需要添加到工作线程集合和启动新的Worker</span></span><br><span class="line">                <span class="comment">// firstTask == null证明只新建线程而不执行任务</span></span><br><span class="line">                 <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                     (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                     workers.add(w);</span><br><span class="line">                    <span class="comment">//更新当前工作线程的最大容量</span></span><br><span class="line">                     <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                     <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                         largestPoolSize = s;</span><br><span class="line">                   <span class="comment">// 工作线程是否启动成功</span></span><br><span class="line">                     workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 <span class="comment">// 释放锁</span></span><br><span class="line">                 mainLock.unlock();</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//// 如果成功添加工作线程，则调用Worker内部的线程实例t的Thread#start()方法启动真实的线程实例</span></span><br><span class="line">             <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                 t.start();</span><br><span class="line">               <span class="comment">/// 标记线程启动成功</span></span><br><span class="line">                 workerStarted = <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 线程启动失败，需要从工作线程中移除对应的Worker</span></span><br><span class="line">         <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">             addWorkerFailed(w);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> workerStarted;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>更多关于线程池源码分析的内容推荐这篇文章：《<a href="http://www.throwable.club/2019/07/15/java-concurrency-thread-pool-executor/" target="_blank" rel="noopener">JUC线程池ThreadPoolExecutor源码分析</a>》</p><p>现在，让我们在回到 4.1 节我们写的 Demo， 现在应该是不是很容易就可以搞懂它的原理了呢？</p><p>没搞懂的话，也没关系，可以看看我的分析：</p><blockquote><p>我们在代码中模拟了 10 个任务，我们配置的核心线程数为 5 、等待队列容量为 100 ，所以每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的5个任务中如果有任务被执行完了，线程池就会去拿新的任务执行。</p></blockquote><h3 id="4-3-几个常见的对比"><a href="#4-3-几个常见的对比" class="headerlink" title="4.3 几个常见的对比"></a>4.3 几个常见的对比</h3><h4 id="4-3-1-Runnable-vs-Callable"><a href="#4-3-1-Runnable-vs-Callable" class="headerlink" title="4.3.1 Runnable vs Callable"></a>4.3.1 <code>Runnable</code> vs <code>Callable</code></h4><p><code>Runnable</code>自 Java 1.0 以来一直存在，但<code>Callable</code>仅在 Java 1.5 中引入,目的就是为了来处理<code>Runnable</code>不支持的用例。<strong><code>Runnable</code> 接口</strong>不会返回结果或抛出检查异常，但是<strong><code>Callable</code> 接口</strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <strong><code>Runnable</code> 接口</strong>，这样代码看起来会更加简洁。</p><p>工具类 <code>Executors</code> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。（<code>Executors.callable（Runnable task</code>）或 <code>Executors.callable（Runnable task，Object resule）</code>）。</p><p><code>Runnable.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Callable.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，或在无法这样做时抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-2-execute-vs-submit"><a href="#4-3-2-execute-vs-submit" class="headerlink" title="4.3.2 execute() vs submit()"></a>4.3.2 <code>execute()</code> vs <code>submit()</code></h4><ol><li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li><li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ol><p>我们以<strong><code>AbstractExecutorService</code></strong>接口中的一个 <code>submit</code> 方法为例子来看看源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法调用的 <code>newTaskFor</code> 方法返回了一个 <code>FutureTask</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看看<code>execute()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-3-shutdown-VSshutdownNow"><a href="#4-3-3-shutdown-VSshutdownNow" class="headerlink" title="4.3.3 shutdown()VSshutdownNow()"></a>4.3.3 <code>shutdown()</code>VS<code>shutdownNow()</code></h4><ul><li><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li><li><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li></ul><h4 id="4-3-2-isTerminated-VS-isShutdown"><a href="#4-3-2-isTerminated-VS-isShutdown" class="headerlink" title="4.3.2 isTerminated() VS isShutdown()"></a>4.3.2 <code>isTerminated()</code> VS <code>isShutdown()</code></h4><ul><li><strong><code>isShutDown</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</li><li><strong><code>isTerminated</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</li></ul><h3 id="4-4-加餐-Callable-ThreadPoolExecutor示例代码"><a href="#4-4-加餐-Callable-ThreadPoolExecutor示例代码" class="headerlink" title="4.4 加餐:Callable+ThreadPoolExecutor示例代码"></a>4.4 加餐:<code>Callable</code>+<code>ThreadPoolExecutor</code>示例代码</h3><p><code>MyCallable.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//返回执行当前 Callable 的线程名字</span></span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CallableDemo.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; futureList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Callable&lt;String&gt; callable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//提交任务到线程池</span></span><br><span class="line">            Future&lt;String&gt; future = executor.submit(callable);</span><br><span class="line">            <span class="comment">//将返回值 future 添加到 list，我们可以通过 future 获得 执行 Callable 得到的返回值</span></span><br><span class="line">            futureList.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; fut : futureList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> Date() + <span class="string">"::"</span> + fut.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Wed Nov 13 13:40:41 CST 2019::pool-1-thread-1</span><br><span class="line">Wed Nov 13 13:40:42 CST 2019::pool-1-thread-2</span><br><span class="line">Wed Nov 13 13:40:42 CST 2019::pool-1-thread-3</span><br><span class="line">Wed Nov 13 13:40:42 CST 2019::pool-1-thread-4</span><br><span class="line">Wed Nov 13 13:40:42 CST 2019::pool-1-thread-5</span><br><span class="line">Wed Nov 13 13:40:42 CST 2019::pool-1-thread-3</span><br><span class="line">Wed Nov 13 13:40:43 CST 2019::pool-1-thread-2</span><br><span class="line">Wed Nov 13 13:40:43 CST 2019::pool-1-thread-1</span><br><span class="line">Wed Nov 13 13:40:43 CST 2019::pool-1-thread-4</span><br><span class="line">Wed Nov 13 13:40:43 CST 2019::pool-1-thread-5</span><br></pre></td></tr></table></figure><h2 id="五-几种常见的线程池详解"><a href="#五-几种常见的线程池详解" class="headerlink" title="五 几种常见的线程池详解"></a>五 几种常见的线程池详解</h2><h3 id="5-1-FixedThreadPool"><a href="#5-1-FixedThreadPool" class="headerlink" title="5.1 FixedThreadPool"></a>5.1 FixedThreadPool</h3><h4 id="5-1-1-介绍"><a href="#5-1-1-介绍" class="headerlink" title="5.1.1 介绍"></a>5.1.1 介绍</h4><p><code>FixedThreadPool</code> 被称为可重用固定线程数的线程池。通过 Executors 类中的相关源代码来看一下相关实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建一个可重用固定数量线程的线程池</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                   <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                   <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                   threadFactory);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>另外还有一个 <code>FixedThreadPool</code> 的实现方法，和上面的类似，所以这里不多做阐述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从上面源代码可以看出新创建的 <code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 nThreads，这个 nThreads 参数是我们使用的时候自己传递的。</strong></p><h4 id="5-1-2-执行任务过程介绍"><a href="#5-1-2-执行任务过程介绍" class="headerlink" title="5.1.2 执行任务过程介绍"></a>5.1.2 执行任务过程介绍</h4><p><code>FixedThreadPool</code> 的 <code>execute()</code> 方法运行示意图（该图片来源：《Java 并发编程的艺术》）：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://imgconvert.csdnimg.cn/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC00LTE2LzcxMzc1OTYzLmpwZw?x-oss-process=image/format,png" alt="FixedThreadPool的execute()方法运行示意图"></p><p><strong>上图说明：</strong></p><ol><li>如果当前运行的线程数小于 corePoolSize， 如果再来新任务的话，就创建新的线程来执行任务；</li><li>当前运行的线程数等于 corePoolSize 后， 如果再来新任务的话，会将任务加入 <code>LinkedBlockingQueue</code>；</li><li>线程池中的线程执行完 手头的任务后，会在循环中反复从 <code>LinkedBlockingQueue</code> 中获取任务来执行；</li></ol><h4 id="5-1-3-为什么不推荐使用FixedThreadPool？"><a href="#5-1-3-为什么不推荐使用FixedThreadPool？" class="headerlink" title="5.1.3 为什么不推荐使用FixedThreadPool？"></a>5.1.3 为什么不推荐使用<code>FixedThreadPool</code>？</h4><p><strong><code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>（队列的容量为 Intger.MAX_VALUE）作为线程池的工作队列会对线程池带来如下影响 ：</strong></p><ol><li>当线程池中的线程数达到 <code>corePoolSize</code> 后，新任务将在无界队列中等待，因此线程池中的线程数不会超过 corePoolSize；</li><li>由于使用无界队列时 <code>maximumPoolSize</code> 将是一个无效参数，因为不可能存在任务队列满的情况。所以，通过创建 <code>FixedThreadPool</code>的源码可以看出创建的 <code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 被设置为同一个值。</li><li>由于 1 和 2，使用无界队列时 <code>keepAliveTime</code> 将是一个无效参数；</li><li>运行中的 <code>FixedThreadPool</code>（未执行 <code>shutdown()</code>或 <code>shutdownNow()</code>）不会拒绝任务，在任务比较多的时候会导致 OOM（内存溢出）。</li></ol><h3 id="5-2-SingleThreadExecutor-详解"><a href="#5-2-SingleThreadExecutor-详解" class="headerlink" title="5.2 SingleThreadExecutor 详解"></a>5.2 SingleThreadExecutor 详解</h3><h4 id="5-2-1-介绍"><a href="#5-2-1-介绍" class="headerlink" title="5.2.1 介绍"></a>5.2.1 介绍</h4><p><code>SingleThreadExecutor</code> 是只有一个线程的线程池。下面看看<strong>SingleThreadExecutor 的实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *返回只有一个线程的线程池</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">         (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                 threadFactory));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">         (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                 <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从上面源代码可以看出新创建的 <code>SingleThreadExecutor</code> 的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为 1.其他参数和 <code>FixedThreadPool</code> 相同。</p><h4 id="5-2-2-执行任务过程介绍"><a href="#5-2-2-执行任务过程介绍" class="headerlink" title="5.2.2 执行任务过程介绍"></a>5.2.2 执行任务过程介绍</h4><p><strong><code>SingleThreadExecutor</code> 的运行示意图（该图片来源：《Java 并发编程的艺术》）：</strong><br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://imgconvert.csdnimg.cn/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC00LTE2LzgyMjc2NDU4LmpwZw?x-oss-process=image/format,png" alt="SingleThreadExecutor的运行示意图"></p><p><strong>上图说明;</strong></p><ol><li>如果当前运行的线程数少于 corePoolSize，则创建一个新的线程执行任务；</li><li>当前线程池中有一个运行的线程后，将任务加入 <code>LinkedBlockingQueue</code></li><li>线程执行完当前的任务后，会在循环中反复从<code>LinkedBlockingQueue</code> 中获取任务来执行；</li></ol><h4 id="5-2-3-为什么不推荐使用SingleThreadExecutor？"><a href="#5-2-3-为什么不推荐使用SingleThreadExecutor？" class="headerlink" title="5.2.3 为什么不推荐使用SingleThreadExecutor？"></a>5.2.3 为什么不推荐使用<code>SingleThreadExecutor</code>？</h4><p><code>SingleThreadExecutor</code> 使用无界队列 <code>LinkedBlockingQueue</code> 作为线程池的工作队列（队列的容量为 Intger.MAX_VALUE）。<code>SingleThreadExecutor</code> 使用无界队列作为线程池的工作队列会对线程池带来的影响与 <code>FixedThreadPool</code> 相同。说简单点就是可能会导致 OOM，</p><h3 id="5-3-CachedThreadPool-详解"><a href="#5-3-CachedThreadPool-详解" class="headerlink" title="5.3 CachedThreadPool 详解"></a>5.3 CachedThreadPool 详解</h3><h4 id="5-3-1-介绍"><a href="#5-3-1-介绍" class="headerlink" title="5.3.1 介绍"></a>5.3.1 介绍</h4><p><code>CachedThreadPool</code> 是一个会根据需要创建新线程的线程池。下面通过源码来看看 <code>CachedThreadPool</code> 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CachedThreadPool</code> 的<code>corePoolSize</code> 被设置为空（0），<code>maximumPoolSize</code>被设置为 Integer.MAX.VALUE，即它是无界的，这也就意味着如果主线程提交任务的速度高于 <code>maximumPool</code> 中线程处理任务的速度时，<code>CachedThreadPool</code> 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。</p><h4 id="5-3-2-执行任务过程介绍"><a href="#5-3-2-执行任务过程介绍" class="headerlink" title="5.3.2 执行任务过程介绍"></a>5.3.2 执行任务过程介绍</h4><p><strong>CachedThreadPool 的 execute()方法的执行示意图（该图片来源：《Java 并发编程的艺术》）：</strong><br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://imgconvert.csdnimg.cn/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC00LTE2LzE4NjExNzY3LmpwZw?x-oss-process=image/format,png" alt="CachedThreadPool的execute()方法的执行示意图"></p><p><strong>上图说明：</strong></p><ol><li>首先执行 <code>SynchronousQueue.offer(Runnable task)</code> 提交任务到任务队列。如果当前 <code>maximumPool</code> 中有闲线程正在执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>，那么主线程执行 offer 操作与空闲线程执行的 <code>poll</code> 操作配对成功，主线程把任务交给空闲线程执行，<code>execute()</code>方法执行完成，否则执行下面的步骤 2；</li><li>当初始 <code>maximumPool</code> 为空，或者 <code>maximumPool</code> 中没有空闲线程时，将没有线程执行 <code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>。这种情况下，步骤 1 将失败，此时 <code>CachedThreadPool</code> 会创建新线程执行任务，execute 方法执行完成；</li></ol><h4 id="5-3-3-为什么不推荐使用CachedThreadPool？"><a href="#5-3-3-为什么不推荐使用CachedThreadPool？" class="headerlink" title="5.3.3 为什么不推荐使用CachedThreadPool？"></a>5.3.3 为什么不推荐使用<code>CachedThreadPool</code>？</h4><p><code>CachedThreadPool</code>允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</p><h2 id="六-ScheduledThreadPoolExecutor-详解"><a href="#六-ScheduledThreadPoolExecutor-详解" class="headerlink" title="六 ScheduledThreadPoolExecutor 详解"></a>六 ScheduledThreadPoolExecutor 详解</h2><p><strong><code>ScheduledThreadPoolExecutor</code> 主要用来在给定的延迟后运行任务，或者定期执行任务。</strong> 这个在实际项目中基本不会被用到，因为有其他方案选择比如<code>quartz</code>。大家只需要简单了解一下它的思想。关于如何在 Spring Boot 中 实现定时任务，可以查看这篇文章<a href="https://github.com/Snailclimb/springboot-guide/blob/master/docs/advanced/SpringBoot-ScheduleTasks.md" target="_blank" rel="noopener">《5 分钟搞懂如何在 Spring Boot 中 Schedule Tasks》</a>。</p><h3 id="6-1-简介"><a href="#6-1-简介" class="headerlink" title="6.1 简介"></a>6.1 简介</h3><p><strong><code>ScheduledThreadPoolExecutor</code> 使用的任务队列 <code>DelayQueue</code> 封装了一个 <code>PriorityQueue</code>，<code>PriorityQueue</code> 会对队列中的任务进行排序，执行所需时间短的放在前面先被执行(<code>ScheduledFutureTask</code> 的 <code>time</code> 变量小的先执行)，如果执行所需时间相同则先提交的任务将被先执行(<code>ScheduledFutureTask</code> 的 <code>squenceNumber</code> 变量小的先执行)。</strong></p><p><strong><code>ScheduledThreadPoolExecutor</code> 和 <code>Timer</code> 的比较：</strong></p><ul><li><code>Timer</code> 对系统时钟的变化敏感，<code>ScheduledThreadPoolExecutor</code>不是；</li><li><code>Timer</code> 只有一个执行线程，因此长时间运行的任务可以延迟其他任务。 <code>ScheduledThreadPoolExecutor</code> 可以配置任意数量的线程。 此外，如果你想（通过提供 ThreadFactory），你可以完全控制创建的线程;</li><li>在<code>TimerTask</code> 中抛出的运行时异常会杀死一个线程，从而导致 <code>Timer</code> 死机:-( …即计划任务将不再运行。<code>ScheduledThreadExecutor</code> 不仅捕获运行时异常，还允许您在需要时处理它们（通过重写 <code>afterExecute</code> 方法<code>ThreadPoolExecutor</code>）。抛出异常的任务将被取消，但其他任务将继续运行。</li></ul><p><strong>综上，在 JDK1.5 之后，你没有理由再使用 Timer 进行任务调度了。</strong></p><blockquote><p><strong>备注：</strong> Quartz 是一个由 java 编写的任务调度库，由 OpenSymphony 组织开源出来。在实际项目开发中使用 Quartz 的还是居多，比较推荐使用 Quartz。因为 Quartz 理论上能够同时对上万个任务进行调度，拥有丰富的功能特性，包括任务调度、任务持久化、可集群化、插件等等。</p></blockquote><h3 id="6-2-运行机制"><a href="#6-2-运行机制" class="headerlink" title="6.2 运行机制"></a>6.2 运行机制</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://imgconvert.csdnimg.cn/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC00LTE2LzkyNTk0Njk4LmpwZw?x-oss-process=image/format,png" alt="ScheduledThreadPoolExecutor运行机制"></p><p><strong><code>ScheduledThreadPoolExecutor</code> 的执行主要分为两大部分：</strong></p><ol><li>当调用 <code>ScheduledThreadPoolExecutor</code> 的 <strong><code>scheduleAtFixedRate()</code></strong> 方法或者<strong><code>scheduleWirhFixedDelay()</code></strong> 方法时，会向 <code>ScheduledThreadPoolExecutor</code> 的 <strong><code>DelayQueue</code></strong> 添加一个实现了 <strong><code>RunnableScheduledFuture</code></strong> 接口的 <strong><code>ScheduledFutureTask</code></strong> 。</li><li>线程池中的线程从 <code>DelayQueue</code> 中获取 <code>ScheduledFutureTask</code>，然后执行任务。</li></ol><p><strong><code>ScheduledThreadPoolExecutor</code> 为了实现周期性的执行任务，对 <code>ThreadPoolExecutor</code>做了如下修改：</strong></p><ul><li>使用 <strong><code>DelayQueue</code></strong> 作为任务队列；</li><li>获取任务的方不同</li><li>执行周期任务后，增加了额外的处理</li></ul><h3 id="6-3-ScheduledThreadPoolExecutor-执行周期任务的步骤"><a href="#6-3-ScheduledThreadPoolExecutor-执行周期任务的步骤" class="headerlink" title="6.3 ScheduledThreadPoolExecutor 执行周期任务的步骤"></a>6.3 ScheduledThreadPoolExecutor 执行周期任务的步骤</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://imgconvert.csdnimg.cn/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC01LTMwLzU5OTE2Mzg5LmpwZw?x-oss-process=image/format,png" alt="ScheduledThreadPoolExecutor执行周期任务的步骤"></p><ol><li>线程 1 从 <code>DelayQueue</code> 中获取已到期的 <code>ScheduledFutureTask（DelayQueue.take()）</code>。到期任务是指 <code>ScheduledFutureTask</code>的 time 大于等于当前系统的时间；</li><li>线程 1 执行这个 <code>ScheduledFutureTask</code>；</li><li>线程 1 修改 <code>ScheduledFutureTask</code> 的 time 变量为下次将要被执行的时间；</li><li>线程 1 把这个修改 time 之后的 <code>ScheduledFutureTask</code> 放回 <code>DelayQueue</code> 中（<code>DelayQueue.add()</code>)。</li></ol><h2 id="七-线程池大小确定"><a href="#七-线程池大小确定" class="headerlink" title="七 线程池大小确定"></a>七 线程池大小确定</h2><p><strong>线程池数量的确定一直是困扰着程序员的一个难题，大部分程序员在设定线程池大小的时候就是随心而定。</strong></p><p>很多人甚至可能都会觉得把线程池配置过大一点比较好！我觉得这明显是有问题的。就拿我们生活中非常常见的一例子来说：<strong>并不是人多就能把事情做好，增加了沟通交流成本。你本来一件事情只需要 3 个人做，你硬是拉来了 6 个人，会提升做事效率嘛？我想并不会。</strong> 线程数量过多的影响也是和我们分配多少人做事情一样，对于多线程这个场景来说主要是增加了<strong>上下文切换</strong>成本。不清楚什么是上下文切换的话，可以看我下面的介绍。</p><blockquote><p>上下文切换：</p><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p><p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p></blockquote><p><strong>类比于实现世界中的人类通过合作做某件事情，我们可以肯定的一点是线程池大小设置过大或者过小都会有问题，合适的才是最好。</strong></p><p><strong>如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的！ CPU 根本没有得到充分利用。</strong></p><p><strong>但是，如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</strong></p><p>有一个简单并且适用面比较广的公式：</p><ul><li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul><p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。单凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><h2 id="八-参考"><a href="#八-参考" class="headerlink" title="八 参考"></a>八 参考</h2><ul><li>《Java 并发编程的艺术》</li><li><a href="https://www.journaldev.com/2340/java-scheduler-scheduledexecutorservice-scheduledthreadpoolexecutor-example" target="_blank" rel="noopener" title="Java Scheduler ScheduledExecutorService ScheduledThreadPoolExecutor Example">Java Scheduler ScheduledExecutorService ScheduledThreadPoolExecutor Example</a></li><li><a href="https://examples.javacodegeeks.com/core-java/util/concurrent/scheduledthreadpoolexecutor/java-util-concurrent-scheduledthreadpoolexecutor-example/" target="_blank" rel="noopener" title="java.util.concurrent.ScheduledThreadPoolExecutor Example">java.util.concurrent.ScheduledThreadPoolExecutor Example</a></li><li><a href="https://www.journaldev.com/1069/threadpoolexecutor-java-thread-pool-example-executorservice" target="_blank" rel="noopener" title="ThreadPoolExecutor – Java Thread Pool Example">ThreadPoolExecutor – Java Thread Pool Example</a></li></ul><h2 id="九-其他推荐阅读"><a href="#九-其他推荐阅读" class="headerlink" title="九 其他推荐阅读"></a>九 其他推荐阅读</h2><ul><li><a href="https://www.cnblogs.com/warehouse/p/10720781.html" target="_blank" rel="noopener" title="Java并发（三）线程池原理">Java 并发（三）线程池原理</a></li><li><a href="https://github.com/crossoverJie/JCSprout/blob/master/MD/ThreadPoolExecutor.md" target="_blank" rel="noopener" title="如何优雅的使用和理解线程池">如何优雅的使用和理解线程池</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程锁</title>
      <link href="/posts/23a410c6/"/>
      <url>/posts/23a410c6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><p><a href="https://blog.csdn.net/xlgen157387/article/details/78298840" target="_blank" rel="noopener">ThreadLocal造成OOM内存溢出案例演示与原理分析</a></p><p><a href="https://allenwu.itscoder.com/threadlocal-source" target="_blank" rel="noopener">深入理解 Java 之 ThreadLocal 工作原理</a></p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong> JDK中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p><p><strong>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get（）</code> 和 <code>set（）</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</strong></p><p>再举个简单的例子： </p><p>比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么ThreadLocal就是用来这两个线程竞争的。</p><h3 id="ThreadLocal示例"><a href="#ThreadLocal示例" class="headerlink" title="ThreadLocal示例"></a>ThreadLocal示例</h3><p>相信看了上面的解释，大家已经搞懂 ThreadLocal 类是个什么东西了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd HHmm"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadLocalExample obj = <span class="keyword">new</span> ThreadLocalExample();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(obj, <span class="string">""</span>+i);</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread Name= "</span>+Thread.currentThread().getName()+<span class="string">" default Formatter = "</span>+formatter.get().toPattern());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//formatter pattern is changed here by thread, but it won't reflect to other threads</span></span><br><span class="line">        formatter.set(<span class="keyword">new</span> SimpleDateFormat());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread Name= "</span>+Thread.currentThread().getName()+<span class="string">" formatter = "</span>+formatter.get().toPattern());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread Name&#x3D; 0 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 0 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 1 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 2 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 1 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 3 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 2 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 4 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 3 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 4 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 5 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 5 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 6 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 6 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 7 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 7 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 8 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 9 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 8 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 9 formatter &#x3D; yy-M-d ah:mm</span><br></pre></td></tr></table></figure><p>从输出中可以看出，Thread-0已经改变了formatter的值，但仍然是thread-2默认格式化程序与初始化值相同，其他线程也一样。</p><p>上面有一段代码用到了创建 <code>ThreadLocal</code> 变量的那段代码用到了 Java8 的知识，它等于下面这段代码，如果你写了下面这段代码的话，IDEA会提示你转换为Java8的格式(IDEA真的不错！)。因为ThreadLocal类在Java 8中扩展，使用一个新的方法<code>withInitial()</code>，将Supplier功能接口作为参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;()&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd HHmm"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h3><p>从 <code>Thread</code>类源代码入手。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line"><span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面<code>Thread</code>类 源代码可以看出<code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个  <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code>  类型的变量,我们可以把 <code>ThreadLocalMap</code>  理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p><p><code>ThreadLocal</code>类的<code>set()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面这些内容，我们足以通过猜测得出结论：<strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。</strong></p><p><strong>每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为key的键值对。</strong> 比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话，会使用 <code>Thread</code>内部都是使用仅有那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code>的 key 就是 <code>ThreadLocal</code>对象，value 就是 <code>ThreadLocal</code> 对象调用<code>set</code>方法设置的值。<code>ThreadLocal</code> 是 map结构是为了让每个线程可以关联多个 <code>ThreadLocal</code>变量。这也就解释了ThreadLocal声明的变量为什么在每一个线程都有自己的专属本地变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line"><span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://ws1.sinaimg.cn/large/006rNwoDgy1g2f47u9li2j30ka08cq43.jpg" alt="ThreadLocal内部类"></p><h3 id="ThreadLocal-内存泄露问题"><a href="#ThreadLocal-内存泄露问题" class="headerlink" title="ThreadLocal 内存泄露问题"></a>ThreadLocal 内存泄露问题</h3><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候会 key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">      <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">      Object value;</span><br><span class="line"></span><br><span class="line">      Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">          <span class="keyword">super</span>(k);</span><br><span class="line">          value = v;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>弱引用介绍：</strong></p><blockquote><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建线程的几种方式</title>
      <link href="/posts/de5ad898/"/>
      <url>/posts/de5ad898/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><h2 id="面试官：“创建线程有哪几种常见的方式？”"><a href="#面试官：“创建线程有哪几种常见的方式？”" class="headerlink" title="面试官：“创建线程有哪几种常见的方式？”"></a>面试官：“创建线程有哪几种常见的方式？”</h2><ol><li>继承 Thread 类</li><li>实现 Runnable 接口</li><li>使用 Executor 框架</li><li>使用 FutureTask</li></ol><h2 id="最简单的两种方式"><a href="#最简单的两种方式" class="headerlink" title="最简单的两种方式"></a>最简单的两种方式</h2><h3 id="1-继承-Thread-类"><a href="#1-继承-Thread-类" class="headerlink" title="1.继承 Thread 类"></a>1.继承 Thread 类</h3><h3 id="2-实现-Runnable-接口"><a href="#2-实现-Runnable-接口" class="headerlink" title="2.实现 Runnable 接口"></a>2.实现 Runnable 接口</h3><h2 id="比较实用的两种方式"><a href="#比较实用的两种方式" class="headerlink" title="比较实用的两种方式"></a>比较实用的两种方式</h2><h3 id="3-使用-Executor-框架"><a href="#3-使用-Executor-框架" class="headerlink" title="3.使用 Executor 框架"></a>3.使用 Executor 框架</h3><p>Executor 框架是 Java5 之后引进的，在 Java 5 之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。</p><blockquote><p>补充：this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p></blockquote><p>Executor 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor 框架让并发编程变得更加简单。</p><p>为了能搞懂如何使用 Executor 框架创建</p><h3 id="Executor-框架结构-主要由三大部分组成"><a href="#Executor-框架结构-主要由三大部分组成" class="headerlink" title="Executor 框架结构(主要由三大部分组成)"></a>Executor 框架结构(主要由三大部分组成)</h3><h4 id="1-任务-Runnable-Callable"><a href="#1-任务-Runnable-Callable" class="headerlink" title="1) 任务(Runnable /Callable)"></a>1) 任务(<code>Runnable</code> /<code>Callable</code>)</h4><p>执行任务需要实现的 <strong><code>Runnable</code> 接口</strong> 或 <strong><code>Callable</code>接口</strong>。<strong><code>Runnable</code> 接口</strong>或 <strong><code>Callable</code> 接口</strong> 实现类都可以被 <strong><code>ThreadPoolExecutor</code></strong> 或 <strong><code>ScheduledThreadPoolExecutor</code></strong> 执行。</p><h4 id="2-任务的执行-Executor"><a href="#2-任务的执行-Executor" class="headerlink" title="2) 任务的执行(Executor)"></a>2) 任务的执行(<code>Executor</code>)</h4><p>如下图所示，包括任务执行机制的核心接口 <strong><code>Executor</code></strong> ，以及继承自 <code>Executor</code> 接口的 <strong><code>ExecutorService</code> 接口。<code>ThreadPoolExecutor</code></strong> 和 <strong><code>ScheduledThreadPoolExecutor</code></strong> 这两个关键类实现了 <strong>ExecutorService 接口</strong>。</p><h3 id="4-使用-FutureTask"><a href="#4-使用-FutureTask" class="headerlink" title="4.使用 FutureTask"></a>4.使用 FutureTask</h3>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发基础常见面试题总结</title>
      <link href="/posts/aeb54382/"/>
      <url>/posts/aeb54382/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/%E4%BA%8C%20%20Synchronized%20%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%E3%80%81%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E3%80%81JDK1.6%20%E4%B9%8B%E5%90%8E%E7%9A%84%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96%E4%BB%A5%E5%8F%8A%20%E5%92%8CReenTrantLock%20%E7%9A%84%E5%AF%B9%E6%AF%94.png" alt="Synchronized 关键字使用、底层原理、JDK1.6 之后的底层优化以及 和ReenTrantLock 的对比"></p><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><h3 id="synchronized关键字最主要的三种使用方式的总结"><a href="#synchronized关键字最主要的三种使用方式的总结" class="headerlink" title="synchronized关键字最主要的三种使用方式的总结"></a>synchronized关键字最主要的三种使用方式的总结</h3><ul><li><strong>修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</strong></li><li><strong>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</strong> 。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li><li><strong>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。</strong> 和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能！</li></ul><p>下面我已一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。</p><p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p><p><strong>双重校验锁实现对象单例（线程安全）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。</p><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><p>###synchronized 关键字底层原理总结</p><p><strong>synchronized 关键字底层原理属于 JVM 层面。</strong></p><p><strong>① synchronized 同步语句块的情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"synchronized 代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 <code>javac SynchronizedDemo.java</code> 命令生成编译后的 .class 文件，然后执行<code>javap -c -s -v -l SynchronizedDemo.class</code>。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://images.gitbook.cn/abc37c80-d21d-11e8-aab3-09d30029e0d5" alt="synchronized 关键字原理"></p><p>从上面我们可以看出：</p><p><strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权.当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><p><strong>② synchronized 修饰方法的的情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"synchronized 方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://images.gitbook.cn/7d407bf0-d21e-11e8-b2d6-1188c7e0dd7e" alt="synchronized 关键字原理"></p><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p>在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><h3 id="JDK1-6-之后的底层优化"><a href="#JDK1-6-之后的底层优化" class="headerlink" title="JDK1.6 之后的底层优化"></a>JDK1.6 之后的底层优化</h3><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p><p>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><p><strong>①偏向锁</strong></p><p><strong>引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉</strong>。</p><p>偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！关于偏向锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。</p><p>但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p><p><strong>② 轻量级锁</strong></p><p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。<strong>轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作。</strong> 关于轻量级锁的加锁和解锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。</p><p><strong>轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！</strong></p><p><strong>③  自旋锁和自适应自旋</strong></p><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</p><p>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。</p><p><strong>一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。</strong> 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。<strong>为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋</strong>。</p><p>百度百科对自旋锁的解释：</p><blockquote><p>何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</p></blockquote><p>自旋锁在 JDK1.6 之前其实就已经引入了，不过是默认关闭的，需要通过<code>--XX:+UseSpinning</code>参数来开启。JDK1.6及1.6之后，就改为默认开启的了。需要注意的是：自旋等待不能完全替代阻塞，因为它还是要占用处理器时间。如果锁被占用的时间短，那么效果当然就很好了！反之，相反！自旋等待的时间必须要有限度。如果自旋超过了限定次数任然没有获得锁，就应该挂起线程。<strong>自旋次数的默认值是10次，用户可以修改<code>--XX:PreBlockSpin</code>来更改</strong>。</p><p>另外,<strong>在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了</strong>。</p><p><strong>④ 锁消除</strong></p><p>锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。</p><p><strong>⑤ 锁粗化</strong></p><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，——直在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。</p><p>大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。</p><h3 id="Synchronized-和-ReenTrantLock-的对比"><a href="#Synchronized-和-ReenTrantLock-的对比" class="headerlink" title="Synchronized 和 ReenTrantLock 的对比"></a>Synchronized 和 ReenTrantLock 的对比</h3><p><strong>① 两者都是可重入锁</strong></p><p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p><p><strong>② synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API</strong></p><p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><p><strong>③ ReenTrantLock 比 synchronized 增加了一些高级功能</strong></p><p>相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</strong></p><ul><li><strong>ReenTrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li><li>synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li></ul><p>如果你想使用上述功能，那么选择ReenTrantLock是一个不错的选择。</p><p><strong>④ 性能已不是选择标准</strong></p><p>在JDK1.6之前，synchronized 的性能是比 ReenTrantLock 差很多。具体表示为：synchronized 关键字吞吐量随线程数的增加，下降得非常严重。而ReenTrantLock 基本保持一个比较稳定的水平。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。<strong>JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReenTrantLock 的文章都是错的！JDK1.6之后，性能已经不是选择synchronized和ReenTrantLock的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的synchronized，所以还是提倡在synchronized能满足你的需求的情况下，优先考虑使用synchronized关键字来进行同步！优化后的synchronized和ReenTrantLock一样，在很多地方都是用到了CAS操作</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发容器总结</title>
      <link href="/posts/242838a2/"/>
      <url>/posts/242838a2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><p>点击关注<a href="#公众号" title="公众号">公众号</a>及时获取笔主最新更新文章，并可免费领取本文档配套的《Java 面试突击》以及 Java 工程师必备学习资源。</p><h2 id="一-JDK-提供的并发容器总结"><a href="#一-JDK-提供的并发容器总结" class="headerlink" title="一 JDK 提供的并发容器总结"></a>一 JDK 提供的并发容器总结</h2><p>JDK 提供的这些容器大部分在 <code>java.util.concurrent</code> 包中。</p><ul><li><strong>ConcurrentHashMap:</strong> 线程安全的 HashMap</li><li><strong>CopyOnWriteArrayList:</strong> 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector.</li><li><strong>ConcurrentLinkedQueue:</strong> 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。</li><li><strong>BlockingQueue:</strong> 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</li><li><strong>ConcurrentSkipListMap:</strong> 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。</li></ul><h2 id="二-ConcurrentHashMap"><a href="#二-ConcurrentHashMap" class="headerlink" title="二 ConcurrentHashMap"></a>二 ConcurrentHashMap</h2><p>我们知道 HashMap 不是线程安全的，在并发场景下如果要保证一种可行的方式是使用 <code>Collections.synchronizedMap()</code> 方法来包装我们的 HashMap。但这是通过使用一个全局的锁来同步不同线程间的并发访问，因此会带来不可忽视的性能问题。</p><p>所以就有了 HashMap 的线程安全版本—— ConcurrentHashMap 的诞生。在 ConcurrentHashMap 中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。</p><p>关于 ConcurrentHashMap 相关问题，我在 <a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.md" target="_blank" rel="noopener" title="Java集合框架常见面试题">Java 集合框架常见面试题</a> 这篇文章中已经提到过。下面梳理一下关于 ConcurrentHashMap 比较重要的问题：</p><ul><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.md#concurrenthashmap-%E5%92%8C-hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener" title="ConcurrentHashMap 和 Hashtable 的区别">ConcurrentHashMap 和 Hashtable 的区别</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.md#concurrenthashmap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%BA%95%E5%B1%82%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener" title="ConcurrentHashMap线程安全的具体实现方式/底层具体实现">ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</a></li></ul><h2 id="三-CopyOnWriteArrayList"><a href="#三-CopyOnWriteArrayList" class="headerlink" title="三 CopyOnWriteArrayList"></a>三 CopyOnWriteArrayList</h2><h3 id="3-1-CopyOnWriteArrayList-简介"><a href="#3-1-CopyOnWriteArrayList-简介" class="headerlink" title="3.1 CopyOnWriteArrayList 简介"></a>3.1 CopyOnWriteArrayList 简介</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>在很多应用场景中，读操作可能会远远大于写操作。由于读操作根本不会修改原有的数据，因此对于每次读取都进行加锁其实是一种资源浪费。我们应该允许多个线程同时访问 List 的内部数据，毕竟读取操作是安全的。</p><p>这和我们之前在多线程章节讲过 <code>ReentrantReadWriteLock</code> 读写锁的思想非常类似，也就是读读共享、写写互斥、读写互斥、写读互斥。JDK 中提供了 <code>CopyOnWriteArrayList</code> 类比相比于在读写锁的思想又更进一步。为了将读取的性能发挥到极致，<code>CopyOnWriteArrayList</code> 读取是完全不用加锁的，并且更厉害的是：写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。这样一来，读操作的性能就会大幅度提升。<strong>那它是怎么做的呢？</strong></p><h3 id="3-2-CopyOnWriteArrayList-是如何做到的？"><a href="#3-2-CopyOnWriteArrayList-是如何做到的？" class="headerlink" title="3.2 CopyOnWriteArrayList 是如何做到的？"></a>3.2 CopyOnWriteArrayList 是如何做到的？</h3><p><code>CopyOnWriteArrayList</code> 类的所有可变操作（add，set 等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。</p><p>从 <code>CopyOnWriteArrayList</code> 的名字就能看出<code>CopyOnWriteArrayList</code> 是满足<code>CopyOnWrite</code> 的 ArrayList，所谓<code>CopyOnWrite</code> 也就是说：在计算机，如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后呢，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了。</p><h3 id="3-3-CopyOnWriteArrayList-读取和写入源码简单分析"><a href="#3-3-CopyOnWriteArrayList-读取和写入源码简单分析" class="headerlink" title="3.3 CopyOnWriteArrayList 读取和写入源码简单分析"></a>3.3 CopyOnWriteArrayList 读取和写入源码简单分析</h3><h4 id="3-3-1-CopyOnWriteArrayList-读取操作的实现"><a href="#3-3-1-CopyOnWriteArrayList-读取操作的实现" class="headerlink" title="3.3.1 CopyOnWriteArrayList 读取操作的实现"></a>3.3.1 CopyOnWriteArrayList 读取操作的实现</h4><p>读取操作没有任何同步控制和锁操作，理由就是内部数组 array 不会发生修改，只会被另外一个 array 替换，因此可以保证数据安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-CopyOnWriteArrayList-写入操作的实现"><a href="#3-3-2-CopyOnWriteArrayList-写入操作的实现" class="headerlink" title="3.3.2 CopyOnWriteArrayList 写入操作的实现"></a>3.3.2 CopyOnWriteArrayList 写入操作的实现</h4><p>CopyOnWriteArrayList 写入操作 add() 方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();<span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);<span class="comment">//拷贝新数组</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-ConcurrentLinkedQueue"><a href="#四-ConcurrentLinkedQueue" class="headerlink" title="四 ConcurrentLinkedQueue"></a>四 ConcurrentLinkedQueue</h2><p>Java 提供的线程安全的 Queue 可以分为<strong>阻塞队列</strong>和<strong>非阻塞队列</strong>，其中阻塞队列的典型例子是 BlockingQueue，非阻塞队列的典型例子是 ConcurrentLinkedQueue，在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列。 <strong>阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。</strong></p><p>从名字可以看出，<code>ConcurrentLinkedQueue</code>这个队列使用链表作为其数据结构．ConcurrentLinkedQueue 应该算是在高并发环境中性能最好的队列了。它之所有能有很好的性能，是因为其内部复杂的实现。</p><p>ConcurrentLinkedQueue 内部代码我们就不分析了，大家知道 ConcurrentLinkedQueue 主要使用 CAS 非阻塞算法来实现线程安全就好了。</p><p>ConcurrentLinkedQueue 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的 ConcurrentLinkedQueue 来替代。</p><h2 id="五-BlockingQueue"><a href="#五-BlockingQueue" class="headerlink" title="五 BlockingQueue"></a>五 BlockingQueue</h2><h3 id="5-1-BlockingQueue-简单介绍"><a href="#5-1-BlockingQueue-简单介绍" class="headerlink" title="5.1 BlockingQueue 简单介绍"></a>5.1 BlockingQueue 简单介绍</h3><p>上面我们己经提到了 ConcurrentLinkedQueue 作为高性能的非阻塞队列。下面我们要讲到的是阻塞队列——BlockingQueue。阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p><p>BlockingQueue 是一个接口，继承自 Queue，所以其实现类也可以作为 Queue 的实现来使用，而 Queue 又继承自 Collection 接口。下面是 BlockingQueue 的相关实现类：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-9/51622268.jpg" alt="BlockingQueue 的实现类"></p><p><strong>下面主要介绍一下:ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue，这三个 BlockingQueue 的实现类。</strong></p><h3 id="5-2-ArrayBlockingQueue"><a href="#5-2-ArrayBlockingQueue" class="headerlink" title="5.2 ArrayBlockingQueue"></a>5.2 ArrayBlockingQueue</h3><p><strong>ArrayBlockingQueue</strong> 是 BlockingQueue 接口的有界队列实现类，底层采用<strong>数组</strong>来实现。ArrayBlockingQueue 一旦创建，容量不能改变。其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。</p><p>ArrayBlockingQueue 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 ArrayBlockingQueue。而非公平性则是指访问 ArrayBlockingQueue 的顺序不是遵守严格的时间顺序，有可能存在，当 ArrayBlockingQueue 可以被访问时，长时间阻塞的线程依然无法访问到 ArrayBlockingQueue。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的 ArrayBlockingQueue，可采用如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">10</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h3 id="5-3-LinkedBlockingQueue"><a href="#5-3-LinkedBlockingQueue" class="headerlink" title="5.3 LinkedBlockingQueue"></a>5.3 LinkedBlockingQueue</h3><p><strong>LinkedBlockingQueue</strong> 底层基于<strong>单向链表</strong>实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性，与 ArrayBlockingQueue 相比起来具有更高的吞吐量，为了防止 LinkedBlockingQueue 容量迅速增，损耗大量内存。通常在创建 LinkedBlockingQueue 对象时，会指定其大小，如果未指定，容量等于 Integer.MAX_VALUE。</p><p><strong>相关构造方法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *某种意义上的无界队列</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> LinkedBlockingQueue&#125; with a capacity of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Integer#MAX_VALUE&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *有界队列</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> LinkedBlockingQueue&#125; with the given (fixed) capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity the capacity of this queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> capacity&#125; is not greater</span></span><br><span class="line"><span class="comment"> *         than zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-PriorityBlockingQueue"><a href="#5-4-PriorityBlockingQueue" class="headerlink" title="5.4 PriorityBlockingQueue"></a>5.4 PriorityBlockingQueue</h3><p><strong>PriorityBlockingQueue</strong> 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 <code>compareTo()</code> 方法来指定元素排序规则，或者初始化时通过构造器参数 <code>Comparator</code> 来指定排序规则。</p><p>PriorityBlockingQueue 并发控制采用的是 <strong>ReentrantLock</strong>，队列为无界队列（ArrayBlockingQueue 是有界队列，LinkedBlockingQueue 也可以通过在构造函数中传入 capacity 指定队列最大的容量，但是 PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，<strong>如果空间不够的话会自动扩容</strong>）。</p><p>简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。</p><p><strong>推荐文章：</strong></p><p>《解读 Java 并发队列 BlockingQueue》</p><p><a href="https://javadoop.com/post/java-concurrent-queue" target="_blank" rel="noopener" title="https://javadoop.com/post/java-concurrent-queue">https://javadoop.com/post/java-concurrent-queue</a></p><h2 id="六-ConcurrentSkipListMap"><a href="#六-ConcurrentSkipListMap" class="headerlink" title="六 ConcurrentSkipListMap"></a>六 ConcurrentSkipListMap</h2><p>下面这部分内容参考了极客时间专栏<a href="https://time.geekbang.org/column/intro/126?code=zl3GYeAsRI4rEJIBNu5B/km7LSZsPDlGWQEpAYw5Vu0=&utm_term=SPoster" target="_blank" rel="noopener" title="《数据结构与算法之美》">《数据结构与算法之美》</a>以及《实战 Java 高并发程序设计》。</p><p><strong>为了引出 ConcurrentSkipListMap，先带着大家简单理解一下跳表。</strong></p><p>对于一个单链表，即使链表是有序的，如果我们想要在其中查找某个数据，也只能从头到尾遍历链表，这样效率自然就会很低，跳表就不一样了。跳表是一种可以用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可。这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。而对于跳表，你只需要部分锁即可。这样，在高并发环境下，你就可以拥有更好的性能。而就查询的性能而言，跳表的时间复杂度也是 <strong>O(logn)</strong> 所以在并发数据结构中，JDK 使用跳表来实现一个 Map。</p><p>跳表的本质是同时维护了多个链表，并且链表是分层的，</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-9/93666217.jpg" alt="2级索引跳表"></p><p>最低层的链表维护了跳表内所有的元素，每上面一层链表都是下面一层的子集。</p><p>跳表内的所有链表的元素都是排序的。查找时，可以从顶级链表开始找。一旦发现被查找的元素大于当前链表中的取值，就会转入下一层链表继续找。这也就是说在查找过程中，搜索是跳跃式的。如上图所示，在跳表中查找元素 18。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-9/32005738.jpg" alt="在跳表中查找元素18"></p><p>查找 18 的时候原来需要遍历 18 次，现在只需要 7 次即可。针对链表长度比较大的时候，构建索引查找效率的提升就会非常明显。</p><p>从上面很容易看出，<strong>跳表是一种利用空间换时间的算法。</strong></p><p>使用跳表实现 Map 和使用哈希算法实现 Map 的另外一个不同之处是：哈希并不会保存元素的顺序，而跳表内所有的元素都是排序的。因此在对跳表进行遍历时，你会得到一个有序的结果。所以，如果你的应用需要有序性，那么跳表就是你不二的选择。JDK 中实现这一数据结构的类是 ConcurrentSkipListMap。</p><h2 id="七-参考"><a href="#七-参考" class="headerlink" title="七 参考"></a>七 参考</h2><ul><li>《实战 Java 高并发程序设计》</li><li><a href="https://javadoop.com/post/java-concurrent-queue" target="_blank" rel="noopener">https://javadoop.com/post/java-concurrent-queue</a></li><li><a href="https://juejin.im/post/5aeebd02518825672f19c546" target="_blank" rel="noopener">https://juejin.im/post/5aeebd02518825672f19c546</a></li></ul><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p><p><strong>《Java 面试突击》:</strong> 由本文档衍生的专为面试而生的《Java 面试突击》V2.0 PDF 版本<a href="#公众号" title="公众号">公众号</a>后台回复 <strong>“面试突击”</strong> 即可免费领取！</p><p><strong>Java 工程师必备学习资源:</strong> 一些 Java 工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/qrcode_for_gh_ea338256af79_258.jpg" alt="我的公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList-Grow</title>
      <link href="/posts/d3b5b646/"/>
      <url>/posts/d3b5b646/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><h2 id="一-先从-ArrayList-的构造函数说起"><a href="#一-先从-ArrayList-的构造函数说起" class="headerlink" title="一 先从 ArrayList 的构造函数说起"></a>一 先从 ArrayList 的构造函数说起</h2><p><strong>ArrayList有三种方式来初始化，构造方法源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 默认初始容量大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">         <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">         <span class="comment">//创建空数组</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment"> *如果指定的集合为null，throws NullPointerException。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">     elementData = c.toArray();</span><br><span class="line">     <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">         <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">             <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// replace with empty array.</span></span><br><span class="line">         <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>细心的同学一定会发现 ：<strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。</strong> 下面在我们分析 ArrayList 扩容时会讲到这一点内容！</p><h2 id="二-一步一步分析-ArrayList-扩容机制"><a href="#二-一步一步分析-ArrayList-扩容机制" class="headerlink" title="二 一步一步分析 ArrayList 扩容机制"></a>二 一步一步分析 ArrayList 扩容机制</h2><p>这里以无参构造函数创建的 ArrayList 为例分析</p><h3 id="1-先来看-add-方法"><a href="#1-先来看-add-方法" class="headerlink" title="1. 先来看 add 方法"></a>1. 先来看 <code>add</code> 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将指定的元素追加到此列表的末尾。 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">     ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">     <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">     elementData[size++] = e;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="2-再来看看-ensureCapacityInternal-方法"><a href="#2-再来看看-ensureCapacityInternal-方法" class="headerlink" title="2. 再来看看 ensureCapacityInternal() 方法"></a>2. 再来看看 <code>ensureCapacityInternal()</code> 方法</h3><p>可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ensureExplicitCapacity(minCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>当 要 add 进第1个元素时，minCapacity为1，在Math.max()方法比较后，minCapacity 为10。</strong></p><h3 id="3-ensureExplicitCapacity-方法"><a href="#3-ensureExplicitCapacity-方法" class="headerlink" title="3. ensureExplicitCapacity() 方法"></a>3. <code>ensureExplicitCapacity()</code> 方法</h3><p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进过（执行）这个方法，下面我们来研究一下这个方法的源码！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      modCount++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">          <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">          grow(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们来仔细分析一下：</p><ul><li>当我们要 add 进第1个元素到 ArrayList 时，elementData.length 为0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li><li>当add第2个元素时，minCapacity 为2，此时e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li><li>添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。</li></ul><p>直到添加第11个元素，minCapacity(为11)比elementData.length（为10）要大。进入grow方法进行扩容。</p><h3 id="4-grow-方法"><a href="#4-grow-方法" class="headerlink" title="4. grow() 方法"></a>4. <code>grow()</code> 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">   <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">   <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity为偶数就是1.5倍，否则是1.5倍左右）！</strong>  奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p><blockquote><p>  “&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源 　</p></blockquote><p><strong>我们再来通过例子探究一下<code>grow()</code> 方法 ：</strong></p><ul><li>当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为10，add方法中 return true,size增为1。</li><li>当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true,size增为11。</li><li>以此类推······</li></ul><p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p><ul><li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li><li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li><li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li></ul><h3 id="5-hugeCapacity-方法。"><a href="#5-hugeCapacity-方法。" class="headerlink" title="5. hugeCapacity() 方法。"></a>5. <code>hugeCapacity()</code> 方法。</h3><p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">    <span class="comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-System-arraycopy-和-Arrays-copyOf-方法"><a href="#三-System-arraycopy-和-Arrays-copyOf-方法" class="headerlink" title="三 System.arraycopy() 和 Arrays.copyOf()方法"></a>三 <code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法</h2><p>阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p><h3 id="3-1-System-arraycopy-方法"><a href="#3-1-System-arraycopy-方法" class="headerlink" title="3.1 System.arraycopy() 方法"></a>3.1 <code>System.arraycopy()</code> 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在此列表中的指定位置插入指定的元素。 </span></span><br><span class="line"><span class="comment"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">    <span class="comment">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们写一个简单的方法测试以下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraycopyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">a[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">System.arraycopy(a, <span class="number">2</span>, a, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">a[<span class="number">2</span>]=<span class="number">99</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">System.out.println(a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 99 2 3 0 0 0 0 0</span><br></pre></td></tr></table></figure><h3 id="3-2-Arrays-copyOf-方法"><a href="#3-2-Arrays-copyOf-方法" class="headerlink" title="3.2 Arrays.copyOf()方法"></a>3.2 <code>Arrays.copyOf()</code>方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line"> <span class="comment">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class="line">     <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容，测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayscopyOfTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[] b = Arrays.copyOf(a, <span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">"b.length"</span>+b.length);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="3-3-两者联系和区别"><a href="#3-3-两者联系和区别" class="headerlink" title="3.3 两者联系和区别"></a>3.3 两者联系和区别</h3><p><strong>联系：</strong> </p><p>看两者源代码可以发现 copyOf() 内部实际调用了 <code>System.arraycopy()</code> 方法 </p><p><strong>区别：</strong></p><p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p><h2 id="四-ensureCapacity方法"><a href="#四-ensureCapacity方法" class="headerlink" title="四 ensureCapacity方法"></a>四 <code>ensureCapacity</code>方法</h2><p>ArrayList 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if not default element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for default empty table. It's already</span></span><br><span class="line">        <span class="comment">// supposed to be at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</strong></p><p>我们通过下面的代码实际测试以下这个方法的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnsureCapacityTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">list.add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"使用ensureCapacity方法前："</span>+(endTime - startTime));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用ensureCapacity方法前：2158</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnsureCapacityTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10000000</span>;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">long</span> startTime1 = System.currentTimeMillis();</span><br><span class="line">        list.ensureCapacity(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime1 = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"使用ensureCapacity方法后："</span>+(endTime1 - startTime1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用ensureCapacity方法前：1773</span><br></pre></td></tr></table></figure><p>通过运行结果，我们可以看出向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数。</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> collection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList</title>
      <link href="/posts/f53fbd0d/"/>
      <url>/posts/f53fbd0d/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><h3 id="ArrayList简介"><a href="#ArrayList简介" class="headerlink" title="ArrayList简介"></a>ArrayList简介</h3><p>　　ArrayList 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。</p><p>   它继承于 <strong>AbstractList</strong>，实现了 <strong>List</strong>, <strong>RandomAccess</strong>, <strong>Cloneable</strong>, <strong>java.io.Serializable</strong> 这些接口。</p><p>   在我们学数据结构的时候就知道了线性表的顺序存储，插入删除元素的时间复杂度为<strong>O（n）</strong>,求表长以及增加元素，取第 i   元素的时间复杂度为<strong>O（1）</strong></p><p>　  ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</p><p>　　ArrayList 实现了<strong>RandomAccess 接口</strong>， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</p><p>　　ArrayList 实现了<strong>Cloneable 接口</strong>，即覆盖了函数 clone()，<strong>能被克隆</strong>。</p><p>　　ArrayList 实现<strong>java.io.Serializable 接口</strong>，这意味着ArrayList<strong>支持序列化</strong>，<strong>能通过序列化去传输</strong>。</p><p>　　和 Vector 不同，<strong>ArrayList 中的操作不是线程安全的</strong>！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者  CopyOnWriteArrayList。</p><h3 id="ArrayList核心源码"><a href="#ArrayList核心源码" class="headerlink" title="ArrayList核心源码"></a>ArrayList核心源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.UnaryOperator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空数组（用于空实例）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//用于默认大小空实例的共享空数组实例。</span></span><br><span class="line">      <span class="comment">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存ArrayList数据的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList 所包含的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//创建空数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认构造函数，DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">//如果指定集合元素个数不为0</span></span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray 可能返回的不是Object类型的数组所以加上下面的语句用于判断，</span></span><br><span class="line">            <span class="comment">//这里用到了反射里面的getClass()方法</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 用空数组代替</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData = (size == <span class="number">0</span>)</span><br><span class="line">              ? EMPTY_ELEMENTDATA</span><br><span class="line">              : Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//下面是ArrayList的扩容机制</span></span><br><span class="line"><span class="comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class="line"><span class="comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="comment">// any size if not default element table</span></span><br><span class="line">            ? <span class="number">0</span></span><br><span class="line">            <span class="comment">// larger than default for default empty table. It's already</span></span><br><span class="line">            <span class="comment">// supposed to be at default size.</span></span><br><span class="line">            : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//得到最小扩容量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">              <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">        <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class="line">        <span class="comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class="line">        <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较minCapacity和 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回此列表中的元素数。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表不包含元素，则返回 true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意=和==的区别</span></span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 </span></span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="comment">//equals()方法比较</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。） </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">            <span class="comment">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span></span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// 这不应该发生，因为我们是可以克隆的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 </span></span><br><span class="line"><span class="comment">     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class="line"><span class="comment">     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; </span></span><br><span class="line"><span class="comment">     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。 </span></span><br><span class="line"><span class="comment">     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。 </span></span><br><span class="line"><span class="comment">     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span></span><br><span class="line"><span class="comment">     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。） </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            <span class="comment">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span></span><br><span class="line">            <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">            <span class="comment">//调用System提供的arraycopy()方法实现数组之间的复制</span></span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Positional Access Operations</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用指定的元素替换此列表中指定位置的元素。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对index进行界限检查</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="comment">//返回原来在这个位置的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定的元素追加到此列表的末尾。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在此列表中的指定位置插入指定的元素。 </span></span><br><span class="line"><span class="comment">     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment">     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">      <span class="comment">//从列表中删除的元素 </span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span></span><br><span class="line"><span class="comment">     *返回true，如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment">     * return the value removed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除所有元素。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把数组中所有的元素的值设为null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                             numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span></span><br><span class="line"><span class="comment">     *将任何后续元素移动到左侧（减少其索引）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查给定的索引是否在范围内。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * add和addAll使用的rangeCheck的一个版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回IndexOutOfBoundsException细节信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除指定集合中包含的所有元素。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="comment">//如果此列表被修改则返回true</span></span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅保留此列表中包含在指定集合中的元素。</span></span><br><span class="line"><span class="comment">     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span></span><br><span class="line"><span class="comment">     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。 </span></span><br><span class="line"><span class="comment">     *返回的列表迭代器是fail-fast 。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回列表中的列表迭代器（按适当的顺序）。 </span></span><br><span class="line"><span class="comment">     *返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *以正确的顺序返回该列表中的元素的迭代器。 </span></span><br><span class="line"><span class="comment">     *返回的迭代器是fail-fast 。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a><font face="楷体" id="1" id="5">ArrayList源码分析</font></h3><h4 id="System-arraycopy-和Arrays-copyOf-方法"><a href="#System-arraycopy-和Arrays-copyOf-方法" class="headerlink" title="System.arraycopy()和Arrays.copyOf()方法"></a>System.arraycopy()和Arrays.copyOf()方法</h4><p>　　通过上面源码我们发现这两个实现数组复制的方法被广泛使用而且很多地方都特别巧妙。比如下面<font color="red">add(int index, E element)</font>方法就很巧妙的用到了<font color="red">arraycopy()方法</font>让数组自己复制自己实现让index开始之后的所有成员后移一个位置:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在此列表中的指定位置插入指定的元素。 </span></span><br><span class="line"><span class="comment"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">    <span class="comment">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又如toArray()方法中用到了copyOf()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 </span></span><br><span class="line"><span class="comment"> *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class="line"><span class="comment"> *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line"><span class="comment">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="两者联系与区别"><a href="#两者联系与区别" class="headerlink" title="两者联系与区别"></a>两者联系与区别</h5><p><strong>联系：</strong><br>看两者源代码可以发现<code>copyOf()</code>内部调用了<code>System.arraycopy()</code>方法<br><strong>区别：</strong></p><ol><li>arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</li><li>copyOf()是系统自动在内部新建一个数组，并返回该数组。<h4 id="ArrayList-核心扩容技术"><a href="#ArrayList-核心扩容技术" class="headerlink" title="ArrayList 核心扩容技术"></a>ArrayList 核心扩容技术</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是ArrayList的扩容机制</span></span><br><span class="line"><span class="comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class="line"><span class="comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="comment">// any size if not default element table</span></span><br><span class="line">            ? <span class="number">0</span></span><br><span class="line">            <span class="comment">// larger than default for default empty table. It's already</span></span><br><span class="line">            <span class="comment">// supposed to be at default size.</span></span><br><span class="line">            : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//得到最小扩容量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">              <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//判断是否需要扩容,上面两个方法都要调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果说minCapacity也就是所需的最小容量大于保存ArrayList数据的数组的长度的话，就需要调用grow(minCapacity)方法扩容。</span></span><br><span class="line">        <span class="comment">//这个minCapacity到底为多少呢？举个例子在添加元素(add)方法中这个minCapacity的大小就为现在数组的长度加1</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//elementData为保存ArrayList数据的数组</span></span><br><span class="line">   <span class="comment">///elementData.length求数组长度elementData.size是求数组中的元素个数</span></span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class="line">    <span class="comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class="line">    <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>　　扩容机制代码已经做了详细的解释。另外值得注意的是大家很容易忽略的一个运算符：<strong>移位运算符</strong><br>　　<strong>简介</strong>：移位运算符就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种:<font color="red">&lt;&lt;(左移)</font>、<font color="red">&gt;&gt;(带符号右移)</font>和<font color="red">&gt;&gt;&gt;(无符号右移)</font>。<br>　　<strong>作用</strong>：<strong>对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</strong><br>　　比如这里：int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);<br>右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。</li></ol><p><strong>另外需要注意的是：</strong></p><ol><li><p>java 中的<strong>length 属性</strong>是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</p></li><li><p>java 中的<strong>length()方法</strong>是针对字  符串String说的,如果想看这个字符串的长度则用到 length()这个方法.</p></li><li><p>.java 中的<strong>size()方法</strong>是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</p></li></ol><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;  </span></span><br><span class="line"><span class="class">(2)<span class="title">private</span> <span class="title">class</span> <span class="title">ListItr</span> <span class="keyword">extends</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt;  </span></span><br><span class="line"><span class="class">(3)<span class="title">private</span> <span class="title">class</span> <span class="title">SubList</span> <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span>  </span></span><br><span class="line"><span class="class">(4)<span class="title">static</span> <span class="title">final</span> <span class="title">class</span> <span class="title">ArrayListSpliterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>　　ArrayList有四个内部类，其中的<strong>Itr是实现了Iterator接口</strong>，同时重写了里面的<strong>hasNext()</strong>， <strong>next()</strong>， <strong>remove()</strong> 等方法；其中的<strong>ListItr</strong> 继承 <strong>Itr</strong>，实现了<strong>ListIterator接口</strong>，同时重写了<strong>hasPrevious()</strong>， <strong>nextIndex()</strong>， <strong>previousIndex()</strong>， <strong>previous()</strong>， <strong>set(E e)</strong>， <strong>add(E e)</strong> 等方法，所以这也可以看出了 <strong>Iterator和ListIterator的区别:</strong> ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。</p><h3 id="ArrayList经典Demo"><a href="#ArrayList经典Demo" class="headerlink" title=" ArrayList经典Demo"></a><font face="楷体" id="6"> ArrayList经典Demo</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> list;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] srgs)</span></span>&#123;</span><br><span class="line">         ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">         System.out.printf(<span class="string">"Before add:arrayList.size() = %d\n"</span>,arrayList.size());</span><br><span class="line"></span><br><span class="line">         arrayList.add(<span class="number">1</span>);</span><br><span class="line">         arrayList.add(<span class="number">3</span>);</span><br><span class="line">         arrayList.add(<span class="number">5</span>);</span><br><span class="line">         arrayList.add(<span class="number">7</span>);</span><br><span class="line">         arrayList.add(<span class="number">9</span>);</span><br><span class="line">         System.out.printf(<span class="string">"After add:arrayList.size() = %d\n"</span>,arrayList.size());</span><br><span class="line"></span><br><span class="line">         System.out.println(<span class="string">"Printing elements of arrayList"</span>);</span><br><span class="line">         <span class="comment">// 三种遍历方式打印元素</span></span><br><span class="line">         <span class="comment">// 第一种：通过迭代器遍历</span></span><br><span class="line">         System.out.print(<span class="string">"通过迭代器遍历:"</span>);</span><br><span class="line">         Iterator&lt;Integer&gt; it = arrayList.iterator();</span><br><span class="line">         <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">             System.out.print(it.next() + <span class="string">" "</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 第二种：通过索引值遍历</span></span><br><span class="line">         System.out.print(<span class="string">"通过索引值遍历:"</span>);</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.size(); i++)&#123;</span><br><span class="line">             System.out.print(arrayList.get(i) + <span class="string">" "</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 第三种：for循环遍历</span></span><br><span class="line">         System.out.print(<span class="string">"for循环遍历:"</span>);</span><br><span class="line">         <span class="keyword">for</span>(Integer number : arrayList)&#123;</span><br><span class="line">             System.out.print(number + <span class="string">" "</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// toArray用法</span></span><br><span class="line">         <span class="comment">// 第一种方式(最常用)</span></span><br><span class="line">         Integer[] integer = arrayList.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 第二种方式(容易理解)</span></span><br><span class="line">         Integer[] integer1 = <span class="keyword">new</span> Integer[arrayList.size()];</span><br><span class="line">         arrayList.toArray(integer1);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 抛出异常，java不支持向下转型</span></span><br><span class="line">         <span class="comment">//Integer[] integer2 = new Integer[arrayList.size()];</span></span><br><span class="line">         <span class="comment">//integer2 = arrayList.toArray();</span></span><br><span class="line">         System.out.println();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 在指定位置添加元素</span></span><br><span class="line">         arrayList.add(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">         <span class="comment">// 删除指定位置上的元素</span></span><br><span class="line">         arrayList.remove(<span class="number">2</span>);    </span><br><span class="line">         <span class="comment">// 删除指定元素</span></span><br><span class="line">         arrayList.remove((Object)<span class="number">3</span>);</span><br><span class="line">         <span class="comment">// 判断arrayList是否包含5</span></span><br><span class="line">         System.out.println(<span class="string">"ArrayList contains 5 is: "</span> + arrayList.contains(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 清空ArrayList</span></span><br><span class="line">         arrayList.clear();</span><br><span class="line">         <span class="comment">// 判断ArrayList是否为空</span></span><br><span class="line">         System.out.println(<span class="string">"ArrayList is empty: "</span> + arrayList.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> collection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程学习指南</title>
      <link href="/posts/4087a947/"/>
      <url>/posts/4087a947/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是我的第二篇专门介绍如何去学习某个知识点的文章，在上一篇<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486508&idx=1&sn=ce2faafcde166d5412d7166a01fdc1e9&chksm=cea243e7f9d5caf1dbf4d6ccf0438a1731bc0070310bba1ac481d485e4a6756349c20f02a6b1&token=211950660&lang=zh_CN#rd" target="_blank" rel="noopener">《写给 Java 程序员看的算法学习指南！》</a> 的文章中，我推荐了一些关于 <strong>算法学习的书籍以及资源</strong> 。</p><p>相比于写技术文章来说，写这种这种类型的文章实际花费的时间可能会稍微少一点。但是，这种学习指南形式的文章，我想对于 Java 初学者甚至是工作几年的 Java 工程师来说应该还是非常有帮助的！</p><p>我们都知道多线程应该是大部分 Java 程序员最难啃的一块骨头之一，这部分内容的难度跨度大，难实践，并且市面上的参考资料的质量也层次不齐。</p><p>在这篇文章中，我会首先介绍一下 <strong>Java 多线程学习</strong> 中比较重要的一些问题，然后还会推荐一些比较不错的学习资源供大家参考。希望对你们学习多线程相关的知识能有帮助。以下介绍的很多知识点你都可以在这里找到：<a href="https://snailclimb.gitee.io/javaguide/#/?id=并发" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/?id=并发</a></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://imgkr.cn-bj.ufileos.com/49f0b564-224d-43d8-813e-0fe53196c1a9.png" alt=""></p><p><strong>另外，我还将本文的内容同步到了 Github 上，点击阅读原文即可直达。如果你觉得有任何需要完善和修改的地方，都可以去 Github 给我提交 Issue 或者 PR（推荐）。</strong></p><h2 id="一-Java-多线程知识点总结"><a href="#一-Java-多线程知识点总结" class="headerlink" title="一.Java 多线程知识点总结"></a>一.Java 多线程知识点总结</h2><h3 id="1-1-多线程基础"><a href="#1-1-多线程基础" class="headerlink" title="1.1.多线程基础"></a>1.1.多线程基础</h3><ol><li>什么是线程和进程? 线程与进程的关系,区别及优缺点？</li><li>说说并发与并行的区别?</li><li>为什么要使用多线程呢?</li><li>使用多线程可能带来什么问题?（内存泄漏、死锁、线程不安全等等）</li><li>创建线程有哪几种方式？（a.继承 Thread 类;b.实现 Runnable 接口;c. 使用 Executor 框架;d.使用 FutureTask）</li><li>说说线程的生命周期和状态?</li><li>什么是上下文切换?</li><li>什么是线程死锁?如何避免死锁?</li><li>说说 sleep() 方法和 wait() 方法区别和共同点?</li><li>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</li><li>……</li></ol><h3 id="1-2-多线程知识进阶"><a href="#1-2-多线程知识进阶" class="headerlink" title="1.2.多线程知识进阶"></a>1.2.多线程知识进阶</h3><h4 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h4><ol><li>Java 内存模型（<strong>JMM</strong>）;</li><li>重排序与 happens-before 原则了解吗?</li><li>volatile 关键字的作用;</li><li>说说 synchronized 关键字和 volatile 关键字的区别;</li><li>……</li></ol><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><ol><li>有啥用（解决了什么问题）？怎么用？</li><li>原理了解吗？</li><li>内存泄露问题了解吗？</li></ol><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><ol><li>为什么要用线程池？</li><li>你会使用线程池吗？</li><li>如何创建线程池比较好？ （推荐使用 <code>ThreadPoolExecutor</code> 构造函数创建线程池）</li><li><code>ThreadPoolExecutor</code> 类的重要参数了解吗？<code>ThreadPoolExecutor</code> 饱和策略了解吗？</li><li>线程池原理了解吗？</li><li>几种常见的线程池了解吗？为什么不推荐使用<code>FixedThreadPool</code>？</li><li>如何设置线程池的大小？</li><li>……</li></ol><h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><ol><li>简介</li><li>原理</li><li>AQS 常用组件。<ul><li><strong>Semaphore(信号量)</strong>-允许多个线程同时访问</li><li><strong>CountDownLatch （倒计时器）</strong>-CountDownLatch 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</li><li><strong>CyclicBarrier(循环栅栏)</strong>-CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。</li><li><strong>ReentrantLock 和 ReentrantReadWriteLock</strong></li><li>……</li></ul></li></ol><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>锁的常见分类</p><ol><li>可重入锁和非可重入锁</li><li>公平锁与非公平锁</li><li>读写锁和排它锁</li></ol><p><strong>synchronized 关键字</strong></p><ol><li>说一说自己对于 synchronized 关键字的了解；</li><li>说说自己是怎么使用 synchronized 关键字，在项目中用到了吗;</li><li>讲一下 synchronized 关键字的底层原理；</li><li>说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗；</li><li>谈谈 synchronized 和 ReentrantLock 的区别；</li><li>……</li></ol><p><strong>ReentrantLock 和 ReentrantReadWriteLock</strong></p><p><strong>ReadWriteLock</strong></p><p><strong>StampedLock（JDK8）</strong></p><h4 id="Atomic-与-CAS"><a href="#Atomic-与-CAS" class="headerlink" title="Atomic 与 CAS"></a><strong>Atomic 与 CAS</strong></h4><p><strong>CAS:</strong></p><ol><li>介绍</li><li>原理</li></ol><p><strong>Atomic 原子类：</strong></p><ol><li>介绍一下 Atomic 原子类；</li><li>JUC 包中的原子类是哪 4 类?；</li><li>讲讲 AtomicInteger 的使用；</li><li>能不能给我简单介绍一下 AtomicInteger 类的原理。</li><li>……</li></ol><h4 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h4><p>JDK 提供的这些容器大部分在 <code>java.util.concurrent</code> 包中。</p><ul><li><strong>ConcurrentHashMap:</strong> 线程安全的 HashMap</li><li><strong>CopyOnWriteArrayList:</strong> 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector.</li><li><strong>ConcurrentLinkedQueue:</strong> 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。</li><li><strong>BlockingQueue:</strong> 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</li><li><strong>ConcurrentSkipListMap:</strong> 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。</li><li>……</li></ul><h4 id="Future-和-CompletableFuture"><a href="#Future-和-CompletableFuture" class="headerlink" title="Future 和 CompletableFuture"></a>Future 和 CompletableFuture</h4><h2 id="二-书籍推荐"><a href="#二-书籍推荐" class="headerlink" title="二.书籍推荐"></a>二.书籍推荐</h2><h4 id="《Java-并发编程之美》"><a href="#《Java-并发编程之美》" class="headerlink" title="《Java 并发编程之美》"></a>《Java 并发编程之美》</h4><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://imgkr.cn-bj.ufileos.com/b4c03ec2-f907-47a4-ad19-731c969a499b.png" alt="《Java 并发编程之美》"></p><p><strong>我觉得这本书还是非常适合我们用来学习 Java 多线程的。这本书的讲解非常通俗易懂，作者从并发编程基础到实战都是信手拈来。</strong></p><p>另外，这本书的作者加多自身也会经常在网上发布各种技术文章。我觉得这本书也是加多大佬这么多年在多线程领域的沉淀所得的结果吧！他书中的内容基本都是结合代码讲解，非常有说服力！</p><h4 id="《实战-Java-高并发程序设计》"><a href="#《实战-Java-高并发程序设计》" class="headerlink" title="《实战 Java 高并发程序设计》"></a>《实战 Java 高并发程序设计》</h4><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://imgkr.cn-bj.ufileos.com/0d6e5484-aea1-41cc-8417-4694c6028012.png" alt="《实战 Java 高并发程序设计》"></p><p>这个是我第二本要推荐的书籍，比较适合作为多线程入门/进阶书籍来看。这本书内容同样是理论结合实战，对于每个知识点的讲解也比较通俗易懂，整体结构也比较清。</p><h4 id="《深入浅出-Java-多线程》"><a href="#《深入浅出-Java-多线程》" class="headerlink" title="《深入浅出 Java 多线程》"></a>《深入浅出 Java 多线程》</h4><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://imgkr.cn-bj.ufileos.com/7001a206-8ac0-432c-bf62-ca7130487c12.png" alt="《深入浅出Java多线程》"></p><p>这本书是几位大厂（如阿里）的大佬开源的，Github 地址：<a href="https://github.com/RedSpider1/concurrent" target="_blank" rel="noopener">https://github.com/RedSpider1/concurrent</a></p><p>几位作者为了写好《深入浅出 Java 多线程》这本书阅读了大量的 Java 多线程方面的书籍和博客，然后再加上他们的经验总结、Demo 实例、源码解析，最终才形成了这本书。</p><p>这本书的质量也是非常过硬！给作者们点个赞！这本书有统一的排版规则和语言风格、清晰的表达方式和逻辑。并且每篇文章初稿写完后，作者们就会互相审校，合并到主分支时所有成员会再次审校，最后再通篇修订了三遍。</p><h4 id="《Java-并发编程的艺术》"><a href="#《Java-并发编程的艺术》" class="headerlink" title="《Java 并发编程的艺术》"></a>《Java 并发编程的艺术》</h4><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://imgkr.cn-bj.ufileos.com/9ff63f79-f537-40df-a111-be5a11747b8f.png" alt="《Java 并发编程的艺术》"></p><p>这本书不是很适合作为 Java 多线程入门书籍，需要具备一定的 JVM 基础，有些东西讲的还是挺深入的。另外，就我自己阅读这本书的感觉来说，我觉得这本书的章节规划有点杂乱，但是，具体到某个知识点又很棒！这可能也和这本书由三名作者共同编写完成有关系吧！</p><p><strong>综上：这本书并不是和 Java 多线程入门，你也不需要把这本书的每一章节都看一遍，建议挑选自己想要详细了解的知识点来看。</strong></p><h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h2><p>在这篇文章中我主要总结了 Java 多线程方面的知识点，并且推荐了相关的书籍。并发这部分东西实战的话比较难，你可以尝试学会了某个知识点之后然后在自己写过的一些项目上实践。另外，leetcode 有一个练习多线程的类别： <a href="https://leetcode-cn.com/problemset/concurrency" target="_blank" rel="noopener">https://leetcode-cn.com/problemset/concurrency</a> 可以作为参考。</p><p><strong>为了这篇文章的内容更加完善，我还将本文的内容同步到了 Github 上，点击阅读原文即可直达。如果你觉得有任何需要完善和修改的地方，都可以去 Github 给我提交 Issue 或者 PR（推荐）。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap</title>
      <link href="/posts/9ed7444c/"/>
      <url>/posts/9ed7444c/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>感谢 <a href="https://github.com/changfubai" target="_blank" rel="noopener">changfubai</a> 对本文的改进做出的贡献！</p></blockquote><h2 id="HashMap-简介"><a href="#HashMap-简介" class="headerlink" title="HashMap 简介"></a>HashMap 简介</h2><p>HashMap 主要用来存放键值对，它基于哈希表的Map接口实现</font>，是常用的Java集合之一。 </p><p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间，具体可以参考 <code>treeifyBin</code>方法。</p><h2 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h2><h3 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h3><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash  值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p><p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p><p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p><p>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/jdk1.8%E4%B9%8B%E5%89%8D%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="jdk1.8之前的内部结构"></p><h3 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h3><p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/67233764.jpg" alt="JDK1.8之后的HashMap底层数据结构"></p><p><strong>类的属性：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;    </span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;   </span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; </span><br><span class="line">    <span class="comment">// 默认的填充因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; </span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table; </span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;   </span><br><span class="line">    <span class="comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// 加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>loadFactor加载因子</strong></p><p>loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么   数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值</strong>。 </p><p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p></li><li><p><strong>threshold</strong></p><p><strong>threshold = capacity * loadFactor</strong>，<strong>当Size&gt;=threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p></li></ul><p><strong>Node节点类源码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承自 Map.Entry&lt;K,V&gt;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span></span><br><span class="line">       <span class="keyword">final</span> K key;<span class="comment">//键</span></span><br><span class="line">       V value;<span class="comment">//值</span></span><br><span class="line">       <span class="comment">// 指向下一个节点</span></span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line">       Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line">        <span class="comment">// 重写hashCode()方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重写 equals() 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>树节点类源码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// 父</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;    <span class="comment">// 左</span></span><br><span class="line">        TreeNode&lt;K,V&gt; right;   <span class="comment">// 右</span></span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;           <span class="comment">// 判断颜色</span></span><br><span class="line">        TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回根节点</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                r = p;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>HashMap 中有四个构造方法，它们分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">     putMapEntries(m, <span class="keyword">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</span><br><span class="line">     <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">     <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>putMapEntries方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p>HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。</p><p><strong>对putVal方法添加元素的分析如下：</strong></p><ul><li>①如果定位到的数组位置没有元素 就直接插入。</li><li>②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li></ul><p>ps:下图有一个小问题，来自 <a href="https://github.com/Snailclimb/JavaGuide/issues/608" target="_blank" rel="noopener">issue#608</a>指出：直接覆盖之后应该就会 return，不会有后续操作。参考 JDK8 HashMap.java 658 行。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/put%E6%96%B9%E6%B3%95.png" alt="put方法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值，转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我们再来对比一下 JDK1.7 put方法的代码</strong></p><p><strong>对于put方法的分析如下：</strong></p><ul><li>①如果定位到的数组位置没有元素 就直接插入。</li><li>②如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(table == EMPTY_TABLE)</span> </span>&#123; </span><br><span class="line">    inflateTable(threshold); </span><br><span class="line">&#125;  </span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123; <span class="comment">// 先遍历</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);  <span class="comment">// 再插入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 桶中不止一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h3><p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ? (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap常用方法测试"><a href="#HashMap常用方法测试" class="headerlink" title="HashMap常用方法测试"></a>HashMap常用方法测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">// 键不能重复，值可以重复</span></span><br><span class="line">        map.put(<span class="string">"san"</span>, <span class="string">"张三"</span>);</span><br><span class="line">        map.put(<span class="string">"si"</span>, <span class="string">"李四"</span>);</span><br><span class="line">        map.put(<span class="string">"wu"</span>, <span class="string">"王五"</span>);</span><br><span class="line">        map.put(<span class="string">"wang"</span>, <span class="string">"老王"</span>);</span><br><span class="line">        map.put(<span class="string">"wang"</span>, <span class="string">"老王2"</span>);<span class="comment">// 老王被覆盖</span></span><br><span class="line">        map.put(<span class="string">"lao"</span>, <span class="string">"老王"</span>);</span><br><span class="line">        System.out.println(<span class="string">"-------直接输出hashmap:-------"</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历HashMap</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1.获取Map中的所有键</span></span><br><span class="line">        System.out.println(<span class="string">"-------foreach获取Map中所有的键:------"</span>);</span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            System.out.print(key+<span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 2.获取Map中所有值</span></span><br><span class="line">        System.out.println(<span class="string">"-------foreach获取Map中所有的值:------"</span>);</span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        <span class="keyword">for</span> (String value : values) &#123;</span><br><span class="line">            System.out.print(value+<span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 3.得到key的值的同时得到key所对应的值</span></span><br><span class="line">        System.out.println(<span class="string">"-------得到key的值的同时得到key所对应的值:-------"</span>);</span><br><span class="line">        Set&lt;String&gt; keys2 = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys2) &#123;</span><br><span class="line">            System.out.print(key + <span class="string">"："</span> + map.get(key)+<span class="string">"   "</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果既要遍历key又要value，那么建议这种方式，应为如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。</span></span><br><span class="line"><span class="comment">         * 一次是在获取keySet的时候，一次是在遍历所有key的时候。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span></span><br><span class="line">        <span class="comment">// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span></span><br><span class="line">        <span class="comment">// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span></span><br><span class="line">        <span class="comment">// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span></span><br><span class="line">        Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">"--"</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * HashMap其他常用方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"after map.size()："</span>+map.size());</span><br><span class="line">        System.out.println(<span class="string">"after map.isEmpty()："</span>+map.isEmpty());</span><br><span class="line">        System.out.println(map.remove(<span class="string">"san"</span>));</span><br><span class="line">        System.out.println(<span class="string">"after map.remove()："</span>+map);</span><br><span class="line">        System.out.println(<span class="string">"after map.get(si)："</span>+map.get(<span class="string">"si"</span>));</span><br><span class="line">        System.out.println(<span class="string">"after map.containsKey(si)："</span>+map.containsKey(<span class="string">"si"</span>));</span><br><span class="line">        System.out.println(<span class="string">"after containsValue(李四)："</span>+map.containsValue(<span class="string">"李四"</span>));</span><br><span class="line">        System.out.println(map.replace(<span class="string">"si"</span>, <span class="string">"李四2"</span>));</span><br><span class="line">        System.out.println(<span class="string">"after map.replace(si, 李四2):"</span>+map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> collection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架面试题</title>
      <link href="/posts/4ae6ef4c/"/>
      <url>/posts/4ae6ef4c/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><p>点击关注<a href="#公众号">公众号</a>及时获取笔主最新更新文章，并可免费领取本文档配套的《Java面试突击》以及Java工程师必备学习资源。</p><h1 id="剖析面试最常见问题之Java集合框架"><a href="#剖析面试最常见问题之Java集合框架" class="headerlink" title="剖析面试最常见问题之Java集合框架"></a>剖析面试最常见问题之Java集合框架</h1><h2 id="1-1-集合概述"><a href="#1-1-集合概述" class="headerlink" title="1.1 集合概述"></a>1.1 集合概述</h2><h3 id="1-1-1-说说List-Set-Map三者的区别？"><a href="#1-1-1-说说List-Set-Map三者的区别？" class="headerlink" title="1.1.1 说说List,Set,Map三者的区别？"></a>1.1.1 说说List,Set,Map三者的区别？</h3><ul><li><strong>List(对付顺序的好帮手)：</strong> List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</li><li><strong>Set(注重独一无二的性质):</strong> 不允许重复的集合。不会有多个元素引用相同的对象。</li><li><strong>Map(用Key来搜索的专家):</strong> 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</li></ul><h3 id="1-1-2-集合框架底层数据结构总结"><a href="#1-1-2-集合框架底层数据结构总结" class="headerlink" title="1.1.2 集合框架底层数据结构总结"></a>1.1.2 集合框架底层数据结构总结</h3><h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><ul><li><strong>Arraylist：</strong> Object数组</li><li><strong>Vector：</strong> Object数组</li><li><strong>LinkedList：</strong> 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环)</li></ul><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><ul><li><strong>HashSet（无序，唯一）:</strong> 基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li><strong>LinkedHashSet：</strong> LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的</li><li><strong>TreeSet（有序，唯一）：</strong> 红黑树(自平衡的排序二叉树)</li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul><li><strong>HashMap：</strong> JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li><li><strong>LinkedHashMap：</strong> LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931" target="_blank" rel="noopener">《LinkedHashMap 源码详细分析（JDK1.8）》</a></li><li><strong>Hashtable：</strong> 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li><strong>TreeMap：</strong> 红黑树（自平衡的排序二叉树）</li></ul><h3 id="1-1-3如何选用集合"><a href="#1-1-3如何选用集合" class="headerlink" title="1.1.3如何选用集合?"></a>1.1.3如何选用集合?</h3><p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用Map接口下的集合，需要排序时选择TreeMap,不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap.当我们只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。</p><h2 id="1-2-Iterator迭代器接口"><a href="#1-2-Iterator迭代器接口" class="headerlink" title="1.2 Iterator迭代器接口"></a>1.2 Iterator迭代器接口</h2><h2 id="1-3-Collection子接口之List"><a href="#1-3-Collection子接口之List" class="headerlink" title="1.3 Collection子接口之List"></a>1.3 Collection子接口之List</h2><h3 id="1-3-1-Arraylist-与-LinkedList-区别"><a href="#1-3-1-Arraylist-与-LinkedList-区别" class="headerlink" title="1.3.1 Arraylist 与 LinkedList 区别?"></a>1.3.1 Arraylist 与 LinkedList 区别?</h3><ul><li><p><strong>1. 是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</p></li><li><p><strong>2. 底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p></li><li><p><strong>3. 插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></p></li><li><p><strong>4. 是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p></li><li><p><strong>5. 内存空间占用：</strong> ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</p></li></ul><h4 id="补充内容-RandomAccess接口"><a href="#补充内容-RandomAccess接口" class="headerlink" title="补充内容:RandomAccess接口"></a><strong>补充内容:RandomAccess接口</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看源码我们发现实际上 <code>RandomAccess</code> 接口中什么都没有定义。所以，在我看来 <code>RandomAccess</code> 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p><p>在 <code>binarySearch（)</code> 方法中，它要判断传入的list 是否 <code>RamdomAccess</code> 的实例，如果是，调用<code>indexedBinarySearch()</code>方法，如果不是，那么调用<code>iteratorBinarySearch()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。为什么呢？我觉得还是和底层数据结构有关！<code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。，<code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的！</p><p><strong>下面再总结一下 list 的遍历方式选择：</strong></p><ul><li>实现了 <code>RandomAccess</code> 接口的list，优先选择普通 for 循环 ，其次 foreach,</li><li>未实现 <code>RandomAccess</code>接口的list，优先选择iterator遍历（foreach遍历底层也是通过iterator实现的），大size的数据，千万不要使用普通for循环</li></ul><h4 id="补充内容-双向链表和双向循环链表"><a href="#补充内容-双向链表和双向循环链表" class="headerlink" title="补充内容:双向链表和双向循环链表"></a>补充内容:双向链表和双向循环链表</h4><p><strong>双向链表：</strong> 包含两个指针，一个prev指向前一个节点，一个next指向后一个节点。</p><blockquote><p>另外推荐一篇把双向链表讲清楚的文章：<a href="https://juejin.im/post/5b5d1a9af265da0f47352f14" target="_blank" rel="noopener">https://juejin.im/post/5b5d1a9af265da0f47352f14</a></p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="双向链表"></p><p><strong>双向循环链表：</strong> 最后一个节点的 next 指向head，而 head 的prev指向最后一个节点，构成一个环。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="双向循环链表"></p><h3 id="1-3-2-ArrayList-与-Vector-区别呢-为什么要用Arraylist取代Vector呢？"><a href="#1-3-2-ArrayList-与-Vector-区别呢-为什么要用Arraylist取代Vector呢？" class="headerlink" title="1.3.2 ArrayList 与 Vector 区别呢?为什么要用Arraylist取代Vector呢？"></a>1.3.2 ArrayList 与 Vector 区别呢?为什么要用Arraylist取代Vector呢？</h3><p><code>Vector</code>类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p><p><code>Arraylist</code>不是同步的，所以在不需要保证线程安全时建议使用Arraylist。</p><h3 id="1-3-3-说一说-ArrayList-的扩容机制吧"><a href="#1-3-3-说一说-ArrayList-的扩容机制吧" class="headerlink" title="1.3.3 说一说 ArrayList 的扩容机制吧"></a>1.3.3 说一说 ArrayList 的扩容机制吧</h3><p>详见笔主的这篇文章:<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md" target="_blank" rel="noopener">通过源码一步一步分析ArrayList 扩容机制</a></p><h2 id="1-4-Collection子接口之Set"><a href="#1-4-Collection子接口之Set" class="headerlink" title="1.4 Collection子接口之Set"></a>1.4 Collection子接口之Set</h2><h3 id="1-4-1-comparable-和-Comparator的区别"><a href="#1-4-1-comparable-和-Comparator的区别" class="headerlink" title="1.4.1 comparable 和 Comparator的区别"></a>1.4.1 comparable 和 Comparator的区别</h3><ul><li>comparable接口实际上是出自java.lang包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li>comparator接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code>.</p><h4 id="Comparator定制排序"><a href="#Comparator定制排序" class="headerlink" title="Comparator定制排序"></a>Comparator定制排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">arrayList.add(-<span class="number">1</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(-<span class="number">5</span>);</span><br><span class="line">arrayList.add(<span class="number">7</span>);</span><br><span class="line">arrayList.add(<span class="number">4</span>);</span><br><span class="line">arrayList.add(-<span class="number">9</span>);</span><br><span class="line">arrayList.add(-<span class="number">7</span>);</span><br><span class="line">System.out.println(<span class="string">"原始数组:"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"><span class="comment">// void reverse(List list)：反转</span></span><br><span class="line">Collections.reverse(arrayList);</span><br><span class="line">System.out.println(<span class="string">"Collections.reverse(arrayList):"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// void sort(List list),按自然排序的升序排序</span></span><br><span class="line">Collections.sort(arrayList);</span><br><span class="line">System.out.println(<span class="string">"Collections.sort(arrayList):"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"><span class="comment">// 定制排序的用法</span></span><br><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">"定制排序后："</span>);</span><br><span class="line">System.out.println(arrayList);</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原始数组:</span><br><span class="line">[-1, 3, 3, -5, 7, 4, -9, -7]</span><br><span class="line">Collections.reverse(arrayList):</span><br><span class="line">[-7, -9, 4, 7, -5, 3, 3, -1]</span><br><span class="line">Collections.sort(arrayList):</span><br><span class="line">[-9, -7, -5, -1, 3, 3, 4, 7]</span><br><span class="line">定制排序后：</span><br><span class="line">[7, 4, 3, 3, -1, -5, -7, -9]</span><br></pre></td></tr></table></figure><h4 id="重写compareTo方法实现按年龄来排序"><a href="#重写compareTo方法实现按年龄来排序" class="headerlink" title="重写compareTo方法实现按年龄来排序"></a>重写compareTo方法实现按年龄来排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span></span><br><span class="line"><span class="comment">// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span></span><br><span class="line"><span class="comment">// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TODO重写compareTo方法实现按年龄来排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age &lt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TreeMap&lt;Person, String&gt; pdata = <span class="keyword">new</span> TreeMap&lt;Person, String&gt;();</span><br><span class="line">    pdata.put(<span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">30</span>), <span class="string">"zhangsan"</span>);</span><br><span class="line">    pdata.put(<span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">20</span>), <span class="string">"lisi"</span>);</span><br><span class="line">    pdata.put(<span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">10</span>), <span class="string">"wangwu"</span>);</span><br><span class="line">    pdata.put(<span class="keyword">new</span> Person(<span class="string">"小红"</span>, <span class="number">5</span>), <span class="string">"xiaohong"</span>);</span><br><span class="line">    <span class="comment">// 得到key的值的同时得到key所对应的值</span></span><br><span class="line">    Set&lt;Person&gt; keys = pdata.keySet();</span><br><span class="line">    <span class="keyword">for</span> (Person key : keys) &#123;</span><br><span class="line">        System.out.println(key.getAge() + <span class="string">"-"</span> + key.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5-小红</span><br><span class="line">10-王五</span><br><span class="line">20-李四</span><br><span class="line">30-张三</span><br></pre></td></tr></table></figure><h2 id="1-5-Map接口"><a href="#1-5-Map接口" class="headerlink" title="1.5 Map接口"></a>1.5 Map接口</h2><h3 id="1-5-1-HashMap-和-Hashtable-的区别"><a href="#1-5-1-HashMap-和-Hashtable-的区别" class="headerlink" title="1.5.1 HashMap 和 Hashtable 的区别"></a>1.5.1 HashMap 和 Hashtable 的区别</h3><ol><li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li><li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li><li><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol><p><strong>HashMap 中带有初始容量的构造函数：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个方法保证了 HashMap 总是使用2的幂作为哈希表的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-2-HashMap-和-HashSet区别"><a href="#1-5-2-HashMap-和-HashSet区别" class="headerlink" title="1.5.2 HashMap 和 HashSet区别"></a>1.5.2 HashMap 和 HashSet区别</h3><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p><table><thead><tr><th align="center">HashMap</th><th align="center">HashSet</th></tr></thead><tbody><tr><td align="center">实现了Map接口</td><td align="center">实现Set接口</td></tr><tr><td align="center">存储键值对</td><td align="center">仅存储对象</td></tr><tr><td align="center">调用 <code>put()</code>向map中添加元素</td><td align="center">调用 <code>add()</code>方法向Set中添加元素</td></tr><tr><td align="center">HashMap使用键（Key）计算Hashcode</td><td align="center">HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，</td></tr></tbody></table><h3 id="1-5-3-HashSet如何检查重复"><a href="#1-5-3-HashSet如何检查重复" class="headerlink" title="1.5.3 HashSet如何检查重复"></a>1.5.3 HashSet如何检查重复</h3><p>当你把对象加入<code>HashSet</code>时，HashSet会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用<code>equals()</code>方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。（摘自我的Java启蒙书《Head fist java》第二版）</p><p><strong>hashCode()与equals()的相关规定：</strong></p><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个equals方法返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><p><strong>==与equals的区别</strong></p><ol><li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li><li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较</li><li>==指引用是否相同 equals()指的是值是否相同</li></ol><h3 id="1-5-4-HashMap的底层实现"><a href="#1-5-4-HashMap的底层实现" class="headerlink" title="1.5.4 HashMap的底层实现"></a>1.5.4 HashMap的底层实现</h3><h4 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h4><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p><p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p><p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p><p>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/jdk1.8%E4%B9%8B%E5%89%8D%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84-HashMap.jpg" alt="jdk1.8之前的内部结构-HashMap"></p><h4 id="5-4-2-JDK1-8之后"><a href="#5-4-2-JDK1-8之后" class="headerlink" title="5.4.2. JDK1.8之后"></a>5.4.2. <a name='JDK1.8-1'></a>JDK1.8之后</h4><p>相比于之前的版本， JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/JDK1.8%E4%B9%8B%E5%90%8E%E7%9A%84HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="jdk1.8之后的内部结构-HashMap"></p><blockquote><p>TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p></blockquote><p><strong>推荐阅读：</strong></p><ul><li>《Java 8系列之重新认识HashMap》 ：<a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21673805</a></li></ul><h3 id="1-5-5-HashMap-的长度为什么是2的幂次方"><a href="#1-5-5-HashMap-的长度为什么是2的幂次方" class="headerlink" title="1.5.5 HashMap 的长度为什么是2的幂次方"></a>1.5.5 HashMap 的长度为什么是2的幂次方</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n代表数组长度）。这也就解释了 HashMap 的长度为什么是2的幂次方。</p><p><strong>这个算法应该如何设计呢？</strong></p><p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</strong></p><h3 id="1-5-6-HashMap-多线程操作导致死循环问题"><a href="#1-5-6-HashMap-多线程操作导致死循环问题" class="headerlink" title="1.5.6 HashMap 多线程操作导致死循环问题"></a>1.5.6 HashMap 多线程操作导致死循环问题</h3><p>主要原因在于并发下的Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p><p>详情请查看：<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9606.html</a></p><h3 id="1-5-7-ConcurrentHashMap-和-Hashtable-的区别"><a href="#1-5-7-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="1.5.7 ConcurrentHashMap 和 Hashtable 的区别"></a>1.5.7 ConcurrentHashMap 和 Hashtable 的区别</h3><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构：</strong> JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><p><strong>两者的对比图：</strong></p><p>图片来源：<a href="http://www.cnblogs.com/chengxiao/p/6842045.html" target="_blank" rel="noopener">http://www.cnblogs.com/chengxiao/p/6842045.html</a></p><p><strong>HashTable:</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/HashTable%E5%85%A8%E8%A1%A8%E9%94%81.png" alt="HashTable全表锁"></p><p><strong>JDK1.7的ConcurrentHashMap：</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ConcurrentHashMap%E5%88%86%E6%AE%B5%E9%94%81.jpg" alt="JDK1.7的ConcurrentHashMap"></p><p><strong>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/JDK1.8-ConcurrentHashMap-Structure.jpg" alt="JDK1.8的ConcurrentHashMap"></p><h3 id="1-5-8-ConcurrentHashMap线程安全的具体实现方式-底层具体实现"><a href="#1-5-8-ConcurrentHashMap线程安全的具体实现方式-底层具体实现" class="headerlink" title="1.5.8 ConcurrentHashMap线程安全的具体实现方式/底层具体实现"></a>1.5.8 ConcurrentHashMap线程安全的具体实现方式/底层具体实现</h3><h4 id="JDK1-7（上面有示意图）"><a href="#JDK1-7（上面有示意图）" class="headerlink" title="JDK1.7（上面有示意图）"></a>JDK1.7（上面有示意图）</h4><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p><strong>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成</strong>。</p><p>Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p><h4 id="JDK1-8-（上面有示意图）"><a href="#JDK1-8-（上面有示意图）" class="headerlink" title="JDK1.8 （上面有示意图）"></a>JDK1.8 （上面有示意图）</h4><p>ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(log(N))）</p><p>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p><h2 id="1-6-Collections工具类"><a href="#1-6-Collections工具类" class="headerlink" title="1.6 Collections工具类"></a>1.6 Collections工具类</h2><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p><p><strong>《Java面试突击》:</strong> 由本文档衍生的专为面试而生的《Java面试突击》V2.0 PDF 版本<a href="#公众号">公众号</a>后台回复 <strong>“Java面试突击”</strong> 即可免费领取！</p><p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/qrcode_for_gh_ea338256af79_258.jpg" alt="我的公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
            <tag> collection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList</title>
      <link href="/posts/e3987cd6/"/>
      <url>/posts/e3987cd6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><font face="楷体" id="1">简介</font></h2><p><font color="red">LinkedList</font>是一个实现了<font color="red">List接口</font>和<font color="red">Deque接口</font>的<font color="red">双端链表</font>。<br>LinkedList底层的链表结构使它<font color="red">支持高效的插入和删除操作</font>，另外它实现了Deque接口，使得LinkedList类也具有队列的特性;<br>LinkedList<font color="red">不是线程安全的</font>，如果想使LinkedList变成线程安全的，可以调用静态类<font color="red">Collections类</font>中的<font color="red">synchronizedList</font>方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list=Collections.synchronizedList(<span class="keyword">new</span> LinkedList(...));</span><br></pre></td></tr></table></figure><h2 id="内部结构分析"><a href="#内部结构分析" class="headerlink" title="内部结构分析"></a><font face="楷体" id="2">内部结构分析</font></h2><p><strong>如下图所示：</strong><br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://user-gold-cdn.xitu.io/2018/3/19/1623e363fe0450b0?w=600&h=481&f=jpeg&s=18502" alt="LinkedList内部结构"><br>看完了图之后，我们再看LinkedList类中的一个<font color="red"><strong>内部私有类Node</strong></font>就很好理解了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;<span class="comment">//节点值</span></span><br><span class="line">        Node&lt;E&gt; next;<span class="comment">//后继节点</span></span><br><span class="line">        Node&lt;E&gt; prev;<span class="comment">//前驱节点</span></span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。</p><h2 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a><font face="楷体" id="3">LinkedList源码分析</font></h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><font face="楷体" id="3.1">构造方法</font></h3><p><strong>空构造方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用已有的集合创建链表的构造方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a><font face="楷体" id="3.2">add方法</font></h3><p><strong>add(E e)</strong> 方法：将元素添加到链表尾部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);<span class="comment">//这里就只调用了这一个方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 链接使e作为最后一个元素。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">     <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">     last = newNode;<span class="comment">//新建节点</span></span><br><span class="line">     <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">         first = newNode;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         l.next = newNode;<span class="comment">//指向后继元素也就是指向下一个元素</span></span><br><span class="line">     size++;</span><br><span class="line">     modCount++;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>add(int index,E e)</strong>：在指定位置添加元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index); <span class="comment">//检查索引是否处于[0-size]之间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == size)<span class="comment">//添加在链表尾部</span></span><br><span class="line">            linkLast(element);</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//添加在链表中间</span></span><br><span class="line">            linkBefore(element, node(index));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><font color="red">linkBefore方法</font>需要给定两个参数，一个<font color="red">插入节点的值</font>，一个<font color="red">指定的node</font>，所以我们又调用了<font color="red">Node(index)去找到index对应的node</font></p><p><strong>addAll(Collection  c )：将集合插入到链表尾部</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>addAll(int index, Collection c)：</strong> 将集合从指定位置开始插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1:检查index范围是否在size之内</span></span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2:toArray()方法把集合的数据存到对象数组中</span></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3：得到插入位置的前驱节点和后继节点</span></span><br><span class="line">        Node&lt;E&gt; pred, succ;</span><br><span class="line">        <span class="comment">//如果插入位置为尾部，前驱节点为last，后继节点为null</span></span><br><span class="line">        <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">            succ = <span class="keyword">null</span>;</span><br><span class="line">            pred = last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则，调用node()方法得到后继节点，再得到前驱节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            succ = node(index);</span><br><span class="line">            pred = succ.prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4：遍历数据将数据插入</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">            <span class="comment">//创建新节点</span></span><br><span class="line">            Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//如果插入位置在链表头部</span></span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                first = newNode;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = newNode;</span><br><span class="line">            pred = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果插入位置在尾部，重置last节点</span></span><br><span class="line">        <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = pred;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则，将插入的链表与先前链表连接起来</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pred.next = succ;</span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size += numNew;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面可以看出addAll方法通常包括下面四个步骤：</p><ol><li>检查index范围是否在size之内</li><li>toArray()方法把集合的数据存到对象数组中</li><li>得到插入位置的前驱和后继节点</li><li>遍历数据，将数据插入到指定位置</li></ol><p><strong>addFirst(E e)：</strong> 将元素添加到链表头部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       linkFirst(e);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);<span class="comment">//新建节点，以头节点为后继节点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">        <span class="comment">//如果链表为空，last节点也指向该节点</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            last = newNode;</span><br><span class="line">        <span class="comment">//否则，将头节点的前驱指针指向新节点，也就是指向前一个元素</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>addLast(E e)：</strong> 将元素添加到链表尾部，与 <strong>add(E e)</strong> 方法一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="根据位置取数据的方法"><a href="#根据位置取数据的方法" class="headerlink" title="根据位置取数据的方法"></a><font face="楷体" id="3.3">根据位置取数据的方法</font></h3><p><strong>get(int index)：</strong> 根据指定索引返回数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查index范围是否在size之内</span></span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="comment">//调用Node(index)去找到index对应的node然后返回它的值</span></span><br><span class="line">        <span class="keyword">return</span> node(index).item;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>获取头节点（index=0）数据方法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> f.item;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getFirst();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p><strong>区别：</strong><br>getFirst(),element(),peek(),peekFirst()<br>这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中<strong>getFirst()</strong> 和<strong>element()</strong> 方法将会在链表为空时，抛出异常</p><p>element()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出NoSuchElementException<br><strong>获取尾节点（index=-1）数据方法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">       <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> l.item;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">       <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>两者区别：</strong><br><strong>getLast()</strong> 方法在链表为空时，会抛出<strong>NoSuchElementException</strong>，而<strong>peekLast()</strong> 则不会，只是会返回 <strong>null</strong>。</p><h3 id="根据对象得到索引的方法"><a href="#根据对象得到索引的方法" class="headerlink" title="根据对象得到索引的方法"></a><font face="楷体" id="3.4">根据对象得到索引的方法</font></h3><p><strong>int indexOf(Object o)：</strong> 从头遍历找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//从头遍历</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//从头遍历</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>int lastIndexOf(Object o)：</strong> 从尾遍历找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = size;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//从尾遍历</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//从尾遍历</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="检查链表是否包含某对象的方法："><a href="#检查链表是否包含某对象的方法：" class="headerlink" title="检查链表是否包含某对象的方法："></a><font face="楷体" id="3.5">检查链表是否包含某对象的方法：</font></h3><p><strong>contains(Object o)：</strong> 检查对象o是否存在于链表中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a><font face="楷体" id="3.6">删除方法</font></h3><p><strong>remove()</strong> ,<strong>removeFirst(),pop():</strong> 删除头节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public E pop() &#123;</span><br><span class="line">        return removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">public E remove() &#123;</span><br><span class="line">        return removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">public E removeFirst() &#123;</span><br><span class="line">        final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">        if (f &#x3D;&#x3D; null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return unlinkFirst(f);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>removeLast(),pollLast():</strong> 删除尾节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>区别：</strong> removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。</p><p><strong>remove(Object o):</strong> 删除指定元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果删除对象为null</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//从头开始遍历</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="comment">//找到元素</span></span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">//从链表中移除找到的元素</span></span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//从头开始遍历</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="comment">//找到元素</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    <span class="comment">//从链表中移除找到的元素</span></span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。</p><p>unlink(Node<E> x) 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = x.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;<span class="comment">//得到后继节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;<span class="comment">//得到前驱节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除前驱指针</span></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = next;<span class="comment">//如果删除的节点是头节点,令头节点指向该节点的后继节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = next;<span class="comment">//将前驱节点的后继节点指向后继节点</span></span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除后继指针</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = prev;<span class="comment">//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>remove(int index)</strong>：删除指定位置的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查index范围</span></span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="comment">//将节点删除</span></span><br><span class="line">        <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedList类常用方法测试"><a href="#LinkedList类常用方法测试" class="headerlink" title="LinkedList类常用方法测试"></a><font face="楷体" id="4">LinkedList类常用方法测试</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] srgs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建存放int类型的linkedList</span></span><br><span class="line">        LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">/************************** linkedList的基本操作 ************************/</span></span><br><span class="line">        linkedList.addFirst(<span class="number">0</span>); <span class="comment">// 添加元素到列表开头</span></span><br><span class="line">        linkedList.add(<span class="number">1</span>); <span class="comment">// 在列表结尾添加元素</span></span><br><span class="line">        linkedList.add(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 在指定位置添加元素</span></span><br><span class="line">        linkedList.addLast(<span class="number">3</span>); <span class="comment">// 添加元素到列表结尾</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"LinkedList（直接输出的）: "</span> + linkedList);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"getFirst()获得第一个元素: "</span> + linkedList.getFirst()); <span class="comment">// 返回此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"getLast()获得第最后一个元素: "</span> + linkedList.getLast()); <span class="comment">// 返回此列表的最后一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"removeFirst()删除第一个元素并返回: "</span> + linkedList.removeFirst()); <span class="comment">// 移除并返回此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"removeLast()删除最后一个元素并返回: "</span> + linkedList.removeLast()); <span class="comment">// 移除并返回此列表的最后一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"After remove:"</span> + linkedList);</span><br><span class="line">        System.out.println(<span class="string">"contains()方法判断列表是否包含1这个元素:"</span> + linkedList.contains(<span class="number">1</span>)); <span class="comment">// 判断此列表包含指定元素，如果是，则返回true</span></span><br><span class="line">        System.out.println(<span class="string">"该linkedList的大小 : "</span> + linkedList.size()); <span class="comment">// 返回此列表的元素个数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 位置访问操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        linkedList.set(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// 将此列表中指定位置的元素替换为指定的元素</span></span><br><span class="line">        System.out.println(<span class="string">"After set(1, 3):"</span> + linkedList);</span><br><span class="line">        System.out.println(<span class="string">"get(1)获得指定位置（这里为1）的元素: "</span> + linkedList.get(<span class="number">1</span>)); <span class="comment">// 返回此列表中指定位置处的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** Search操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        linkedList.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"indexOf(3): "</span> + linkedList.indexOf(<span class="number">3</span>)); <span class="comment">// 返回此列表中首次出现的指定元素的索引</span></span><br><span class="line">        System.out.println(<span class="string">"lastIndexOf(3): "</span> + linkedList.lastIndexOf(<span class="number">3</span>));<span class="comment">// 返回此列表中最后出现的指定元素的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** Queue操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"peek(): "</span> + linkedList.peek()); <span class="comment">// 获取但不移除此列表的头</span></span><br><span class="line">        System.out.println(<span class="string">"element(): "</span> + linkedList.element()); <span class="comment">// 获取但不移除此列表的头</span></span><br><span class="line">        linkedList.poll(); <span class="comment">// 获取并移除此列表的头</span></span><br><span class="line">        System.out.println(<span class="string">"After poll():"</span> + linkedList);</span><br><span class="line">        linkedList.remove();</span><br><span class="line">        System.out.println(<span class="string">"After remove():"</span> + linkedList); <span class="comment">// 获取并移除此列表的头</span></span><br><span class="line">        linkedList.offer(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"After offer(4):"</span> + linkedList); <span class="comment">// 将指定元素添加到此列表的末尾</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** Deque操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        linkedList.offerFirst(<span class="number">2</span>); <span class="comment">// 在此列表的开头插入指定的元素</span></span><br><span class="line">        System.out.println(<span class="string">"After offerFirst(2):"</span> + linkedList);</span><br><span class="line">        linkedList.offerLast(<span class="number">5</span>); <span class="comment">// 在此列表末尾插入指定的元素</span></span><br><span class="line">        System.out.println(<span class="string">"After offerLast(5):"</span> + linkedList);</span><br><span class="line">        System.out.println(<span class="string">"peekFirst(): "</span> + linkedList.peekFirst()); <span class="comment">// 获取但不移除此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"peekLast(): "</span> + linkedList.peekLast()); <span class="comment">// 获取但不移除此列表的第一个元素</span></span><br><span class="line">        linkedList.pollFirst(); <span class="comment">// 获取并移除此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"After pollFirst():"</span> + linkedList);</span><br><span class="line">        linkedList.pollLast(); <span class="comment">// 获取并移除此列表的最后一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"After pollLast():"</span> + linkedList);</span><br><span class="line">        linkedList.push(<span class="number">2</span>); <span class="comment">// 将元素推入此列表所表示的堆栈（插入到列表的头）</span></span><br><span class="line">        System.out.println(<span class="string">"After push(2):"</span> + linkedList);</span><br><span class="line">        linkedList.pop(); <span class="comment">// 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）</span></span><br><span class="line">        System.out.println(<span class="string">"After pop():"</span> + linkedList);</span><br><span class="line">        linkedList.add(<span class="number">3</span>);</span><br><span class="line">        linkedList.removeFirstOccurrence(<span class="number">3</span>); <span class="comment">// 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表）</span></span><br><span class="line">        System.out.println(<span class="string">"After removeFirstOccurrence(3):"</span> + linkedList);</span><br><span class="line">        linkedList.removeLastOccurrence(<span class="number">3</span>); <span class="comment">// 从此列表中移除最后一次出现的指定元素（从尾部到头部遍历列表）</span></span><br><span class="line">        System.out.println(<span class="string">"After removeFirstOccurrence(3):"</span> + linkedList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 遍历操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        linkedList.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            linkedList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代器遍历</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = linkedList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"Iterator："</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顺序遍历(随机遍历)</span></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linkedList.size(); i++) &#123;</span><br><span class="line">            linkedList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"for："</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 另一种for循环遍历</span></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (Integer i : linkedList)</span><br><span class="line">            ;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"for2："</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过pollFirst()或pollLast()来遍历LinkedList</span></span><br><span class="line">        LinkedList&lt;Integer&gt; temp1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        temp1.addAll(linkedList);</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (temp1.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            temp1.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"pollFirst()或pollLast()："</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过removeFirst()或removeLast()来遍历LinkedList</span></span><br><span class="line">        LinkedList&lt;Integer&gt; temp2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        temp2.addAll(linkedList);</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (temp2.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            temp2.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"removeFirst()或removeLast()："</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> collection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Collections 工具类和 Arrays 工具类常见方法</title>
      <link href="/posts/20565686/"/>
      <url>/posts/20565686/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><h1 id="Collections-工具类和-Arrays-工具类常见方法"><a href="#Collections-工具类和-Arrays-工具类常见方法" class="headerlink" title="Collections 工具类和 Arrays 工具类常见方法"></a>Collections 工具类和 Arrays 工具类常见方法</h1><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>Collections 工具类常用方法:</p><ol><li>排序</li><li>查找,替换操作</li><li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li></ol><h3 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List list, <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List list, <span class="keyword">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。</span></span></span><br></pre></td></tr></table></figure><p><strong>示例代码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">   ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">arrayList.add(-<span class="number">1</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(-<span class="number">5</span>);</span><br><span class="line">arrayList.add(<span class="number">7</span>);</span><br><span class="line">arrayList.add(<span class="number">4</span>);</span><br><span class="line">arrayList.add(-<span class="number">9</span>);</span><br><span class="line">arrayList.add(-<span class="number">7</span>);</span><br><span class="line">System.out.println(<span class="string">"原始数组:"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"><span class="comment">// void reverse(List list)：反转</span></span><br><span class="line">Collections.reverse(arrayList);</span><br><span class="line">System.out.println(<span class="string">"Collections.reverse(arrayList):"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Collections.rotate(arrayList, <span class="number">4</span>);</span><br><span class="line">System.out.println(<span class="string">"Collections.rotate(arrayList, 4):"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// void sort(List list),按自然排序的升序排序</span></span><br><span class="line">Collections.sort(arrayList);</span><br><span class="line">System.out.println(<span class="string">"Collections.sort(arrayList):"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// void shuffle(List list),随机排序</span></span><br><span class="line">Collections.shuffle(arrayList);</span><br><span class="line">System.out.println(<span class="string">"Collections.shuffle(arrayList):"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// void swap(List list, int i , int j),交换两个索引位置的元素</span></span><br><span class="line">Collections.swap(arrayList, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"Collections.swap(arrayList, 2, 5):"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定制排序的用法</span></span><br><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">"定制排序后："</span>);</span><br><span class="line">System.out.println(arrayList);</span><br></pre></td></tr></table></figure><h3 id="查找-替换操作"><a href="#查找-替换操作" class="headerlink" title="查找,替换操作"></a>查找,替换操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span>, 用新元素替换旧元素</span></span><br></pre></td></tr></table></figure><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">arrayList.add(-<span class="number">1</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(<span class="number">3</span>);</span><br><span class="line">arrayList.add(-<span class="number">5</span>);</span><br><span class="line">arrayList.add(<span class="number">7</span>);</span><br><span class="line">arrayList.add(<span class="number">4</span>);</span><br><span class="line">arrayList.add(-<span class="number">9</span>);</span><br><span class="line">arrayList.add(-<span class="number">7</span>);</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">arrayList2.add(-<span class="number">3</span>);</span><br><span class="line">arrayList2.add(-<span class="number">5</span>);</span><br><span class="line">arrayList2.add(<span class="number">7</span>);</span><br><span class="line">System.out.println(<span class="string">"原始数组:"</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Collections.max(arrayList):"</span>);</span><br><span class="line">System.out.println(Collections.max(arrayList));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Collections.min(arrayList):"</span>);</span><br><span class="line">System.out.println(Collections.min(arrayList));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Collections.replaceAll(arrayList, 3, -3):"</span>);</span><br><span class="line">Collections.replaceAll(arrayList, <span class="number">3</span>, -<span class="number">3</span>);</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Collections.frequency(arrayList, -3):"</span>);</span><br><span class="line">System.out.println(Collections.frequency(arrayList, -<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Collections.indexOfSubList(arrayList, arrayList2):"</span>);</span><br><span class="line">System.out.println(Collections.indexOfSubList(arrayList, arrayList2));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Collections.binarySearch(arrayList, 7):"</span>);</span><br><span class="line"><span class="comment">// 对List进行二分查找，返回索引，List必须是有序的</span></span><br><span class="line">Collections.sort(arrayList);</span><br><span class="line">System.out.println(Collections.binarySearch(arrayList, <span class="number">7</span>));</span><br></pre></td></tr></table></figure><h3 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h3><p>Collections提供了多个<code>synchronizedXxx()</code>方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p><p>我们知道 HashSet，TreeSet，ArrayList,LinkedList,HashMap,TreeMap 都是线程不安全的。Collections提供了多个静态方法可以把他们包装成线程同步的集合。</p><p><strong>最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。</strong></p><p>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronizedCollection(Collection&lt;T&gt;  c) <span class="comment">//返回指定 collection 支持的同步（线程安全的）collection。</span></span><br><span class="line">synchronizedList(List&lt;T&gt; list)<span class="comment">//返回指定列表支持的同步（线程安全的）List。</span></span><br><span class="line">synchronizedMap(Map&lt;K,V&gt; m) <span class="comment">//返回由指定映射支持的同步（线程安全的）Map。</span></span><br><span class="line">synchronizedSet(Set&lt;T&gt; s) <span class="comment">//返回指定 set 支持的同步（线程安全的）set。</span></span><br></pre></td></tr></table></figure><h3 id="Collections还可以设置不可变集合，提供了如下三类方法："><a href="#Collections还可以设置不可变集合，提供了如下三类方法：" class="headerlink" title="Collections还可以设置不可变集合，提供了如下三类方法："></a>Collections还可以设置不可变集合，提供了如下三类方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">emptyXxx(): 返回一个空的、不可变的集合对象，此处的集合既可以是List，也可以是Set，还可以是Map。</span><br><span class="line">singletonXxx(): 返回一个只包含指定对象（只有一个或一个元素）的不可变的集合对象，此处的集合可以是：List，Set，Map。</span><br><span class="line">unmodifiableXxx(): 返回指定集合对象的不可变视图，此处的集合可以是：List，Set，Map。</span><br><span class="line">上面三类方法的参数是原有的集合对象，返回值是该集合的”只读“版本。</span><br></pre></td></tr></table></figure><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        arrayList.add(-<span class="number">1</span>);</span><br><span class="line">        arrayList.add(<span class="number">3</span>);</span><br><span class="line">        arrayList.add(<span class="number">3</span>);</span><br><span class="line">        arrayList.add(-<span class="number">5</span>);</span><br><span class="line">        arrayList.add(<span class="number">7</span>);</span><br><span class="line">        arrayList.add(<span class="number">4</span>);</span><br><span class="line">        arrayList.add(-<span class="number">9</span>);</span><br><span class="line">        arrayList.add(-<span class="number">7</span>);</span><br><span class="line">        HashSet&lt;Integer&gt; integers1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        integers1.add(<span class="number">1</span>);</span><br><span class="line">        integers1.add(<span class="number">3</span>);</span><br><span class="line">        integers1.add(<span class="number">2</span>);</span><br><span class="line">        Map scores = <span class="keyword">new</span> HashMap();</span><br><span class="line">        scores.put(<span class="string">"语文"</span> , <span class="number">80</span>);</span><br><span class="line">        scores.put(<span class="string">"Java"</span> , <span class="number">82</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Collections.emptyXXX();创建一个空的、不可改变的XXX对象</span></span><br><span class="line">        List&lt;Object&gt; list = Collections.emptyList();</span><br><span class="line">        System.out.println(list);<span class="comment">//[]</span></span><br><span class="line">        Set&lt;Object&gt; objects = Collections.emptySet();</span><br><span class="line">        System.out.println(objects);<span class="comment">//[]</span></span><br><span class="line">        Map&lt;Object, Object&gt; objectObjectMap = Collections.emptyMap();</span><br><span class="line">        System.out.println(objectObjectMap);<span class="comment">//&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Collections.singletonXXX();</span></span><br><span class="line">        List&lt;ArrayList&lt;Integer&gt;&gt; arrayLists = Collections.singletonList(arrayList);</span><br><span class="line">        System.out.println(arrayLists);<span class="comment">//[[-1, 3, 3, -5, 7, 4, -9, -7]]</span></span><br><span class="line">        <span class="comment">//创建一个只有一个元素，且不可改变的Set对象</span></span><br><span class="line">        Set&lt;ArrayList&lt;Integer&gt;&gt; singleton = Collections.singleton(arrayList);</span><br><span class="line">        System.out.println(singleton);<span class="comment">//[[-1, 3, 3, -5, 7, 4, -9, -7]]</span></span><br><span class="line">        Map&lt;String, String&gt; nihao = Collections.singletonMap(<span class="string">"1"</span>, <span class="string">"nihao"</span>);</span><br><span class="line">        System.out.println(nihao);<span class="comment">//&#123;1=nihao&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//unmodifiableXXX();创建普通XXX对象对应的不可变版本</span></span><br><span class="line">        List&lt;Integer&gt; integers = Collections.unmodifiableList(arrayList);</span><br><span class="line">        System.out.println(integers);<span class="comment">//[-1, 3, 3, -5, 7, 4, -9, -7]</span></span><br><span class="line">        Set&lt;Integer&gt; integers2 = Collections.unmodifiableSet(integers1);</span><br><span class="line">        System.out.println(integers2);<span class="comment">//[1, 2, 3]</span></span><br><span class="line">        Map&lt;Object, Object&gt; objectObjectMap2 = Collections.unmodifiableMap(scores);</span><br><span class="line">        System.out.println(objectObjectMap2);<span class="comment">//&#123;Java=82, 语文=80&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加出现异常：java.lang.UnsupportedOperationException</span></span><br><span class="line"><span class="comment">//        list.add(1);</span></span><br><span class="line"><span class="comment">//        arrayLists.add(arrayList);</span></span><br><span class="line"><span class="comment">//        integers.add(1);</span></span><br></pre></td></tr></table></figure><h2 id="Arrays类的常见操作"><a href="#Arrays类的常见操作" class="headerlink" title="Arrays类的常见操作"></a>Arrays类的常见操作</h2><ol><li>排序 : <code>sort()</code></li><li>查找 : <code>binarySearch()</code></li><li>比较: <code>equals()</code></li><li>填充 : <code>fill()</code></li><li>转列表:  <code>asList()</code></li><li>转字符串 : <code>toString()</code></li><li>复制: <code>copyOf()</code></li></ol><h3 id="排序-sort"><a href="#排序-sort" class="headerlink" title="排序 : sort()"></a>排序 : <code>sort()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *************排序 sort****************</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="comment">// sort(int[] a)方法按照数字顺序排列指定的数组。</span></span><br><span class="line">Arrays.sort(a);</span><br><span class="line">System.out.println(<span class="string">"Arrays.sort(a):"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort(int[] a,int fromIndex,int toIndex)按升序排列数组的指定范围</span></span><br><span class="line"><span class="keyword">int</span> b[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span> &#125;;</span><br><span class="line">Arrays.sort(b, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.sort(b, 2, 6):"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : b) &#123;</span><br><span class="line">System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="comment">// parallelSort(int[] a) 按照数字顺序排列指定的数组(并行的)。同sort方法一样也有按范围的排序</span></span><br><span class="line">Arrays.parallelSort(c);</span><br><span class="line">System.out.println(<span class="string">"Arrays.parallelSort(c)："</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : c) &#123;</span><br><span class="line">System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// parallelSort给字符数组排序，sort也可以</span></span><br><span class="line"><span class="keyword">char</span> d[] = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line">Arrays.parallelSort(d);</span><br><span class="line">System.out.println(<span class="string">"Arrays.parallelSort(d)："</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> d2 : d) &#123;</span><br><span class="line">System.out.print(d2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure><p>在做算法面试题的时候，我们还可能会经常遇到对字符串排序的情况,<code>Arrays.sort()</code> 对每个字符串的特定位置进行比较，然后按照升序排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] strs = &#123; <span class="string">"abcdehg"</span>, <span class="string">"abcdefg"</span>, <span class="string">"abcdeag"</span> &#125;;</span><br><span class="line">Arrays.sort(strs);</span><br><span class="line">System.out.println(Arrays.toString(strs));<span class="comment">//[abcdeag, abcdefg, abcdehg]</span></span><br></pre></td></tr></table></figure><h3 id="查找-binarySearch"><a href="#查找-binarySearch" class="headerlink" title="查找 : binarySearch()"></a>查找 : <code>binarySearch()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *************查找 binarySearch()****************</span></span><br><span class="line"><span class="keyword">char</span>[] e = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line"><span class="comment">// 排序后再进行二分查找，否则找不到</span></span><br><span class="line">Arrays.sort(e);</span><br><span class="line">System.out.println(<span class="string">"Arrays.sort(e)"</span> + Arrays.toString(e));</span><br><span class="line">System.out.println(<span class="string">"Arrays.binarySearch(e, 'c')："</span>);</span><br><span class="line"><span class="keyword">int</span> s = Arrays.binarySearch(e, <span class="string">'c'</span>);</span><br><span class="line">System.out.println(<span class="string">"字符c在数组的位置："</span> + s);</span><br></pre></td></tr></table></figure><h3 id="比较-equals"><a href="#比较-equals" class="headerlink" title="比较: equals()"></a>比较: <code>equals()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *************比较 equals****************</span></span><br><span class="line"><span class="keyword">char</span>[] e = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line"><span class="keyword">char</span>[] f = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 元素数量相同，并且相同位置的元素相同。 另外，如果两个数组引用都是null，则它们被认为是相等的 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 输出true</span></span><br><span class="line">System.out.println(<span class="string">"Arrays.equals(e, f):"</span> + Arrays.equals(e, f));</span><br></pre></td></tr></table></figure><h3 id="填充-fill"><a href="#填充-fill" class="headerlink" title="填充 : fill()"></a>填充 : <code>fill()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *************填充fill(批量初始化)****************</span></span><br><span class="line"><span class="keyword">int</span>[] g = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="comment">// 数组中所有元素重新分配值</span></span><br><span class="line">Arrays.fill(g, <span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.fill(g, 3)："</span>);</span><br><span class="line"><span class="comment">// 输出结果：333333333</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : g) &#123;</span><br><span class="line">System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] h = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, &#125;;</span><br><span class="line"><span class="comment">// 数组中指定范围元素重新分配值</span></span><br><span class="line">Arrays.fill(h, <span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.fill(h, 0, 2, 9);："</span>);</span><br><span class="line"><span class="comment">// 输出结果：993333666</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : h) &#123;</span><br><span class="line">System.out.print(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转列表-asList"><a href="#转列表-asList" class="headerlink" title="转列表 asList()"></a>转列表 <code>asList()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *************转列表 asList()****************</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回由指定数组支持的固定大小的列表。</span></span><br><span class="line"><span class="comment"> * （将返回的列表更改为“写入数组”。）该方法作为基于数组和基于集合的API之间的桥梁，与Collection.toArray()相结合 。</span></span><br><span class="line"><span class="comment"> * 返回的列表是可序列化的，并实现RandomAccess 。</span></span><br><span class="line"><span class="comment"> * 此方法还提供了一种方便的方式来创建一个初始化为包含几个元素的固定大小的列表如下：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;String&gt; stooges = Arrays.asList(<span class="string">"Larry"</span>, <span class="string">"Moe"</span>, <span class="string">"Curly"</span>);</span><br><span class="line">System.out.println(stooges);</span><br></pre></td></tr></table></figure><h3 id="转字符串-toString"><a href="#转字符串-toString" class="headerlink" title="转字符串 toString()"></a>转字符串 <code>toString()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *************转字符串 toString()****************</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 返回指定数组的内容的字符串表示形式。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">char</span>[] k = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line">System.out.println(Arrays.toString(k));<span class="comment">// [a, f, b, c, e, A, C, B]</span></span><br></pre></td></tr></table></figure><h3 id="复制-copyOf"><a href="#复制-copyOf" class="headerlink" title="复制 copyOf()"></a>复制 <code>copyOf()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *************复制 copy****************</span></span><br><span class="line"><span class="comment">// copyOf 方法实现数组复制,h为数组，6为复制的长度</span></span><br><span class="line"><span class="keyword">int</span>[] h = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, &#125;;</span><br><span class="line"><span class="keyword">int</span> i[] = Arrays.copyOf(h, <span class="number">6</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.copyOf(h, 6);："</span>);</span><br><span class="line"><span class="comment">// 输出结果：123333</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j : i) &#123;</span><br><span class="line">System.out.print(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">// copyOfRange将指定数组的指定范围复制到新数组中</span></span><br><span class="line"><span class="keyword">int</span> j[] = Arrays.copyOfRange(h, <span class="number">6</span>, <span class="number">11</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.copyOfRange(h, 6, 11)："</span>);</span><br><span class="line"><span class="comment">// 输出结果66600(h数组只有9个元素这里是从索引6到索引11复制所以不足的就为0)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j2 : j) &#123;</span><br><span class="line">System.out.print(j2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> collection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>final,static,this,super 关键字总结</title>
      <link href="/posts/f313f783/"/>
      <url>/posts/f313f783/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><h1 id="final-static-this-super-关键字总结"><a href="#final-static-this-super-关键字总结" class="headerlink" title="final,static,this,super 关键字总结"></a>final,static,this,super 关键字总结</h1><h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><p><strong>final关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点：</strong></p><ol><li><p><strong>final修饰的类不能被继承，final类中的所有成员方法都会被隐式的指定为final方法；</strong></p></li><li><p><strong>final修饰的方法不能被重写；</strong></p></li><li><p><strong>final修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。</strong></p></li></ol><p>说明：使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。</p><h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h2><p><strong>static 关键字主要有以下四种使用场景：</strong></p><ol><li><strong>修饰成员变量和成员方法:</strong> 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：<code>类名.静态变量名</code>    <code>类名.静态方法名()</code></li><li><strong>静态代码块:</strong> 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</li><li><strong>静态内部类（static修饰类的话只能修饰内部类）：</strong> 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。</li><li><strong>静态导包(用来导入类中的静态资源，1.5之后的新特性):</strong> 格式为：<code>import static</code> 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</li></ol><h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><p>this关键字用于引用类的当前实例。 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line">    Employees[] employees;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">manageEmployees</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalEmp = <span class="keyword">this</span>.employees.length;</span><br><span class="line">        System.out.println(<span class="string">"Total employees: "</span> + totalEmp);</span><br><span class="line">        <span class="keyword">this</span>.report();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，this关键字用于两个地方：</p><ul><li>this.employees.length：访问类Manager的当前实例的变量。</li><li>this.report（）：调用类Manager的当前实例的方法。</li></ul><p>此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。</p><h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>super关键字用于从子类访问父类的变量和方法。 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> number;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">showNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"number = "</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.number = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">super</span>.showNumber();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 <code>showNumber（）</code> 方法。</p><p><strong>使用 this 和 super 要注意的问题：</strong></p><ul><li>在构造器中使用 <code>super（）</code> 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。</li><li>this、super不能用在static方法中。</li></ul><p><strong>简单解释一下：</strong></p><p>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， <strong>this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西</strong>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.codejava.net/java-core/the-java-language/java-keywords" target="_blank" rel="noopener">https://www.codejava.net/java-core/the-java-language/java-keywords</a></li><li><a href="https://blog.csdn.net/u013393958/article/details/79881037" target="_blank" rel="noopener">https://blog.csdn.net/u013393958/article/details/79881037</a></li></ul><h1 id="static-关键字详解"><a href="#static-关键字详解" class="headerlink" title="static 关键字详解"></a>static 关键字详解</h1><h2 id="static-关键字主要有以下四种使用场景"><a href="#static-关键字主要有以下四种使用场景" class="headerlink" title="static 关键字主要有以下四种使用场景"></a>static 关键字主要有以下四种使用场景</h2><ol><li>修饰成员变量和成员方法</li><li>静态代码块</li><li>修饰类(只能修饰内部类)</li><li>静态导包(用来导入类中的静态资源，1.5之后的新特性)</li></ol><h3 id="修饰成员变量和成员方法-常用"><a href="#修饰成员变量和成员方法-常用" class="headerlink" title="修饰成员变量和成员方法(常用)"></a>修饰成员变量和成员方法(常用)</h3><p>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。</p><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p><p> HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。</p><p>调用格式：</p><ul><li><code>类名.静态变量名</code></li><li><code>类名.静态方法名()</code></li></ul><p>如果变量或者方法被 private 则代表该属性或者该方法只能在类的内部被访问而不能在类的外部被访问。</p><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello i am java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"StaticBean&#123;"</span>+</span><br><span class="line">                <span class="string">"name="</span> + name + <span class="string">",age="</span> + age +</span><br><span class="line">                <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticBean staticBean = <span class="keyword">new</span> StaticBean(<span class="string">"1"</span>);</span><br><span class="line">        StaticBean staticBean2 = <span class="keyword">new</span> StaticBean(<span class="string">"2"</span>);</span><br><span class="line">        StaticBean staticBean3 = <span class="keyword">new</span> StaticBean(<span class="string">"3"</span>);</span><br><span class="line">        StaticBean staticBean4 = <span class="keyword">new</span> StaticBean(<span class="string">"4"</span>);</span><br><span class="line">        StaticBean.age = <span class="number">33</span>;</span><br><span class="line">        System.out.println(staticBean + <span class="string">" "</span> + staticBean2 + <span class="string">" "</span> + staticBean3 + <span class="string">" "</span> + staticBean4);</span><br><span class="line">        <span class="comment">//StaticBean&#123;name=1,age=33&#125; StaticBean&#123;name=2,age=33&#125; StaticBean&#123;name=3,age=33&#125; StaticBean&#123;name=4,age=33&#125;</span></span><br><span class="line">        StaticBean.SayHello();<span class="comment">//Hello i am java</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</p><p>静态代码块的格式是 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static &#123;    </span><br><span class="line">语句体;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-14/88531075.jpg" alt=""></p><p>静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问.</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：</p><ol><li>它的创建是不需要依赖外围类的创建。</li><li>它不能使用任何外围类的非static成员变量和方法。</li></ol><p>Example（静态内部类实现单例模式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//声明为 private 避免调用默认构造方法创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 声明为 private 表明静态内部该类只能在该 Singleton 类中被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 <code>getUniqueInstance()</code>方法从而触发 <code>SingletonHolder.INSTANCE</code> 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。</p><p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p><h3 id="静态导包"><a href="#静态导包" class="headerlink" title="静态导包"></a>静态导包</h3><p>格式为：import static </p><p>这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//将Math中的所有静态资源导入，这时候可以直接使用里面的静态方法，而不用通过类名进行调用</span></span><br><span class="line"> <span class="comment">//如果只想导入单一某个静态方法，只需要将换成对应的方法名即可</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;<span class="comment">//换成import static java.lang.Math.max;具有一样的效果</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> max = max(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(max);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><h3 id="静态方法与非静态方法"><a href="#静态方法与非静态方法" class="headerlink" title="静态方法与非静态方法"></a>静态方法与非静态方法</h3><p>静态方法属于类本身，非静态方法属于从该类生成的每个对象。 如果您的方法执行的操作不依赖于其类的各个变量和方法，请将其设置为静态（这将使程序的占用空间更小）。 否则，它应该是非静态的。</p><p>Example</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; </span><br><span class="line">       <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"An example string that doesn't depend on i (an instance variable)"</span>;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.i + <span class="number">1</span>;  <span class="comment">//Depends on i</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以像这样调用静态方法：<code>Foo.method1()</code>。 如果您尝试使用这种方法调用 method2 将失败。 但这样可行：<code>Foo bar = new Foo(1);bar.method2();</code></p><p>总结：</p><ul><li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 </li><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制 </li></ul><h3 id="static-静态代码块与-非静态代码块-构造代码块"><a href="#static-静态代码块与-非静态代码块-构造代码块" class="headerlink" title="static{}静态代码块与{}非静态代码块(构造代码块)"></a><code>static{}</code>静态代码块与<code>{}</code>非静态代码块(构造代码块)</h3><p>相同点： 都是在JVM加载类时且在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行，一般在代码块中对一些static变量进行赋值。 </p><p>不同点： 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。 </p><blockquote><p>修正 <a href="https://github.com/Snailclimb/JavaGuide/issues/677" target="_blank" rel="noopener">issue #677</a>：静态代码块可能在第一次new的时候执行，但不一定只在第一次new的时候执行。比如通过 <code>Class.forName(&quot;ClassDemo&quot;)</code>创建 Class 对象的时候也会执行。</p></blockquote><p>一般情况下,如果有些代码比如一些项目最常用的变量或对象必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的。如果我们想要设计不需要创建对象就可以调用类中的方法，例如：Arrays类，Character类，String类等，就需要使用静态方法, 两者的区别是 静态代码块是自动执行的而静态方法是被调用的时候才执行的. </p><p>Example：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"默认构造方法！--"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非静态代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">"非静态代码块！--"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">"静态代码块！--"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"静态方法中的内容! --"</span>);</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(<span class="string">"静态方法中的代码块！--"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        Test.test();<span class="comment">//静态代码块！--静态方法中的内容! --静态方法中的代码块！--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态代码块！--非静态代码块！--默认构造方法！--静态方法中的内容! --静态方法中的代码块！--</span><br></pre></td></tr></table></figure><p>当只执行 <code>Test.test();</code> 时输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态代码块！--静态方法中的内容! --静态方法中的代码块！--</span><br></pre></td></tr></table></figure><p>当只执行 <code>Test test = new Test();</code> 时输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态代码块！--非静态代码块！--默认构造方法！--</span><br></pre></td></tr></table></figure><p>非静态代码块与构造函数的区别是： 非静态代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。 </p><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul><li>httpsblog.csdn.netchen13579867831articledetails78995480</li><li>http<a href="http://www.cnblogs.comchenssyp3388487.html" target="_blank" rel="noopener">www.cnblogs.comchenssyp3388487.html</a></li><li>http<a href="http://www.cnblogs.comQian123p5713440.html" target="_blank" rel="noopener">www.cnblogs.comQian123p5713440.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用好Java中的枚举</title>
      <link href="/posts/50249b0f/"/>
      <url>/posts/50249b0f/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p><p>最近重看 Java 枚举，看到这篇觉得还不错的文章，于是简单翻译和完善了一些内容，分享给大家，希望你们也能有所收获。另外，不要忘了文末还有补充哦！</p><p>ps: 这里发一篇枚举的文章，也是因为后面要发一篇非常实用的关于 SpringBoot 全局异常处理的比较好的实践，里面就用到了枚举。</p><p>这篇文章由 JavaGuide 翻译，公众号: JavaGuide,原文地址：<a href="https://www.baeldung.com/a-guide-to-java-enums" target="_blank" rel="noopener">https://www.baeldung.com/a-guide-to-java-enums</a> 。</p><p>转载请注明上面这段文字。</p></blockquote><h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1.概览"></a>1.概览</h2><p>在本文中，我们将看到什么是 Java 枚举，它们解决了哪些问题以及如何在实践中使用  Java 枚举实现一些设计模式。</p><p>enum关键字在 java5 中引入，表示一种特殊类型的类，其总是继承java.lang.Enum类，更多内容可以自行查看其<a href="https://docs.oracle.com/javase/6/docs/api/java/lang/Enum.html" target="_blank" rel="noopener">官方文档</a>。</p><p>枚举在很多时候会和常量拿来对比，可能因为本身我们大量实际使用枚举的地方就是为了替代常量。那么这种方式由什么优势呢？</p><p><strong>以这种方式定义的常量使代码更具可读性，允许进行编译时检查，预先记录可接受值的列表，并避免由于传入无效值而引起的意外行为。</strong></p><p>下面示例定义一个简单的枚举类型 pizza 订单的状态，共有三种 ORDERED, READY, DELIVERED状态:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> shuang.kou.enumdemo.enumtest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> PizzaStatus &#123;</span><br><span class="line">    ORDERED,</span><br><span class="line">    READY, </span><br><span class="line">    DELIVERED; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简单来说，我们通过上面的代码避免了定义常量，我们将所有和 pizza 订单的状态的常量都统一放到了一个枚举类型里面。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(PizzaStatus.ORDERED.name());<span class="comment">//ORDERED</span></span><br><span class="line">System.out.println(PizzaStatus.ORDERED);<span class="comment">//ORDERED</span></span><br><span class="line">System.out.println(PizzaStatus.ORDERED.name().getClass());<span class="comment">//class java.lang.String</span></span><br><span class="line">System.out.println(PizzaStatus.ORDERED.getClass());<span class="comment">//class shuang.kou.enumdemo.enumtest.PizzaStatus</span></span><br></pre></td></tr></table></figure><h2 id="2-自定义枚举方法"><a href="#2-自定义枚举方法" class="headerlink" title="2.自定义枚举方法"></a>2.自定义枚举方法</h2><p>现在我们对枚举是什么以及如何使用它们有了基本的了解，让我们通过在枚举上定义一些额外的API方法，将上一个示例提升到一个新的水平：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PizzaStatus status;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> PizzaStatus &#123;</span><br><span class="line">        ORDERED,</span><br><span class="line">        READY,</span><br><span class="line">        DELIVERED;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDeliverable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getStatus() == PizzaStatus.READY) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Methods that set and get the status variable.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-使用-比较枚举类型"><a href="#3-使用-比较枚举类型" class="headerlink" title="3.使用 == 比较枚举类型"></a>3.使用 == 比较枚举类型</h2><p>由于枚举类型确保JVM中仅存在一个常量实例，因此我们可以安全地使用“ ==”运算符比较两个变量，如上例所示；此外，“ ==”运算符可提供编译时和运行时的安全性。</p><p>首先，让我们看一下以下代码段中的运行时安全性，其中“ ==”运算符用于比较状态，并且如果两个值均为null 都不会引发 NullPointerException。相反，如果使用equals方法，将抛出 NullPointerException：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(testPz.getStatus().equals(Pizza.PizzaStatus.DELIVERED)); </span><br><span class="line"><span class="keyword">if</span>(testPz.getStatus() == Pizza.PizzaStatus.DELIVERED);</span><br></pre></td></tr></table></figure><p>对于编译时安全性，我们看另一个示例，两个不同枚举类型进行比较，使用equal方法比较结果确定为true，因为getStatus方法的枚举值与另一个类型枚举值一致，但逻辑上应该为false。这个问题可以使用==操作符避免。因为编译器会表示类型不兼容错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(testPz.getStatus().equals(TestColor.GREEN));</span><br><span class="line"><span class="keyword">if</span>(testPz.getStatus() == TestColor.GREEN);</span><br></pre></td></tr></table></figure><h2 id="4-在-switch-语句中使用枚举类型"><a href="#4-在-switch-语句中使用枚举类型" class="headerlink" title="4.在 switch 语句中使用枚举类型"></a>4.在 switch 语句中使用枚举类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDeliveryTimeInDays</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">        <span class="keyword">case</span> ORDERED: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> READY: <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> DELIVERED: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-枚举类型的属性-方法和构造函数"><a href="#5-枚举类型的属性-方法和构造函数" class="headerlink" title="5.枚举类型的属性,方法和构造函数"></a>5.枚举类型的属性,方法和构造函数</h2><blockquote><p>文末有我(JavaGuide)的补充。</p></blockquote><p>你可以通过在枚举类型中定义属性,方法和构造函数让它变得更加强大。</p><p>下面，让我们扩展上面的示例，实现从比萨的一个阶段到另一个阶段的过渡，并了解如何摆脱之前使用的if语句和switch语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> PizzaStatus status;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> PizzaStatus &#123;</span><br><span class="line">        ORDERED (<span class="number">5</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOrdered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        READY (<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        DELIVERED (<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDelivered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> timeToDelivery;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOrdered</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReady</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDelivered</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTimeToDelivery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> timeToDelivery;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        PizzaStatus (<span class="keyword">int</span> timeToDelivery) &#123;</span><br><span class="line">            <span class="keyword">this</span>.timeToDelivery = timeToDelivery;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDeliverable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.status.isReady();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTimeToDeliver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Time to delivery is "</span> + </span><br><span class="line">          <span class="keyword">this</span>.getStatus().getTimeToDelivery());</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Methods that set and get the status variable.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这段代码展示它是如何 work 的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenPizaOrder_whenReady_thenDeliverable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Pizza testPz = <span class="keyword">new</span> Pizza();</span><br><span class="line">    testPz.setStatus(Pizza.PizzaStatus.READY);</span><br><span class="line">    assertTrue(testPz.isDeliverable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-EnumSet-and-EnumMap"><a href="#6-EnumSet-and-EnumMap" class="headerlink" title="6.EnumSet and EnumMap"></a>6.EnumSet and EnumMap</h2><h3 id="6-1-EnumSet"><a href="#6-1-EnumSet" class="headerlink" title="6.1. EnumSet"></a>6.1. EnumSet</h3><p><code>EnumSet</code> 是一种专门为枚举类型所设计的 <code>Set</code> 类型。</p><p>与<code>HashSet</code>相比，由于使用了内部位向量表示，因此它是特定 <code>Enum</code> 常量集的非常有效且紧凑的表示形式。</p><p>它提供了类型安全的替代方法，以替代传统的基于int的“位标志”，使我们能够编写更易读和易于维护的简洁代码。</p><p><code>EnumSet</code> 是抽象类，其有两个实现：<code>RegularEnumSet</code> 、<code>JumboEnumSet</code>，选择哪一个取决于实例化时枚举中常量的数量。</p><p>在很多场景中的枚举常量集合操作（如：取子集、增加、删除、<code>containsAll</code>和<code>removeAll</code>批操作）使用<code>EnumSet</code>非常合适；如果需要迭代所有可能的常量则使用<code>Enum.values()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EnumSet&lt;PizzaStatus&gt; undeliveredPizzaStatuses =</span><br><span class="line">      EnumSet.of(PizzaStatus.ORDERED, PizzaStatus.READY);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> PizzaStatus status;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> PizzaStatus &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDeliverable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.status.isReady();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTimeToDeliver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Time to delivery is "</span> + </span><br><span class="line">          <span class="keyword">this</span>.getStatus().getTimeToDelivery() + <span class="string">" days"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Pizza&gt; <span class="title">getAllUndeliveredPizzas</span><span class="params">(List&lt;Pizza&gt; input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.stream().filter(</span><br><span class="line">          (s) -&gt; undeliveredPizzaStatuses.contains(s.getStatus()))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliver</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (isDeliverable()) &#123; </span><br><span class="line">            PizzaDeliverySystemConfiguration.getInstance().getDeliveryStrategy()</span><br><span class="line">              .deliver(<span class="keyword">this</span>); </span><br><span class="line">            <span class="keyword">this</span>.setStatus(PizzaStatus.DELIVERED); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Methods that set and get the status variable.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  下面的测试演示了展示了 <code>EnumSet</code> 在某些场景下的强大功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenPizaOrders_whenRetrievingUnDeliveredPzs_thenCorrectlyRetrieved</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Pizza&gt; pzList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Pizza pz1 = <span class="keyword">new</span> Pizza();</span><br><span class="line">    pz1.setStatus(Pizza.PizzaStatus.DELIVERED);</span><br><span class="line"> </span><br><span class="line">    Pizza pz2 = <span class="keyword">new</span> Pizza();</span><br><span class="line">    pz2.setStatus(Pizza.PizzaStatus.ORDERED);</span><br><span class="line"> </span><br><span class="line">    Pizza pz3 = <span class="keyword">new</span> Pizza();</span><br><span class="line">    pz3.setStatus(Pizza.PizzaStatus.ORDERED);</span><br><span class="line"> </span><br><span class="line">    Pizza pz4 = <span class="keyword">new</span> Pizza();</span><br><span class="line">    pz4.setStatus(Pizza.PizzaStatus.READY);</span><br><span class="line"> </span><br><span class="line">    pzList.add(pz1);</span><br><span class="line">    pzList.add(pz2);</span><br><span class="line">    pzList.add(pz3);</span><br><span class="line">    pzList.add(pz4);</span><br><span class="line"> </span><br><span class="line">    List&lt;Pizza&gt; undeliveredPzs = Pizza.getAllUndeliveredPizzas(pzList); </span><br><span class="line">    assertTrue(undeliveredPzs.size() == <span class="number">3</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-EnumMap"><a href="#6-2-EnumMap" class="headerlink" title="6.2. EnumMap"></a>6.2. EnumMap</h3><p><code>EnumMap</code>是一个专门化的映射实现，用于将枚举常量用作键。与对应的 <code>HashMap</code> 相比，它是一个高效紧凑的实现，并且在内部表示为一个数组:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EnumMap&lt;Pizza.PizzaStatus, Pizza&gt; map;</span><br></pre></td></tr></table></figure><p>让我们快速看一个真实的示例，该示例演示如何在实践中使用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> EnumMap&lt;PizzaStatus, List&lt;Pizza&gt;&gt; </span><br><span class="line">  groupPizzaByStatus(List&lt;Pizza&gt; pizzaList) &#123;</span><br><span class="line">    EnumMap&lt;PizzaStatus, List&lt;Pizza&gt;&gt; pzByStatus = </span><br><span class="line">      <span class="keyword">new</span> EnumMap&lt;PizzaStatus, List&lt;Pizza&gt;&gt;(PizzaStatus<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> (Pizza pz : pizzaList) &#123;</span><br><span class="line">        PizzaStatus status = pz.getStatus();</span><br><span class="line">        <span class="keyword">if</span> (pzByStatus.containsKey(status)) &#123;</span><br><span class="line">            pzByStatus.get(status).add(pz);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;Pizza&gt; newPzList = <span class="keyword">new</span> ArrayList&lt;Pizza&gt;();</span><br><span class="line">            newPzList.add(pz);</span><br><span class="line">            pzByStatus.put(status, newPzList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pzByStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 下面的测试演示了展示了 <code>EnumMap</code> 在某些场景下的强大功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenPizaOrders_whenGroupByStatusCalled_thenCorrectlyGrouped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Pizza&gt; pzList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Pizza pz1 = <span class="keyword">new</span> Pizza();</span><br><span class="line">    pz1.setStatus(Pizza.PizzaStatus.DELIVERED);</span><br><span class="line"> </span><br><span class="line">    Pizza pz2 = <span class="keyword">new</span> Pizza();</span><br><span class="line">    pz2.setStatus(Pizza.PizzaStatus.ORDERED);</span><br><span class="line"> </span><br><span class="line">    Pizza pz3 = <span class="keyword">new</span> Pizza();</span><br><span class="line">    pz3.setStatus(Pizza.PizzaStatus.ORDERED);</span><br><span class="line"> </span><br><span class="line">    Pizza pz4 = <span class="keyword">new</span> Pizza();</span><br><span class="line">    pz4.setStatus(Pizza.PizzaStatus.READY);</span><br><span class="line"> </span><br><span class="line">    pzList.add(pz1);</span><br><span class="line">    pzList.add(pz2);</span><br><span class="line">    pzList.add(pz3);</span><br><span class="line">    pzList.add(pz4);</span><br><span class="line"> </span><br><span class="line">    EnumMap&lt;Pizza.PizzaStatus,List&lt;Pizza&gt;&gt; map = Pizza.groupPizzaByStatus(pzList);</span><br><span class="line">    assertTrue(map.get(Pizza.PizzaStatus.DELIVERED).size() == <span class="number">1</span>);</span><br><span class="line">    assertTrue(map.get(Pizza.PizzaStatus.ORDERED).size() == <span class="number">2</span>);</span><br><span class="line">    assertTrue(map.get(Pizza.PizzaStatus.READY).size() == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-通过枚举实现一些设计模式"><a href="#7-通过枚举实现一些设计模式" class="headerlink" title="7. 通过枚举实现一些设计模式"></a>7. 通过枚举实现一些设计模式</h2><h3 id="7-1-单例模式"><a href="#7-1-单例模式" class="headerlink" title="7.1 单例模式"></a>7.1 单例模式</h3><p>通常，使用类实现 Singleton 模式并非易事，枚举提供了一种实现单例的简便方法。</p><p>《Effective Java 》和《Java与模式》都非常推荐这种方式，使用这种方式方式实现枚举可以有什么好处呢？</p><p>《Effective Java》</p><blockquote><p>这种方法在功能上与公有域方法相近，但是它更加简洁，无偿提供了序列化机制，绝对防止多次实例化，即使是在面对复杂序列化或者反射攻击的时候。虽然这种方法还没有广泛采用，但是单元素的枚举类型已经成为实现 Singleton的最佳方法。 —-《Effective Java 中文版 第二版》</p></blockquote><p>《Java与模式》</p><blockquote><p> 《Java与模式》中，作者这样写道，使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。</p></blockquote><p>下面的代码段显示了如何使用枚举实现单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> PizzaDeliverySystemConfiguration &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    PizzaDeliverySystemConfiguration() &#123;</span><br><span class="line">        <span class="comment">// Initialization configuration which involves</span></span><br><span class="line">        <span class="comment">// overriding defaults like delivery strategy</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> PizzaDeliveryStrategy deliveryStrategy = PizzaDeliveryStrategy.NORMAL;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PizzaDeliverySystemConfiguration <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> PizzaDeliveryStrategy <span class="title">getDeliveryStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deliveryStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何使用呢？请看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PizzaDeliveryStrategy deliveryStrategy = PizzaDeliverySystemConfiguration.getInstance().getDeliveryStrategy();</span><br></pre></td></tr></table></figure><p>通过 <code>PizzaDeliverySystemConfiguration.getInstance()</code> 获取的就是单例的 <code>PizzaDeliverySystemConfiguration</code></p><h3 id="7-2-策略模式"><a href="#7-2-策略模式" class="headerlink" title="7.2 策略模式"></a>7.2 策略模式</h3><p>通常，策略模式由不同类实现同一个接口来实现的。</p><p> 这也就意味着添加新策略意味着添加新的实现类。使用枚举，可以轻松完成此任务，添加新的实现意味着只定义具有某个实现的另一个实例。</p><p>下面的代码段显示了如何使用枚举实现策略模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> PizzaDeliveryStrategy &#123;</span><br><span class="line">    EXPRESS &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliver</span><span class="params">(Pizza pz)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Pizza will be delivered in express mode"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    NORMAL &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliver</span><span class="params">(Pizza pz)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Pizza will be delivered in normal mode"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">deliver</span><span class="params">(Pizza pz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给 <code>Pizza</code>增加下面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDeliverable()) &#123;</span><br><span class="line">        PizzaDeliverySystemConfiguration.getInstance().getDeliveryStrategy()</span><br><span class="line">          .deliver(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.setStatus(PizzaStatus.DELIVERED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何使用呢？请看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenPizaOrder_whenDelivered_thenPizzaGetsDeliveredAndStatusChanges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Pizza pz = <span class="keyword">new</span> Pizza();</span><br><span class="line">    pz.setStatus(Pizza.PizzaStatus.READY);</span><br><span class="line">    pz.deliver();</span><br><span class="line">    assertTrue(pz.getStatus() == Pizza.PizzaStatus.DELIVERED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-Java-8-与枚举"><a href="#8-Java-8-与枚举" class="headerlink" title="8. Java 8 与枚举"></a>8. Java 8 与枚举</h2><p>Pizza 类可以用Java 8重写，您可以看到方法 lambda 和Stream API如何使 <code>getAllUndeliveredPizzas（）</code>和<code>groupPizzaByStatus（）</code>方法变得如此简洁：</p><p><code>getAllUndeliveredPizzas（）</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Pizza&gt; <span class="title">getAllUndeliveredPizzas</span><span class="params">(List&lt;Pizza&gt; input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> input.stream().filter(</span><br><span class="line">      (s) -&gt; !deliveredPizzaStatuses.contains(s.getStatus()))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>groupPizzaByStatus（）</code> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> EnumMap&lt;PizzaStatus, List&lt;Pizza&gt;&gt; </span><br><span class="line">  groupPizzaByStatus(List&lt;Pizza&gt; pzList) &#123;</span><br><span class="line">    EnumMap&lt;PizzaStatus, List&lt;Pizza&gt;&gt; map = pzList.stream().collect(</span><br><span class="line">      Collectors.groupingBy(Pizza::getStatus,</span><br><span class="line">      () -&gt; <span class="keyword">new</span> EnumMap&lt;&gt;(PizzaStatus<span class="class">.<span class="keyword">class</span>), <span class="title">Collectors</span>.<span class="title">toList</span>()))</span>;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-Enum-类型的-JSON-表现形式"><a href="#9-Enum-类型的-JSON-表现形式" class="headerlink" title="9. Enum 类型的 JSON 表现形式"></a>9. Enum 类型的 JSON 表现形式</h2><p>使用Jackson库，可以将枚举类型的JSON表示为POJO。下面的代码段显示了可以用于同一目的的Jackson批注：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat</span>(shape = JsonFormat.Shape.OBJECT)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> PizzaStatus &#123;</span><br><span class="line">    ORDERED (<span class="number">5</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOrdered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    READY (<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DELIVERED (<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDelivered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeToDelivery;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOrdered</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReady</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDelivered</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"timeToDelivery"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTimeToDelivery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeToDelivery;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PizzaStatus</span> <span class="params">(<span class="keyword">int</span> timeToDelivery)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timeToDelivery = timeToDelivery;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以按如下方式使用 <code>Pizza</code> 和 <code>PizzaStatus</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pizza pz = <span class="keyword">new</span> Pizza();</span><br><span class="line">pz.setStatus(Pizza.PizzaStatus.READY);</span><br><span class="line">System.out.println(Pizza.getJsonString(pz));</span><br></pre></td></tr></table></figure><p>生成 Pizza 状态以以下JSON展示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"status"</span> : &#123;</span><br><span class="line">    <span class="attr">"timeToDelivery"</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"ready"</span> : <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"ordered"</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"delivered"</span> : <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"deliverable"</span> : <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关枚举类型的JSON序列化/反序列化（包括自定义）的更多信息，请参阅<a href="https://www.baeldung.com/jackson-serialize-enums" target="_blank" rel="noopener">Jackson-将枚举序列化为JSON对象。</a></p><h2 id="10-总结"><a href="#10-总结" class="headerlink" title="10.总结"></a>10.总结</h2><p>本文我们讨论了Java枚举类型，从基础知识到高级应用以及实际应用场景，让我们感受到枚举的强大功能。</p><h2 id="11-补充"><a href="#11-补充" class="headerlink" title="11. 补充"></a>11. 补充</h2><p>我们在上面讲到了，我们可以通过在枚举类型中定义属性,方法和构造函数让它变得更加强大。</p><p>下面我通过一个实际的例子展示一下，当我们调用短信验证码的时候可能有几种不同的用途，我们在下面这样定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> PinType &#123;</span><br><span class="line"></span><br><span class="line">    REGISTER(<span class="number">100000</span>, <span class="string">"注册使用"</span>),</span><br><span class="line">    FORGET_PASSWORD(<span class="number">100001</span>, <span class="string">"忘记密码使用"</span>),</span><br><span class="line">    UPDATE_PHONE_NUMBER(<span class="number">100002</span>, <span class="string">"更新手机号码使用"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">    PinType(<span class="keyword">int</span> code, String message) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"PinType&#123;"</span> +</span><br><span class="line">                <span class="string">"code="</span> + code +</span><br><span class="line">                <span class="string">", message='"</span> + message + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际使用：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(PinType.FORGET_PASSWORD.getCode());</span><br><span class="line">System.out.println(PinType.FORGET_PASSWORD.getMessage());</span><br><span class="line">System.out.println(PinType.FORGET_PASSWORD.toString());</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100001</span></span><br><span class="line">忘记密码使用</span><br><span class="line">PinType&#123;code=<span class="number">100001</span>, message=<span class="string">'忘记密码使用'</span>&#125;</span><br></pre></td></tr></table></figure><p>这样的话，在实际使用起来就会非常灵活方便！</p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射机制介绍</title>
      <link href="/posts/6f737fa3/"/>
      <url>/posts/6f737fa3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><h3 id="反射机制介绍"><a href="#反射机制介绍" class="headerlink" title="反射机制介绍"></a>反射机制介绍</h3><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。</p><h3 id="获取-Class-对象的两种方式"><a href="#获取-Class-对象的两种方式" class="headerlink" title="获取 Class 对象的两种方式"></a>获取 Class 对象的两种方式</h3><p>如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了两种方式获取 Class 对象:</p><p>1.知道具体类的情况下可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class alunbarClass = TargetObject<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure><p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象</p><p>2.通过 <code>Class.forName()</code>传入类的路径获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class alunbarClass1 = Class.forName(<span class="string">"cn.javaguide.TargetObject"</span>);</span><br></pre></td></tr></table></figure><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><p><strong>简单用代码演示一下反射的一些操作!</strong></p><p>1.创建一个我们要使用反射操作的类 <code>TargetObject</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javaguide;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TargetObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        value = <span class="string">"JavaGuide"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publicMethod</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I love "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"value is "</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.使用反射操作这个类的方法以及参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javaguide;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取TargetObject类的Class对象并且创建TargetObject类实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; tagetClass = Class.forName(<span class="string">"cn.javaguide.TargetObject"</span>);</span><br><span class="line">        TargetObject targetObject = (TargetObject) tagetClass.newInstance();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取所有类中所有定义的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method[] methods = tagetClass.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取指定方法并调用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method publicMethod = tagetClass.getDeclaredMethod(<span class="string">"publicMethod"</span>,</span><br><span class="line">                String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        publicMethod.invoke(targetObject, <span class="string">"JavaGuide"</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取指定参数并对参数进行修改</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Field field = tagetClass.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">//为了对类中的参数进行修改我们取消安全检查</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(targetObject, <span class="string">"JavaGuide"</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用 private 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method privateMethod = tagetClass.getDeclaredMethod(<span class="string">"privateMethod"</span>);</span><br><span class="line">        <span class="comment">//为了调用private方法我们取消安全检查</span></span><br><span class="line">        privateMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        privateMethod.invoke(targetObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">publicMethod</span><br><span class="line">privateMethod</span><br><span class="line">I love JavaGuide</span><br><span class="line">value is JavaGuide</span><br></pre></td></tr></table></figure><p><strong>注意</strong> : 有读者提到上面代码运行会抛出 <code>ClassNotFoundException</code> 异常,具体原因是你没有下面把这段代码的包名替换成自己创建的 <code>TargetObject</code> 所在的包 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; tagetClass = Class.forName(<span class="string">"cn.javaguide.TargetObject"</span>);</span><br></pre></td></tr></table></figure><h3 id="静态编译和动态编译"><a href="#静态编译和动态编译" class="headerlink" title="静态编译和动态编译"></a>静态编译和动态编译</h3><ul><li><strong>静态编译：</strong> 在编译时确定类型，绑定对象</li><li><strong>动态编译：</strong> 运行时确定类型，绑定对象</li></ul><h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><ul><li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li><li><strong>缺点：</strong> 1,性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多。2,安全问题，让我们可以动态操作改变类的属性同时也增加了类的安全隐患。</li></ul><h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p><strong>反射是框架设计的灵魂。</strong></p><p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p><p>举例：</p><ol><li>我们在使用 JDBC 连接数据库时使用 <code>Class.forName()</code>通过反射加载数据库的驱动程序；</li><li>Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；</li><li>动态配置实例的属性；</li><li>……</li></ol><p><strong>推荐阅读：</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/80519709" target="_blank" rel="noopener">Java反射使用总结</a></li><li><a href="https://segmentfault.com/a/1190000010162647?utm_source=tuicool&utm_medium=referral" target="_blank" rel="noopener">Reflection：Java 反射机制的应用场景</a></li><li><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078" target="_blank" rel="noopener">Java 基础之—反射（非常重要）</a></li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型的实际应用</title>
      <link href="/posts/e9204773/"/>
      <url>/posts/e9204773/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><h3 id="0-0-1-泛型的实际应用-实现最小值函数"><a href="#0-0-1-泛型的实际应用-实现最小值函数" class="headerlink" title="0.0.1. 泛型的实际应用:实现最小值函数"></a>0.0.1. 泛型的实际应用:实现最小值函数</h3><p>自己设计一个泛型的获取数组最小值的函数.并且这个方法只能接受Number的子类并且实现了Comparable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：Number并没有实现Comparable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T extends Number &amp; Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (values == <span class="keyword">null</span> || values.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    T min = values[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min.compareTo(values[i]) &gt; <span class="number">0</span>) min = values[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> minInteger = min(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);<span class="comment">//result:1</span></span><br><span class="line"><span class="keyword">double</span> minDouble = min(<span class="keyword">new</span> Double[]&#123;<span class="number">1.2</span>, <span class="number">2.2</span>, -<span class="number">1</span>d&#125;);<span class="comment">//result:-1d</span></span><br><span class="line">String typeError = min(<span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>,<span class="string">"3"</span>&#125;);<span class="comment">//报错</span></span><br></pre></td></tr></table></figure><h3 id="0-0-2-使用数组实现栈"><a href="#0-0-2-使用数组实现栈" class="headerlink" title="0.0.2. 使用数组实现栈"></a>0.0.2. 使用数组实现栈</h3><p><strong>自己实现一个栈，要求这个栈具有<code>push()</code>、<code>pop()</code>（返回栈顶元素并出栈）、<code>peek()</code> （返回栈顶元素不出栈）、<code>isEmpty()</code>、<code>size()</code>这些基本的方法。</strong></p><p>提示：每次入栈之前先判断栈的容量是否够用，如果不够用就用<code>Arrays.copyOf()</code>进行扩容；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] storage;<span class="comment">//存放栈中元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;<span class="comment">//栈的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;<span class="comment">//栈中元素数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GROW_FACTOR = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不带初始容量的构造方法。默认容量为8</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">this</span>.storage=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带初始容量的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Capacity too small."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.capacity = initialCapacity;</span><br><span class="line">        <span class="keyword">this</span>.storage = <span class="keyword">new</span> <span class="keyword">int</span>[initialCapacity];</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == capacity) &#123;</span><br><span class="line">            ensureCapacity();</span><br><span class="line">        &#125;</span><br><span class="line">        storage[count++] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保容量大小</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = capacity * GROW_FACTOR;</span><br><span class="line">        storage = Arrays.copyOf(storage, newCapacity);</span><br><span class="line">        capacity = newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回栈顶元素并出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Stack is empty."</span>);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> storage[count];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回栈顶元素不出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Stack is empty."</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> storage[count-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回栈中元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MyStack myStack = <span class="keyword">new</span> MyStack(<span class="number">3</span>);</span><br><span class="line">myStack.push(<span class="number">1</span>);</span><br><span class="line">myStack.push(<span class="number">2</span>);</span><br><span class="line">myStack.push(<span class="number">3</span>);</span><br><span class="line">myStack.push(<span class="number">4</span>);</span><br><span class="line">myStack.push(<span class="number">5</span>);</span><br><span class="line">myStack.push(<span class="number">6</span>);</span><br><span class="line">myStack.push(<span class="number">7</span>);</span><br><span class="line">myStack.push(<span class="number">8</span>);</span><br><span class="line">System.out.println(myStack.peek());<span class="comment">//8</span></span><br><span class="line">System.out.println(myStack.size());<span class="comment">//8</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    System.out.println(myStack.pop());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(myStack.isEmpty());<span class="comment">//true</span></span><br><span class="line">myStack.pop();<span class="comment">//报错：java.lang.IllegalArgumentException: Stack is empty.</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程相关</title>
      <link href="/posts/40f42b48/"/>
      <url>/posts/40f42b48/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><p>最近被读者问到“不用LinkedHashMap的话，如何实现一个线程安全的 LRU 缓存？网上的代码太杂太乱，Guide哥哥能不能帮忙写一个？”。</p><p><em>划重点，手写一个 LRU 缓存在面试中还是挺常见的！</em></p><p>很多人就会问了：“网上已经有这么多现成的缓存了！为什么面试官还要我们自己实现一个呢？” 。咳咳咳，当然是为了面试需要。哈哈！开个玩笑，我个人觉得更多地是为了学习吧！今天Guide哥教大家：</p><ol><li>实现一个线程安全的 LRU 缓存</li><li>实现一个线程安全并且带有过期时间的 LRU 缓存</li></ol><p>考虑到了线程安全性我们使用了 <code>ConcurrentHashMap</code> 、<code>ConcurrentLinkedQueue</code> 这两个线程安全的集合。另外，还用到 <code>ReadWriteLock</code>（读写锁）。为了实现带有过期时间的缓存，我们用到了 <code>ScheduledExecutorService</code>来做定时任务执行。</p><p>如果有任何不对或者需要完善的地方，请帮忙指出！</p><h3 id="1-LRU-缓存介绍"><a href="#1-LRU-缓存介绍" class="headerlink" title="1. LRU 缓存介绍"></a>1. LRU 缓存介绍</h3><p><strong>LRU (Least Recently Used,最近最少使用)是一种缓存淘汰策略。</strong> </p><p>LRU缓存指的是当缓存大小已达到最大分配容量的时候，如果再要去缓存新的对象数据的话，就需要将缓存中最近访问最少的对象删除掉以便给新来的数据腾出空间。</p><h3 id="2-ConcurrentLinkedQueue简单介绍"><a href="#2-ConcurrentLinkedQueue简单介绍" class="headerlink" title="2. ConcurrentLinkedQueue简单介绍"></a>2. ConcurrentLinkedQueue简单介绍</h3><p><strong>ConcurrentLinkedQueue是一个基于单向链表的无界无锁线程安全的队列，适合在高并发环境下使用，效率比较高。</strong> 我们在使用的时候，可以就把它理解为我们经常接触的数据结构——队列，不过是增加了多线程下的安全性保证罢了。<strong>和普通队列一样，它也是按照先进先出(FIFO)的规则对接点进行排序。</strong> 另外，队列元素中不可以放置null元素。</p><p><code>ConcurrentLinkedQueue</code> 整个继承关系如下图所示：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="./../../../media/pictures/java/my-lru-cache/ConcurrentLinkedQueue-Diagram.png" alt=""></p><p><code>ConcurrentLinkedQueue中</code>最主要的两个方法是：<code>offer(value)</code>和<code>poll()</code>，分别实现队列的两个重要的操作：入队和出队(<code>offer(value)</code>等价于 <code>add(value)</code>)。</p><p>我们添加一个元素到队列的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%8D%95%E9%93%BE%E8%A1%A82.png" alt="单链表"></p><p>利用<code>ConcurrentLinkedQueue</code>队列先进先出的特性，每当我们 <code>put</code>/<code>get</code>(缓存被使用)元素的时候，我们就将这个元素存放在队列尾部，这样就能保证队列头部的元素是最近最少使用的。</p><h3 id="3-ReadWriteLock简单介绍"><a href="#3-ReadWriteLock简单介绍" class="headerlink" title="3. ReadWriteLock简单介绍"></a>3. ReadWriteLock简单介绍</h3><p><code>ReadWriteLock</code> 是一个接口，位于<code>java.util.concurrent.locks</code>包下，里面只有两个方法分别返回读锁和写锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回读锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReentrantReadWriteLock</code> 是<code>ReadWriteLock</code>接口的具体实现类。</p><p><strong>读写锁还是比较适合缓存这种读多写少的场景。读写锁可以保证多个线程和同时读取，但是只有一个线程可以写入。</strong></p><p>读写锁的特点是：写锁和写锁互斥，读锁和写锁互斥，读锁之间不互斥。也就说：同一时刻只能有一个线程写，但是可以有多个线程<br>读。读写之间是互斥的，两者不能同时发生（当进行写操作时，同一时刻其他线程的读操作会被阻塞；当进行读操作时，同一时刻所有线程的写操作会被阻塞）。</p><p>另外，<strong>同一个线程持有写锁时是可以申请读锁，但是持有读锁的情况下不可以申请写锁。</strong></p><h3 id="4-ScheduledExecutorService-简单介绍"><a href="#4-ScheduledExecutorService-简单介绍" class="headerlink" title="4. ScheduledExecutorService 简单介绍"></a>4. ScheduledExecutorService 简单介绍</h3><p><code>ScheduledExecutorService</code> 是一个接口，<code>ScheduledThreadPoolExecutor</code> 是其主要实现类。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="./../../../media/pictures/java/my-lru-cache/ScheduledThreadPoolExecutor-diagram.png" alt=""></p><p><strong><code>ScheduledThreadPoolExecutor</code> 主要用来在给定的延迟后运行任务，或者定期执行任务。</strong> 这个在实际项目用到的比较少，因为有其他方案选择比如<code>quartz</code>。但是，在一些需求比较简单的场景下还是非常有用的！</p><p><strong><code>ScheduledThreadPoolExecutor</code> 使用的任务队列 <code>DelayQueue</code> 封装了一个 <code>PriorityQueue</code>，<code>PriorityQueue</code> 会对队列中的任务进行排序，执行所需时间短的放在前面先被执行，如果执行所需时间相同则先提交的任务将被先执行。</strong></p><h3 id="5-徒手撸一个线程安全的-LRU-缓存"><a href="#5-徒手撸一个线程安全的-LRU-缓存" class="headerlink" title="5. 徒手撸一个线程安全的 LRU 缓存"></a>5. 徒手撸一个线程安全的 LRU 缓存</h3><h4 id="5-1-实现方法"><a href="#5-1-实现方法" class="headerlink" title="5.1. 实现方法"></a>5.1. 实现方法</h4><p> <code>ConcurrentHashMap</code> + <code>ConcurrentLinkedQueue</code> +<code>ReadWriteLock</code></p><h4 id="5-2-原理"><a href="#5-2-原理" class="headerlink" title="5.2. 原理"></a>5.2. 原理</h4><p><code>ConcurrentHashMap</code> 是线程安全的Map，我们可以利用它缓存 key,value形式的数据。<code>ConcurrentLinkedQueue</code>是一个线程安全的基于链表的队列（先进先出），我们可以用它来维护 key 。每当我们put/get(缓存被使用)元素的时候，我们就将这个元素对应的 key 存放在队列尾部，这样就能保证队列头部的元素是最近最少使用的。当我们的缓存容量不够的时候，我们直接移除队列头部对应的key以及这个key对应的缓存即可！</p><p>另外，我们用到了<code>ReadWriteLock</code>(读写锁)来保证线程安全。</p><h4 id="5-3-put方法具体流程分析"><a href="#5-3-put方法具体流程分析" class="headerlink" title="5.3. put方法具体流程分析"></a>5.3. put方法具体流程分析</h4><p>为了方便大家理解，我将代码中比较重要的 <code>put(key,value)</code>方法的原理图画了出来，如下图所示：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="./../../../media/pictures/java/my-lru-cache/MyLRUCachePut.png" alt=""></p><h4 id="5-4-源码"><a href="#5-4-源码" class="headerlink" title="5.4. 源码"></a>5.4. 源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 使用 ConcurrentHashMap+ConcurrentLinkedQueue+ReadWriteLock实现线程安全的 LRU 缓存</span></span><br><span class="line"><span class="comment"> * 这里只是为了学习使用，本地缓存推荐使用 Guava 自带的,使用 Spring 的话，推荐使用Spring Cache</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLruCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存的最大容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;K, V&gt; cacheMap;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentLinkedQueue&lt;K&gt; keys;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> Lock writeLock = readWriteLock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> Lock readLock = readWriteLock.readLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLruCache</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal max capacity: "</span> + maxCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.maxCapacity = maxCapacity;</span><br><span class="line">        cacheMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(maxCapacity);</span><br><span class="line">        keys = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加写锁</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.key是否存在于当前缓存</span></span><br><span class="line">            <span class="keyword">if</span> (cacheMap.containsKey(key)) &#123;</span><br><span class="line">                moveToTailOfQueue(key);</span><br><span class="line">                cacheMap.put(key, value);</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.是否超出缓存容量，超出的话就移除队列头部的元素以及其对应的缓存</span></span><br><span class="line">            <span class="keyword">if</span> (cacheMap.size() == maxCapacity) &#123;</span><br><span class="line">                System.out.println(<span class="string">"maxCapacity of cache reached"</span>);</span><br><span class="line">                removeOldestKey();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.key不存在于当前缓存。将key添加到队列的尾部并且缓存key及其对应的元素</span></span><br><span class="line">            keys.add(key);</span><br><span class="line">            cacheMap.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加读锁</span></span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//key是否存在于当前缓存</span></span><br><span class="line">            <span class="keyword">if</span> (cacheMap.containsKey(key)) &#123;</span><br><span class="line">                <span class="comment">// 存在的话就将key移动到队列的尾部</span></span><br><span class="line">                moveToTailOfQueue(key);</span><br><span class="line">                <span class="keyword">return</span> cacheMap.get(key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不存在于当前缓存中就返回Null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//key是否存在于当前缓存</span></span><br><span class="line">            <span class="keyword">if</span> (cacheMap.containsKey(key)) &#123;</span><br><span class="line">                <span class="comment">// 存在移除队列和Map中对应的Key</span></span><br><span class="line">                keys.remove(key);</span><br><span class="line">                <span class="keyword">return</span> cacheMap.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不存在于当前缓存中就返回Null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将元素添加到队列的尾部(put/get的时候执行)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToTailOfQueue</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        keys.remove(key);</span><br><span class="line">        keys.add(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除队列头部的元素以及其对应的缓存 (缓存容量已满的时候执行)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeOldestKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        K oldestKey = keys.poll();</span><br><span class="line">        <span class="keyword">if</span> (oldestKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cacheMap.remove(oldestKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cacheMap.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非并发环境测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyLruCache&lt;Integer, String&gt; myLruCache = <span class="keyword">new</span> MyLruCache&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">myLruCache.put(<span class="number">1</span>, <span class="string">"Java"</span>);</span><br><span class="line">System.out.println(myLruCache.get(<span class="number">1</span>));<span class="comment">// Java</span></span><br><span class="line">myLruCache.remove(<span class="number">1</span>);</span><br><span class="line">System.out.println(myLruCache.get(<span class="number">1</span>));<span class="comment">// null</span></span><br><span class="line">myLruCache.put(<span class="number">2</span>, <span class="string">"C++"</span>);</span><br><span class="line">myLruCache.put(<span class="number">3</span>, <span class="string">"Python"</span>);</span><br><span class="line">System.out.println(myLruCache.get(<span class="number">2</span>));<span class="comment">//C++</span></span><br><span class="line">myLruCache.put(<span class="number">4</span>, <span class="string">"C"</span>);</span><br><span class="line">myLruCache.put(<span class="number">5</span>, <span class="string">"PHP"</span>);</span><br><span class="line">System.out.println(myLruCache.get(<span class="number">2</span>));<span class="comment">// C++</span></span><br></pre></td></tr></table></figure><p><strong>并发环境测试：</strong></p><p>我们初始化了一个固定容量为 10 的线程池和count为10的<code>CountDownLatch</code>。我们将1000000次操作分10次添加到线程池，然后我们等待线程池执行完成这10次操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> threadNum = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> batchSize = <span class="number">100000</span>;</span><br><span class="line"><span class="comment">//init cache</span></span><br><span class="line">MyLruCache&lt;String, Integer&gt; myLruCache = <span class="keyword">new</span> MyLruCache&lt;&gt;(batchSize * <span class="number">10</span>);</span><br><span class="line"><span class="comment">//init thread pool with 10 threads</span></span><br><span class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(threadNum);</span><br><span class="line"><span class="comment">//init CountDownLatch with 10 count</span></span><br><span class="line">CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(threadNum);</span><br><span class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; threadNum; t++) &#123;</span><br><span class="line">    fixedThreadPool.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; batchSize; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = atomicInteger.incrementAndGet();</span><br><span class="line">            myLruCache.put(<span class="string">"id"</span> + value, value);</span><br><span class="line">        &#125;</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//wait for 10 threads to complete the task</span></span><br><span class="line">latch.await();</span><br><span class="line">fixedThreadPool.shutdown();</span><br><span class="line">System.out.println(<span class="string">"Cache size:"</span> + myLruCache.size());<span class="comment">//Cache size:1000000</span></span><br><span class="line"><span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> duration = endTime - startTime;</span><br><span class="line">System.out.println(String.format(<span class="string">"Time cost：%dms"</span>, duration));<span class="comment">//Time cost：511ms</span></span><br></pre></td></tr></table></figure><h3 id="6-实现一个线程安全并且带有过期时间的-LRU-缓存"><a href="#6-实现一个线程安全并且带有过期时间的-LRU-缓存" class="headerlink" title="6. 实现一个线程安全并且带有过期时间的 LRU 缓存"></a>6. 实现一个线程安全并且带有过期时间的 LRU 缓存</h3><p>实际上就是在我们上面时间的LRU缓存的基础上加上一个定时任务去删除缓存，单纯利用 JDK 提供的类，我们实现定时任务的方式有很多种：</p><ol><li><code>Timer</code> :不被推荐，多线程会存在问题。</li><li><code>ScheduledExecutorService</code> ：定时器线程池，可以用来替代 <code>Timer</code></li><li><code>DelayQueue</code> ：延时队列</li><li><code>quartz</code> ：一个很火的开源任务调度框架，很多其他框架都是基于 <code>quartz</code> 开发的，比如当当网的<code>elastic-job</code>就是基于<code>quartz</code>二次开发之后的分布式调度解决方案 </li><li>……</li></ol><p>最终我们选择了  <code>ScheduledExecutorService</code>，主要原因是它易用（基于<code>DelayQueue</code>做了很多封装）并且基本能满足我们的大部分需求。</p><p>我们在我们上面实现的线程安全的 LRU 缓存基础上，简单稍作修改即可！我们增加了一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeAfterExpireTime</span><span class="params">(K key, <span class="keyword">long</span> expireTime)</span> </span>&#123;</span><br><span class="line">    scheduledExecutorService.schedule(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//过期后清除该键值对</span></span><br><span class="line">        cacheMap.remove(key);</span><br><span class="line">        keys.remove(key);</span><br><span class="line">    &#125;, expireTime, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们put元素的时候，如果通过这个方法就能直接设置过期时间。</p><p><strong>完整源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 使用 ConcurrentHashMap+ConcurrentLinkedQueue+ReadWriteLock+ScheduledExecutorService实现线程安全的 LRU 缓存</span></span><br><span class="line"><span class="comment"> * 这里只是为了学习使用，本地缓存推荐使用 Guava 自带的，使用 Spring 的话，推荐使用Spring Cache</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLruCacheWithExpireTime</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存的最大容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;K, V&gt; cacheMap;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentLinkedQueue&lt;K&gt; keys;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> Lock writeLock = readWriteLock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> Lock readLock = readWriteLock.readLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ScheduledExecutorService scheduledExecutorService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLruCacheWithExpireTime</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal max capacity: "</span> + maxCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.maxCapacity = maxCapacity;</span><br><span class="line">        cacheMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(maxCapacity);</span><br><span class="line">        keys = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">        scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value, <span class="keyword">long</span> expireTime)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加写锁</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.key是否存在于当前缓存</span></span><br><span class="line">            <span class="keyword">if</span> (cacheMap.containsKey(key)) &#123;</span><br><span class="line">                moveToTailOfQueue(key);</span><br><span class="line">                cacheMap.put(key, value);</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.是否超出缓存容量，超出的话就移除队列头部的元素以及其对应的缓存</span></span><br><span class="line">            <span class="keyword">if</span> (cacheMap.size() == maxCapacity) &#123;</span><br><span class="line">                System.out.println(<span class="string">"maxCapacity of cache reached"</span>);</span><br><span class="line">                removeOldestKey();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.key不存在于当前缓存。将key添加到队列的尾部并且缓存key及其对应的元素</span></span><br><span class="line">            keys.add(key);</span><br><span class="line">            cacheMap.put(key, value);</span><br><span class="line">            <span class="keyword">if</span> (expireTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                removeAfterExpireTime(key, expireTime);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加读锁</span></span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//key是否存在于当前缓存</span></span><br><span class="line">            <span class="keyword">if</span> (cacheMap.containsKey(key)) &#123;</span><br><span class="line">                <span class="comment">// 存在的话就将key移动到队列的尾部</span></span><br><span class="line">                moveToTailOfQueue(key);</span><br><span class="line">                <span class="keyword">return</span> cacheMap.get(key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不存在于当前缓存中就返回Null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//key是否存在于当前缓存</span></span><br><span class="line">            <span class="keyword">if</span> (cacheMap.containsKey(key)) &#123;</span><br><span class="line">                <span class="comment">// 存在移除队列和Map中对应的Key</span></span><br><span class="line">                keys.remove(key);</span><br><span class="line">                <span class="keyword">return</span> cacheMap.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不存在于当前缓存中就返回Null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将元素添加到队列的尾部(put/get的时候执行)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToTailOfQueue</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        keys.remove(key);</span><br><span class="line">        keys.add(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除队列头部的元素以及其对应的缓存 (缓存容量已满的时候执行)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeOldestKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        K oldestKey = keys.poll();</span><br><span class="line">        <span class="keyword">if</span> (oldestKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cacheMap.remove(oldestKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeAfterExpireTime</span><span class="params">(K key, <span class="keyword">long</span> expireTime)</span> </span>&#123;</span><br><span class="line">        scheduledExecutorService.schedule(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//过期后清除该键值对</span></span><br><span class="line">            cacheMap.remove(key);</span><br><span class="line">            keys.remove(key);</span><br><span class="line">        &#125;, expireTime, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cacheMap.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试效果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyLruCacheWithExpireTime&lt;Integer,String&gt; myLruCache = <span class="keyword">new</span> MyLruCacheWithExpireTime&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">myLruCache.put(<span class="number">1</span>,<span class="string">"Java"</span>,<span class="number">3000</span>);</span><br><span class="line">myLruCache.put(<span class="number">2</span>,<span class="string">"C++"</span>,<span class="number">3000</span>);</span><br><span class="line">myLruCache.put(<span class="number">3</span>,<span class="string">"Python"</span>,<span class="number">1500</span>);</span><br><span class="line">System.out.println(myLruCache.size());<span class="comment">//3</span></span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">System.out.println(myLruCache.size());<span class="comment">//2</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdk8-jdk14的新特性</title>
      <link href="/posts/9b157072/"/>
      <url>/posts/9b157072/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><p>大家好，我是Guide哥！这篇文章来自读者的投稿，经过了两次较大的改动，两周的完善终于完成。Java 8新特性见这里：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484744&idx=1&sn=9db31dca13d327678845054af75efb74&chksm=cea24a83f9d5c3956f4feb9956b068624ab2fdd6c4a75fe52d5df5dca356a016577301399548&token=1082669959&lang=zh_CN&scene=21#wechat_redirect" target="_blank" rel="noopener">Java8新特性最佳指南</a> 。</p><p><em>Guide 哥：别人家的特性都用了几年了，我 Java 才出来，哈哈！真实！</em></p><h2 id="Java9"><a href="#Java9" class="headerlink" title="Java9"></a>Java9</h2><p>发布于 2017 年 9 月 21 日 。作为 Java8 之后 3 年半才发布的新版本，Java 9 带 来了很多重大的变化其中最重要的改动是 Java 平台模块系统的引入,其他还有诸如集合、Stream 流</p><h3 id="Java-平台模块系统"><a href="#Java-平台模块系统" class="headerlink" title="Java 平台模块系统"></a>Java 平台模块系统</h3><p>Java 平台模块系统，也就是 Project Jigsaw，把模块化开发实践引入到了 Java 平台中。在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 jlink 工具，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。</p><p>Java 9 模块的重要特征是在其工件（artifact）的根目录中包含了一个描述模块的 module-info.class 文 件。 工件的格式可以是传统的 JAR 文件或是 Java 9 新增的 JMOD 文件。</p><h3 id="Jshell"><a href="#Jshell" class="headerlink" title="Jshell"></a>Jshell</h3><p>jshell 是 Java 9 新增的一个实用工具。为 Java 提供了类似于 Python 的实时命令行交互工具。</p><p>在 Jshell 中可以直接输入表达式并查看其执行结果</p><h3 id="集合、Stream-和-Optional"><a href="#集合、Stream-和-Optional" class="headerlink" title="集合、Stream 和 Optional"></a>集合、Stream 和 Optional</h3><ul><li>增加 了 <code>List.of()</code>、<code>Set.of()</code>、<code>Map.of()</code> 和 <code>Map.ofEntries()</code>等工厂方法来创建不可变集合，比如<code>List.of(&quot;Java&quot;, &quot;C++&quot;);</code>、<code>Map.of(&quot;Java&quot;, 1, &quot;C++&quot;, 2)</code>;（这部分内容有点参考 Guava 的味道）</li><li><code>Stream</code> 中增加了新的方法 <code>ofNullable</code>、<code>dropWhile</code>、<code>takeWhile</code> 和 <code>iterate</code> 方法。<code>Collectors</code> 中增加了新的方法 <code>filtering</code> 和 <code>flatMapping</code></li><li><code>Optional</code> 类中新增了 <code>ifPresentOrElse</code>、<code>or</code> 和 <code>stream</code> 等方法</li></ul><h3 id="进程-API"><a href="#进程-API" class="headerlink" title="进程 API"></a>进程 API</h3><p>Java 9 增加了 <code>ProcessHandle</code> 接口，可以对原生进程进行管理，尤其适合于管理长时间运行的进程</p><h3 id="平台日志-API-和服务"><a href="#平台日志-API-和服务" class="headerlink" title="平台日志 API 和服务"></a>平台日志 API 和服务</h3><p>Java 9 允许为 JDK 和应用配置同样的日志实现。新增了 <code>System.LoggerFinder</code> 用来管理 JDK 使 用的日志记录器实现。JVM 在运行时只有一个系统范围的 <code>LoggerFinder</code> 实例。</p><p>我们可以通过添加自己的 <code>System.LoggerFinder</code> 实现来让 JDK 和应用使用 SLF4J 等其他日志记录框架。</p><h3 id="反应式流-（-Reactive-Streams-）"><a href="#反应式流-（-Reactive-Streams-）" class="headerlink" title="反应式流 （ Reactive Streams ）"></a>反应式流 （ Reactive Streams ）</h3><ul><li>在 Java9 中的 <code>java.util.concurrent.Flow</code> 类中新增了反应式流规范的核心接口</li><li>Flow 中包含了 <code>Flow.Publisher</code>、<code>Flow.Subscriber</code>、<code>Flow.Subscription</code> 和 <code>Flow.Processor</code> 等 4 个核心接口。Java 9 还提供了<code>SubmissionPublisher</code> 作为<code>Flow.Publisher</code> 的一个实现。</li></ul><h3 id="变量句柄"><a href="#变量句柄" class="headerlink" title="变量句柄"></a>变量句柄</h3><ul><li>变量句柄是一个变量或一组变量的引用，包括静态域，非静态域，数组元素和堆外数据结构中的组成部分等</li><li>变量句柄的含义类似于已有的方法句柄<code>MethodHandle</code></li><li>由 Java 类<code>java.lang.invoke.VarHandle</code> 来表示，可以使用类 <code>java.lang.invoke.MethodHandles.Lookup</code> 中的静态工厂方法来创建 <code>VarHandle</code> 对 象</li></ul><h3 id="改进方法句柄（Method-Handle）"><a href="#改进方法句柄（Method-Handle）" class="headerlink" title="改进方法句柄（Method Handle）"></a>改进方法句柄（Method Handle）</h3><ul><li>方法句柄从 Java7 开始引入，Java9 在类<code>java.lang.invoke.MethodHandles</code> 中新增了更多的静态方法来创建不同类型的方法句柄</li></ul><h3 id="其它新特性"><a href="#其它新特性" class="headerlink" title="其它新特性"></a>其它新特性</h3><ul><li><strong>接口私有方法</strong> ：Java 9 允许在接口中使用私有方法</li><li><strong>try-with-resources 增强</strong> ：在 try-with-resources 语句中可以使用 effectively-final 变量（什么是 effectively-final 变量，见这篇文章 <a href="http://ilkinulas.github.io/programming/java/2016/03/27/effectively-final-java.html" target="_blank" rel="noopener">http://ilkinulas.github.io/programming/java/2016/03/27/effectively-final-java.html</a>）</li><li><strong>类 <code>CompletableFuture</code> 中增加了几个新的方法（<code>completeAsync</code> ，<code>orTimeout</code> 等）</strong></li><li><strong>Nashorn 引擎的增强</strong> ：Nashorn 从 Java8 开始引入的 JavaScript 引擎，Java9 对 Nashorn 做了些增强，实现了一些 ES6 的新特性</li><li><strong>I/O 流的新特性</strong> ：增加了新的方法来读取和复制 InputStream 中包含的数据</li><li><strong>改进应用的安全性能</strong> ：Java 9 新增了 4 个 SHA- 3 哈希算法，SHA3-224、SHA3-256、SHA3-384 和 S HA3-512</li><li>……</li></ul><h2 id="Java10"><a href="#Java10" class="headerlink" title="Java10"></a>Java10</h2><p>发布于 2018 年 3 月 20 日，最知名的特性应该是 var 关键字（局部变量类型推断）的引入了，其他还有垃圾收集器改善、GC 改进、性能提升、线程管控等一批新特性</p><h3 id="var-关键字"><a href="#var-关键字" class="headerlink" title="var 关键字"></a>var 关键字</h3><ul><li><strong>介绍</strong> :提供了 var 关键字声明局部变量：<code>var list = new ArrayList&lt;String&gt;(); // ArrayList&lt;String&gt;</code></li><li><strong>局限性</strong> ：只能用于带有构造器的<strong>局部变量</strong>和 for 循环中</li></ul><p><em>Guide 哥：实际上 Lombok 早就体用了一个类似的关键字，使用它可以简化代码，但是可能会降低程序的易读性、可维护性。一般情况下，我个人都不太推荐使用。</em></p><h3 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h3><p><strong>list，set，map 提供了静态方法<code>copyOf()</code>返回入参集合的一个不可变拷贝（以下为 JDK 的源码）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">copyOf</span><span class="params">(Collection&lt;? extends E&gt; coll)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ImmutableCollections.listCopy(coll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>java.util.stream.Collectors</code>中新增了静态方法，用于将流中的元素收集为不可变的集合</strong></p><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><ul><li>新增了<code>orElseThrow()</code>方法来在没有值时抛出异常</li></ul><h3 id="并行全垃圾回收器-G1"><a href="#并行全垃圾回收器-G1" class="headerlink" title="并行全垃圾回收器 G1"></a>并行全垃圾回收器 G1</h3><p>从 Java9 开始 G1 就了默认的垃圾回收器，G1 是以一种低延时的垃圾回收器来设计的，旨在避免进行 Full GC,但是 Java9 的 G1 的 FullGC 依然是使用单线程去完成标记清除算法,这可能会导致垃圾回收期在无法回收内存的时候触发 Full GC。</p><p>为了最大限度地减少 Full GC 造成的应用停顿的影响，从 Java10 开始，G1 的 FullGC 改为并行的标记清除算法，同时会使用与年轻代回收和混合回收相同的并行工作线程数量，从而减少了 Full GC 的发生，以带来更好的性能提升、更大的吞吐量。</p><h3 id="应用程序类数据共享"><a href="#应用程序类数据共享" class="headerlink" title="应用程序类数据共享"></a>应用程序类数据共享</h3><p>在 Java 5 中就已经引入了类数据共享机制 (Class Data Sharing，简称 CDS)，允许将一组类预处理为共享归档文件，以便在运行时能够进行内存映射以减少 Java 程序的启动时间，当多个 Java 虚拟机（JVM）共享相同的归档文件时，还可以减少动态内存的占用量，同时减少多个虚拟机在同一个物理或虚拟的机器上运行时的资源占用</p><p>Java 10 在现有的 CDS 功能基础上再次拓展，以允许应用类放置在共享存档中。CDS 特性在原来的 bootstrap 类基础之上，扩展加入了应用类的 CDS (Application Class-Data Sharing) 支持。其原理为：在启动时记录加载类的过程，写入到文本文件中，再次启动时直接读取此启动文本并加载。设想如果应用环境没有大的变化，启动速度就会得到提升</p><h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><ul><li><p><strong>线程-局部管控</strong>：Java 10 中线程管控引入 JVM 安全点的概念，将允许在不运行全局 JVM 安全点的情况下实现线程回调，由线程本身或者 JVM 线程来执行，同时保持线程处于阻塞状态，这种方式使得停止单个线程变成可能，而不是只能启用或停止所有线程</p></li><li><p><strong>备用存储装置上的堆分配</strong>：Java 10 中将使得 JVM 能够使用适用于不同类型的存储机制的堆，在可选内存设备上进行堆内存分配</p></li><li><p><strong>统一的垃圾回收接口</strong>：Java 10 中，hotspot/gc 代码实现方面，引入一个干净的 GC 接口，改进不同 GC 源代码的隔离性，多个 GC 之间共享的实现细节代码应该存在于辅助类中。统一垃圾回收接口的主要原因是：让垃圾回收器（GC）这部分代码更加整洁，便于新人上手开发，便于后续排查相关问题。</p></li></ul><h2 id="Java11"><a href="#Java11" class="headerlink" title="Java11"></a>Java11</h2><p>Java11 于 2018 年 9 月 25 日正式发布，这是很重要的一个版本！Java 11 和 2017 年 9 月份发布的 Java 9 以及 2018 年 3 月份发布的 Java 10 相比，其最大的区别就是：在长期支持(Long-Term-Support)方面，<strong>Oracle 表示会对 Java 11 提供大力支持，这一支持将会持续至 2026 年 9 月。这是据 Java 8 以后支持的首个长期版本。</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://imgkr.cn-bj.ufileos.com/fc66979f-7974-40e8-88ae-6dbff15ac9ef.png" alt=""></p><h3 id="字符串加强"><a href="#字符串加强" class="headerlink" title="字符串加强"></a>字符串加强</h3><p>Java 11 增加了一系列的字符串处理方法，如以下所示。</p><p><em>Guide 哥：说白点就是多了层封装，JDK 开发组的人没少看市面上常见的工具类框架啊!</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断字符串是否为空</span></span><br><span class="line"><span class="string">" "</span>.isBlank();<span class="comment">//true</span></span><br><span class="line"><span class="comment">//去除字符串首尾空格</span></span><br><span class="line"><span class="string">" Java "</span>.strip();<span class="comment">// "Java" </span></span><br><span class="line"><span class="comment">//去除字符串首部空格</span></span><br><span class="line"><span class="string">" Java "</span>.stripLeading();   <span class="comment">// "Java "  </span></span><br><span class="line"><span class="comment">//去除字符串尾部空格</span></span><br><span class="line"><span class="string">" Java "</span>.stripTrailing();  <span class="comment">// " Java"  </span></span><br><span class="line"><span class="comment">//重复字符串多少次</span></span><br><span class="line"><span class="string">"Java"</span>.repeat(<span class="number">3</span>);             <span class="comment">// "JavaJavaJava"  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回由行终止符分隔的字符串集合。</span></span><br><span class="line"><span class="string">"A\nB\nC"</span>.lines().count();    <span class="comment">// 3 </span></span><br><span class="line"><span class="string">"A\nB\nC"</span>.lines().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="ZGC：可伸缩低延迟垃圾收集器"><a href="#ZGC：可伸缩低延迟垃圾收集器" class="headerlink" title="ZGC：可伸缩低延迟垃圾收集器"></a>ZGC：可伸缩低延迟垃圾收集器</h3><p><strong>ZGC 即 Z Garbage Collector</strong>，是一个可伸缩的、低延迟的垃圾收集器。</p><p>ZGC 主要为了满足如下目标进行设计：</p><ul><li>GC 停顿时间不超过 10ms</li><li>即能处理几百 MB 的小堆，也能处理几个 TB 的大堆</li><li>应用吞吐能力不会下降超过 15%（与 G1 回收算法相比）</li><li>方便在此基础上引入新的 GC 特性和利用 colord</li><li>针以及 Load barriers 优化奠定基础</li><li>当前只支持 Linux/x64 位平台</li></ul><p>ZGC 目前 <strong>处在实验阶段</strong>，只支持 Linux/x64 平台</p><h3 id="标准-HTTP-Client-升级"><a href="#标准-HTTP-Client-升级" class="headerlink" title="标准 HTTP Client 升级"></a>标准 HTTP Client 升级</h3><p>Java 11 对 Java 9 中引入并在 Java 10 中进行了更新的 Http Client API 进行了标准化，在前两个版本中进行孵化的同时，Http Client 几乎被完全重写，并且现在完全支持异步非阻塞。</p><p>并且，Java11 中，Http Client 的包名由 <code>jdk.incubator.http</code> 改为<code>java.net.http</code>，该 API 通过 <code>CompleteableFuture</code> 提供非阻塞请求和响应语义。</p><p>使用起来也很简单，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = HttpRequest.newBuilder()  </span><br><span class="line"></span><br><span class="line">    .uri(URI.create(<span class="string">"https://javastack.cn"</span>))  </span><br><span class="line"></span><br><span class="line">    .GET()  </span><br><span class="line"></span><br><span class="line">    .build();  </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> client = HttpClient.newHttpClient();  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步  </span></span><br><span class="line"></span><br><span class="line">HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());  </span><br><span class="line"></span><br><span class="line">System.out.println(response.body());  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步  </span></span><br><span class="line"></span><br><span class="line">client.sendAsync(request, HttpResponse.BodyHandlers.ofString())  </span><br><span class="line"></span><br><span class="line">    .thenApply(HttpResponse::body)  </span><br><span class="line"></span><br><span class="line">    .thenAccept(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="简化启动单个源代码文件的方法"><a href="#简化启动单个源代码文件的方法" class="headerlink" title="简化启动单个源代码文件的方法"></a>简化启动单个源代码文件的方法</h3><ul><li>增强了 Java 启动器，使其能够运行单一文件的 Java 源代码。此功能允许使用 Java 解释器直接执行 Java 源代码。源代码在内存中编译，然后由解释器执行。唯一的约束在于所有相关的类必须定义在同一个 Java 文件中</li><li>对于 Java 初学者并希望尝试简单程序的人特别有用，并且能和 jshell 一起使用</li><li>一定能程度上增强了使用 Java 来写脚本程序的能力</li></ul><h3 id="用于-Lambda-参数的局部变量语法"><a href="#用于-Lambda-参数的局部变量语法" class="headerlink" title="用于 Lambda 参数的局部变量语法"></a>用于 Lambda 参数的局部变量语法</h3><ul><li>从 Java 10 开始，便引入了局部变量类型推断这一关键特性。类型推断允许使用关键字 var 作为局部变量的类型而不是实际类型，编译器根据分配给变量的值推断出类型</li><li>Java 10 中对 var 关键字存在几个限制<ul><li>只能用于局部变量上</li><li>声明时必须初始化</li><li>不能用作方法参数</li><li>不能在 Lambda 表达式中使用</li></ul></li><li>Java11 开始允许开发者在 Lambda 表达式中使用 var 进行参数声明</li></ul><h3 id="其他特性-1"><a href="#其他特性-1" class="headerlink" title="其他特性"></a>其他特性</h3><ul><li>新的垃圾回收器 Epsilon，一个完全消极的 GC 实现，分配有限的内存资源，最大限度的降低内存占用和内存吞吐延迟时间</li><li>低开销的 Heap Profiling：Java 11 中提供一种低开销的 Java 堆分配采样方法，能够得到堆分配的 Java 对象信息，并且能够通过 JVMTI 访问堆信息</li><li>TLS1.3 协议：Java 11 中包含了传输层安全性（TLS）1.3 规范（RFC 8446）的实现，替换了之前版本中包含的 TLS，包括 TLS 1.2，同时还改进了其他 TLS 功能，例如 OCSP 装订扩展（RFC 6066，RFC 6961），以及会话散列和扩展主密钥扩展（RFC 7627），在安全性和性能方面也做了很多提升</li><li>飞行记录器：飞行记录器之前是商业版 JDK 的一项分析工具，但在 Java 11 中，其代码被包含到公开代码库中，这样所有人都能使用该功能了</li></ul><h2 id="Java12"><a href="#Java12" class="headerlink" title="Java12"></a>Java12</h2><h3 id="增强-Switch"><a href="#增强-Switch" class="headerlink" title="增强 Switch"></a>增强 Switch</h3><ul><li><p>传统的 switch 语法存在容易漏写 break 的问题，而且从代码整洁性层面来看，多个 break 本质也是一种重复</p></li><li><p>Java12 提供了 swtich 表达式，使用类似 lambda 语法条件匹配成功后的执行块，不需要多写 break</p></li><li><p>作为预览特性加入，需要在<code>javac</code>编译和<code>java</code>运行时增加参数<code>--enable-preview</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">case</span> TUESDAY                -&gt; System.out.println(<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">case</span> THURSDAY, SATURDAY     -&gt; System.out.println(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY              -&gt; System.out.println(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数字格式化工具类"><a href="#数字格式化工具类" class="headerlink" title="数字格式化工具类"></a>数字格式化工具类</h3><ul><li><p><code>NumberFormat</code> 新增了对复杂的数字进行格式化的支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NumberFormat fmt = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);</span><br><span class="line">String result = fmt.format(<span class="number">1000</span>);</span><br><span class="line"> System.out.println(result); <span class="comment">// 输出为 1K，计算工资是多少K更方便了。。。</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h3><ul><li>Redhat 主导开发的 Pauseless GC 实现，主要目标是 99.9% 的暂停小于 10ms，暂停与堆大小无关等</li><li>和 Java11 开源的 ZGC 相比（需要升级到 JDK11 才能使用），Shenandoah GC 有稳定的 JDK8u 版本，在 Java8 占据主要市场份额的今天有更大的可落地性</li></ul><h3 id="G1-收集器提升"><a href="#G1-收集器提升" class="headerlink" title="G1 收集器提升"></a>G1 收集器提升</h3><ul><li><strong>Java12 为默认的垃圾收集器 G1 带来了两项更新:</strong><ul><li>可中止的混合收集集合：JEP344 的实现，为了达到用户提供的停顿时间目标，JEP 344 通过把要被回收的区域集（混合收集集合）拆分为强制和可选部分，使 G1 垃圾回收器能中止垃圾回收过程。 G1 可以中止可选部分的回收以达到停顿时间目标</li><li>及时返回未使用的已分配内存：JEP346 的实现，增强 G1 GC，以便在空闲时自动将 Java 堆内存返回给操作系统</li></ul></li></ul><h2 id="Java13"><a href="#Java13" class="headerlink" title="Java13"></a>Java13</h2><h3 id="引入-yield-关键字到-Switch-中"><a href="#引入-yield-关键字到-Switch-中" class="headerlink" title="引入 yield 关键字到 Switch 中"></a>引入 yield 关键字到 Switch 中</h3><ul><li><p><code>Switch</code> 表达式中就多了一个关键字用于跳出 <code>Switch</code> 块的关键字 <code>yield</code>，主要用于返回一个值</p></li><li><p><code>yield</code>和 <code>return</code> 的区别在于：<code>return</code> 会直接跳出当前循环或者方法，而 <code>yield</code> 只会跳出当前 <code>Switch</code> 块，同时在使用 <code>yield</code> 时，需要有 <code>default</code> 条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">descLanguage</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">"Java"</span>: yield <span class="string">"object-oriented, platform independent and secured"</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">"Ruby"</span>: yield <span class="string">"a programmer's best friend"</span>;</span><br><span class="line">           <span class="keyword">default</span>: yield name +<span class="string">" is a good language"</span>;</span><br><span class="line">       &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h3><ul><li><p>解决 Java 定义多行字符串时只能通过换行转义或者换行连接符来变通支持的问题，引入<strong>三重双引号</strong>来定义多行文本</p></li><li><p>两个<code>&quot;&quot;&quot;</code>中间的任何内容都会被解释为字符串的一部分，包括换行符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String json =<span class="string">"&#123;\n"</span> +</span><br><span class="line">              <span class="string">"   \"name\":\"mkyong\",\n"</span> +</span><br><span class="line">              <span class="string">"   \"age\":38\n"</span> +</span><br><span class="line">              <span class="string">"&#125;\n"</span>;   <span class="comment">// 未支持文本块之前</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String json = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">               &#123;</span></span><br><span class="line"><span class="string">                   "</span>name<span class="string">":"</span>mkyong<span class="string">",</span></span><br><span class="line"><span class="string">                   "</span>age<span class="string">":38</span></span><br><span class="line"><span class="string">               &#125;</span></span><br><span class="line"><span class="string">               "</span><span class="string">""</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="增强-ZGC-释放未使用内存"><a href="#增强-ZGC-释放未使用内存" class="headerlink" title="增强 ZGC 释放未使用内存"></a>增强 ZGC 释放未使用内存</h3><ul><li>在 Java 11 中是实验性的引入的 ZGC 在实际的使用中存在未能主动将未使用的内存释放给操作系统的问题</li><li>ZGC 堆由一组称为 ZPages 的堆区域组成。在 GC 周期中清空 ZPages 区域时，它们将被释放并返回到页面缓存 <strong>ZPageCache</strong> 中，此缓存中的 ZPages 按最近最少使用（LRU）的顺序，并按照大小进行组织</li><li>在 Java 13 中，ZGC 将向操作系统返回被标识为长时间未使用的页面，这样它们将可以被其他进程重用</li></ul><h3 id="SocketAPI-重构"><a href="#SocketAPI-重构" class="headerlink" title="SocketAPI 重构"></a>SocketAPI 重构</h3><ul><li>Java 13 为 Socket API 带来了新的底层实现方法，并且在 Java 13 中是默认使用新的 Socket 实现，使其易于发现并在排除问题同时增加可维护性</li></ul><h3 id="动态应用程序类-数据共享"><a href="#动态应用程序类-数据共享" class="headerlink" title="动态应用程序类-数据共享"></a>动态应用程序类-数据共享</h3><ul><li>Java 13 中对 Java 10 中引入的 应用程序类数据共享进行了进一步的简化、改进和扩展，即：<strong>允许在 Java 应用程序执行结束时动态进行类归档</strong>，具体能够被归档的类包括：所有已被加载，但不属于默认基层 CDS 的应用程序类和引用类库中的类</li></ul><h2 id="Java14"><a href="#Java14" class="headerlink" title="Java14"></a>Java14</h2><h3 id="record-关键字"><a href="#record-关键字" class="headerlink" title="record 关键字"></a>record 关键字</h3><ul><li><p>简化数据类的定义方式，使用 record 代替 class 定义的类，只需要声明属性，就可以在获得属性的访问方法，以及 toString，hashCode,equals 方法</p></li><li><p>类似于使用 Class 定义类，同时使用了 lomobok 插件，并打上了<code>@Getter,@ToString,@EqualsAndHashCode</code>注解</p></li><li><p>作为预览特性引入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个类具有两个特征</span></span><br><span class="line"><span class="comment"> * 1. 所有成员属性都是final</span></span><br><span class="line"><span class="comment"> * 2. 全部方法由构造方法，和两个成员属性访问器组成（共三个）</span></span><br><span class="line"><span class="comment"> * 那么这种类就很适合使用record来声明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> length;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> length; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">width</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> width; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 使用record声明的类会自动拥有上面类中的三个方法</span></span><br><span class="line"><span class="comment"> * 2. 在这基础上还附赠了equals()，hashCode()方法以及toString()方法</span></span><br><span class="line"><span class="comment"> * 3. toString方法中包括所有成员属性的字符串表示形式及其名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">record <span class="title">Rectangle</span><span class="params">(<span class="keyword">float</span> length, <span class="keyword">float</span> width)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="空指针异常精准提示"><a href="#空指针异常精准提示" class="headerlink" title="空指针异常精准提示"></a>空指针异常精准提示</h3><ul><li><p>通过 JVM 参数中添加<code>-XX:+ShowCodeDetailsInExceptionMessages</code>，可以在空指针异常中获取更为详细的调用信息，更快的定位和解决问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.b.c.i = <span class="number">99</span>; <span class="comment">// 假设这段代码会发生空指针</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NullPointerException:</span><br><span class="line">        Cannot read field <span class="string">'c'</span> because <span class="string">'a.b'</span> is <span class="keyword">null</span>.</span><br><span class="line">    at Prog.main(Prog.java:<span class="number">5</span>) <span class="comment">// 增加参数后提示的异常中很明确的告知了哪里为空导致</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="switch-的增强终于转正"><a href="#switch-的增强终于转正" class="headerlink" title="switch 的增强终于转正"></a>switch 的增强终于转正</h3><ul><li>JDK12 引入的 switch（预览特性）在 JDK14 变为正式版本，不需要增加参数来启用，直接在 JDK14 中就能使用</li><li>主要是用<code>-&gt;</code>来替代以前的<code>:</code>+<code>break</code>；另外就是提供了 yield 来在 block 中返回值</li></ul><p><em>Before Java 14</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">    <span class="keyword">case</span> FRIDAY:</span><br><span class="line">    <span class="keyword">case</span> SUNDAY:</span><br><span class="line">        System.out.println(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY:</span><br><span class="line">        System.out.println(<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> THURSDAY:</span><br><span class="line">    <span class="keyword">case</span> SATURDAY:</span><br><span class="line">        System.out.println(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">        System.out.println(<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Java 14 enhancements</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">case</span> TUESDAY                -&gt; System.out.println(<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">case</span> THURSDAY, SATURDAY     -&gt; System.out.println(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY              -&gt; System.out.println(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="instanceof-增强"><a href="#instanceof-增强" class="headerlink" title="instanceof 增强"></a>instanceof 增强</h3><ul><li><p>instanceof 主要在<strong>类型强转前探测对象的具体类型</strong>，然后执行具体的强转</p></li><li><p>新版的 instanceof 可以在判断的是否属于具体的类型同时完成转换</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="string">"我是字符串"</span>;</span><br><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> String str)&#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他特性-2"><a href="#其他特性-2" class="headerlink" title="其他特性"></a>其他特性</h3><ul><li>从 Java11 引入的 ZGC 作为继 G1 过后的下一代 GC 算法，从支持 Linux 平台到 Java14 开始支持 MacOS 和 Window（个人感觉是终于可以在日常开发工具中先体验下 ZGC 的效果了，虽然其实 G1 也够用）</li><li>移除了 CMS 垃圾收集器（功成而退）</li><li>新增了 jpackage 工具，标配将应用打成 jar 包外，还支持不同平台的特性包，比如 linux 下的<code>deb</code>和<code>rpm</code>，window 平台下的<code>msi</code>和<code>exe</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="关于预览特性"><a href="#关于预览特性" class="headerlink" title="关于预览特性"></a>关于预览特性</h3><ul><li>先贴一段 oracle 官网原文：<code>This is a preview feature, which is a feature whose design, specification, and implementation are complete, but is not permanent, which means that the feature may exist in a different form or not at all in future JDK releases. To compile and run code that contains preview features, you must specify additional command-line options.</code></li><li>这是一个预览功能，该功能的设计，规格和实现是完整的，但不是永久性的，这意味着该功能可能以其他形式存在或在将来的 JDK 版本中根本不存在。 要编译和运行包含预览功能的代码，必须指定其他命令行选项。</li><li>就以<code>switch</code>的增强为例子，从 Java12 中推出，到 Java13 中将继续增强，直到 Java14 才正式转正进入 JDK 可以放心使用，不用考虑后续 JDK 版本对其的改动或修改</li><li>一方面可以看出 JDK 作为标准平台在增加新特性的严谨态度，另一方面个人认为是对于预览特性应该采取审慎使用的态度。特性的设计和实现容易，但是其实际价值依然需要在使用中去验证</li></ul><h3 id="JVM-虚拟机优化"><a href="#JVM-虚拟机优化" class="headerlink" title="JVM 虚拟机优化"></a>JVM 虚拟机优化</h3><ul><li>每次 Java 版本的发布都伴随着对 JVM 虚拟机的优化，包括对现有垃圾回收算法的改进，引入新的垃圾回收算法，移除老旧的不再适用于今天的垃圾回收算法等</li><li>整体优化的方向是<strong>高效，低时延的垃圾回收表现</strong></li><li>对于日常的应用开发者可能比较关注新的语法特性，但是从一个公司角度来说，在考虑是否升级 Java 平台时更加考虑的是<strong>JVM 运行时的提升</strong></li></ul><h2 id="参考信息"><a href="#参考信息" class="headerlink" title="参考信息"></a>参考信息</h2><ul><li>IBM Developer Java9 <a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-9/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-9/</a></li><li>Guide to Java10 <a href="https://www.baeldung.com/java-10-overview" target="_blank" rel="noopener">https://www.baeldung.com/java-10-overview</a></li><li>Java 10 新特性介绍<a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-10/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-10/index.html</a></li><li>IBM Devloper Java11 <a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-11/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-11/index.html</a></li><li>Java 11 – Features and Comparison： <a href="https://www.geeksforgeeks.org/java-11-features-and-comparison/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/java-11-features-and-comparison/</a></li><li>Oracle Java12 ReleaseNote <a href="https://www.oracle.com/technetwork/java/javase/12all-relnotes-5211423.html#NewFeature" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/12all-relnotes-5211423.html#NewFeature</a></li><li>Oracle Java13 ReleaseNote <a href="https://www.oracle.com/technetwork/java/javase/13all-relnotes-5461743.html#NewFeature" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/13all-relnotes-5461743.html#NewFeature</a></li><li>New Java13 Features <a href="https://www.baeldung.com/java-13-new-features" target="_blank" rel="noopener">https://www.baeldung.com/java-13-new-features</a></li><li>Java13 新特性概述 <a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-13/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-13/index.html</a></li><li>Oracle Java14 record <a href="https://docs.oracle.com/en/java/javase/14/language/records.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/14/language/records.html</a></li><li>java14-features <a href="https://www.techgeeknext.com/java/java14-features" target="_blank" rel="noopener">https://www.techgeeknext.com/java/java14-features</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC调优参数</title>
      <link href="/posts/bcb9e688/"/>
      <url>/posts/bcb9e688/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文地址： <a href="https://juejin.im/post/5c94a123f265da610916081f。" target="_blank" rel="noopener">https://juejin.im/post/5c94a123f265da610916081f。</a></p></blockquote><h1 id="JVM面试问题系列：JVM-配置常用参数和常用-GC-调优策略"><a href="#JVM面试问题系列：JVM-配置常用参数和常用-GC-调优策略" class="headerlink" title="JVM面试问题系列：JVM 配置常用参数和常用 GC 调优策略"></a>JVM面试问题系列：JVM 配置常用参数和常用 GC 调优策略</h1><h1 id="JVM-配置常用参数"><a href="#JVM-配置常用参数" class="headerlink" title="JVM 配置常用参数"></a>JVM 配置常用参数</h1><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://user-gold-cdn.xitu.io/2019/3/22/169a49566fec0862?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>堆参数</strong></p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="632" height="205"></svg>)</p><p><strong>回收器参数</strong></p><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="608" height="336"></svg>)</p><p>如上表所示，目前<strong>主要有串行、并行和并发三种</strong>，对于大内存的应用而言，串行的性能太低，因此使用到的主要是并行和并发两种。并行和并发 GC 的策略通过 UseParallelGC 和 UseConcMarkSweepGC 来指定，还有一些细节的配置参数用来配置策略的执行方式。例如：XX:ParallelGCThreads， XX:CMSInitiatingOccupancyFraction 等。 通常：Young 区对象回收只可选择并行（耗时间），Old 区选择并发（耗 CPU）。</p><p><strong>项目中常用配置</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://user-gold-cdn.xitu.io/2019/3/22/169a495670b53d45?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>常用组合</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://user-gold-cdn.xitu.io/2019/3/22/169a495670bca2af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h1 id="常用-GC-调优策略"><a href="#常用-GC-调优策略" class="headerlink" title="常用 GC 调优策略"></a>常用 GC 调优策略</h1><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://user-gold-cdn.xitu.io/2019/3/22/169a495670cf70ab?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p><strong>GC 调优原则</strong></p><p>在调优之前，我们需要记住下面的原则：</p><blockquote><p>多数的 Java 应用不需要在服务器上进行 GC 优化；</p><p>多数导致 GC 问题的 Java 应用，都不是因为我们参数设置错误，而是代码问题；</p><p>在应用上线之前，先考虑将机器的 JVM 参数设置到最优（最适合）；</p><p>减少创建对象的数量；</p><p>减少使用全局变量和大对象；</p><p>GC 优化是到最后不得已才采用的手段；</p><p>在实际使用中，分析 GC 情况优化代码比优化 GC 参数要多得多。</p></blockquote><p><strong>GC 调优目的</strong></p><blockquote><p>将转移到老年代的对象数量降低到最小；</p><p>减少 GC 的执行时间。</p></blockquote><p><strong>策略 1：</strong>将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。</p><p><strong>策略 2：</strong>大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的。但是对于大对象这种做法却值得商榷，大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的 full gc。因此，对于大对象，可以设置直接进入老年代（当然短命的大对象对于垃圾回收老说简直就是噩梦）。-XX:PretenureSizeThreshold 可以设置直接进入老年代的对象大小。</p><p><strong>策略 3：</strong>合理设置进入老年代对象的年龄，-XX:MaxTenuringThreshold 设置对象进入老年代的年龄大小，减少老年代的内存占用，降低 full gc 发生的频率。</p><p><strong>策略 4：</strong>设置稳定的堆大小，堆大小设置有两个参数：-Xms 初始化堆大小，-Xmx 最大堆大小。</p><p><strong>策略5：</strong>注意： 如果满足下面的指标，<strong>则一般不需要进行 GC 优化：</strong></p><blockquote><p>MinorGC 执行时间不到50ms；</p><p>Minor GC 执行不频繁，约10秒一次；</p><p>Full GC 执行时间不到1s；</p><p>Full GC 执行频率不算频繁，不低于10分钟1次。</p></blockquote><h1 id="JVM系列："><a href="#JVM系列：" class="headerlink" title="JVM系列："></a>JVM系列：</h1><p><strong><a href="https://juejin.im/post/5c9482e551882506254d0acb" target="_blank" rel="noopener">深入详解JVM 内存区域及内存溢出分析</a></strong></p><p><strong><a href="https://juejin.im/post/5c9493d35188252daa18f4fd" target="_blank" rel="noopener">JVM的判断对象是否已死和四种垃圾回收算法</a></strong></p><p><strong><a href="https://juejin.im/post/5c94a123f265da610916081f" target="_blank" rel="noopener">JVM 配置常用参数和常用 GC 调优策略</a></strong></p><p><a href="https://juejin.im/post/5c94d0ad5188252d5404b494" target="_blank" rel="noopener"><strong>7种JVM垃圾收集器特点，优劣势、及使用场景！</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK 监控和故障处理工具总结</title>
      <link href="/posts/abb664f3/"/>
      <url>/posts/abb664f3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><p>点击关注<a href="#公众号">公众号</a>及时获取笔主最新更新文章，并可免费领取本文档配套的《Java面试突击》以及Java工程师必备学习资源。</p><h1 id="JDK-监控和故障处理工具总结"><a href="#JDK-监控和故障处理工具总结" class="headerlink" title="JDK 监控和故障处理工具总结"></a>JDK 监控和故障处理工具总结</h1><h2 id="JDK-命令行工具"><a href="#JDK-命令行工具" class="headerlink" title="JDK 命令行工具"></a>JDK 命令行工具</h2><p>这些命令在 JDK 安装目录下的 bin 目录下：</p><ul><li><strong><code>jps</code></strong> (JVM Process Status）: 类似 UNIX 的 <code>ps</code> 命令。用户查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</li><li><strong><code>jstat</code></strong>（ JVM Statistics Monitoring Tool）:  用于收集 HotSpot 虚拟机各方面的运行数据;</li><li><strong><code>jinfo</code></strong> (Configuration Info for Java) : Configuration Info forJava,显示虚拟机配置信息;</li><li><strong><code>jmap</code></strong> (Memory Map for Java) :生成堆转储快照;</li><li><strong><code>jhat</code></strong> (JVM Heap Dump Browser ) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;</li><li><strong><code>jstack</code></strong> (Stack Trace for Java):生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</li></ul><h3 id="jps-查看所有-Java-进程"><a href="#jps-查看所有-Java-进程" class="headerlink" title="jps:查看所有 Java 进程"></a><code>jps</code>:查看所有 Java 进程</h3><p><code>jps</code>(JVM Process Status) 命令类似 UNIX 的 <code>ps</code> 命令。</p><p><code>jps</code>：显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（Local Virtual Machine Identifier,LVMID）。<code>jps -q</code> ：只输出进程的本地虚拟机唯一 ID。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jps</span><br><span class="line"><span class="number">7360</span> NettyClient2</span><br><span class="line"><span class="number">17396</span></span><br><span class="line"><span class="number">7972</span> Launcher</span><br><span class="line"><span class="number">16504</span> Jps</span><br><span class="line"><span class="number">17340</span> NettyServer</span><br></pre></td></tr></table></figure><p><code>jps -l</code>:输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jps <span class="literal">-l</span></span><br><span class="line"><span class="number">7360</span> firstNettyDemo.NettyClient2</span><br><span class="line"><span class="number">17396</span></span><br><span class="line"><span class="number">7972</span> org.jetbrains.jps.cmdline.Launcher</span><br><span class="line"><span class="number">16492</span> sun.tools.jps.Jps</span><br><span class="line"><span class="number">17340</span> firstNettyDemo.NettyServer</span><br></pre></td></tr></table></figure><p><code>jps -v</code>：输出虚拟机进程启动时 JVM 参数。</p><p><code>jps -m</code>：输出传递给 Java 进程 main() 函数的参数。</p><h3 id="jstat-监视虚拟机各种运行状态信息"><a href="#jstat-监视虚拟机各种运行状态信息" class="headerlink" title="jstat: 监视虚拟机各种运行状态信息"></a><code>jstat</code>: 监视虚拟机各种运行状态信息</h3><p>jstat（JVM Statistics Monitoring Tool） 使用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程（需要远程主机提供 RMI 支持）虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据，在没有 GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。</p><p><strong><code>jstat</code> 命令使用格式：</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-<span class="type">t</span>] [-<span class="type">h</span>&lt;<span class="type">lines</span>&gt;] &lt;vmid&gt; [&lt;<span class="built_in">int</span><span class="type">erval</span>&gt; [&lt;<span class="type">count</span>&gt;]]</span><br></pre></td></tr></table></figure><p>比如 <code>jstat -gc -h3 31736 1000 10</code>表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。</p><p><strong>常见的 option 如下：</strong></p><ul><li><code>jstat -class vmid</code> ：显示 ClassLoader 的相关信息；</li><li><code>jstat -compiler vmid</code> ：显示 JIT 编译的相关信息；</li><li><code>jstat -gc vmid</code> ：显示与 GC 相关的堆信息；</li><li><code>jstat -gccapacity vmid</code> ：显示各个代的容量及使用情况；</li><li><code>jstat -gcnew vmid</code> ：显示新生代信息；</li><li><code>jstat -gcnewcapcacity vmid</code> ：显示新生代大小与使用情况；</li><li><code>jstat -gcold vmid</code> ：显示老年代和永久代的行为统计，从jdk1.8开始,该选项仅表示老年代，因为永久代被移除了；</li><li><code>jstat -gcoldcapacity vmid</code> ：显示老年代的大小；</li><li><code>jstat -gcpermcapacity vmid</code> ：显示永久代大小，从jdk1.8开始,该选项不存在了，因为永久代被移除了；</li><li><code>jstat -gcutil vmid</code> ：显示垃圾收集信息；</li></ul><p>另外，加上 <code>-t</code>参数可以在输出信息上加一个 Timestamp 列，显示程序的运行时间。</p><h3 id="jinfo-实时地查看和调整虚拟机各项参数"><a href="#jinfo-实时地查看和调整虚拟机各项参数" class="headerlink" title="jinfo: 实时地查看和调整虚拟机各项参数"></a><code>jinfo</code>: 实时地查看和调整虚拟机各项参数</h3><p><code>jinfo vmid</code> :输出当前 jvm 进程的全部参数和系统属性 (第一部分是系统的属性，第二部分是 JVM 的参数)。</p><p><code>jinfo -flag name vmid</code> :输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( <code>-XX:PrintGCDetails</code> :详细 GC 日志模式，这两个都是默认关闭的)。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span> MaxHeapSize <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:MaxHeapSize=<span class="number">2124414976</span></span><br><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span> PrintGC <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:<span class="literal">-PrintGC</span></span><br></pre></td></tr></table></figure><p>使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数。尤其在线上的环境特别有用,请看下面的例子：</p><p><code>jinfo -flag [+|-]name vmid</code> 开启或者关闭对应名称的参数。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span>  PrintGC <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:<span class="literal">-PrintGC</span></span><br><span class="line"></span><br><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span>  +PrintGC <span class="number">17340</span></span><br><span class="line"></span><br><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span>  PrintGC <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:+PrintGC</span><br></pre></td></tr></table></figure><h3 id="jmap-生成堆转储快照"><a href="#jmap-生成堆转储快照" class="headerlink" title="jmap:生成堆转储快照"></a><code>jmap</code>:生成堆转储快照</h3><p><code>jmap</code>（Memory Map for Java）命令用于生成堆转储快照。 如果不使用 <code>jmap</code> 命令，要想获取 Java 堆转储，可以使用 <code>“-XX:+HeapDumpOnOutOfMemoryError”</code> 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 <code>kill -3</code> 发送进程退出信号也能拿到 dump 文件。</p><p><code>jmap</code> 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和<code>jinfo</code>一样，<code>jmap</code>有不少功能在 Windows 平台下也是受限制的。</p><p>示例：将指定应用程序的堆快照输出到桌面。后面，可以通过 jhat、Visual VM 等工具分析该堆文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jmap <span class="literal">-dump</span>:format=b,file=C:\Users\SnailClimb\Desktop\heap.hprof <span class="number">17340</span></span><br><span class="line">Dumping heap to C:\Users\SnailClimb\Desktop\heap.hprof ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure><h3 id="jhat-分析-heapdump-文件"><a href="#jhat-分析-heapdump-文件" class="headerlink" title="jhat: 分析 heapdump 文件"></a><strong><code>jhat</code></strong>: 分析 heapdump 文件</h3><p> <strong><code>jhat</code></strong> 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jhat C:\Users\SnailClimb\Desktop\heap.hprof</span><br><span class="line">Reading from C:\Users\SnailClimb\Desktop\heap.hprof...</span><br><span class="line">Dump file created Sat May <span class="number">04</span> <span class="number">12</span>:<span class="number">30</span>:<span class="number">31</span> CST <span class="number">2019</span></span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving <span class="number">131419</span> objects...</span><br><span class="line">Chasing references, expect <span class="number">26</span> dots..........................</span><br><span class="line">Eliminating duplicate references..........................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port <span class="number">7000</span></span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:7000/" target="_blank" rel="noopener">http://localhost:7000/</a></p><h3 id="jstack-生成虚拟机当前时刻的线程快照"><a href="#jstack-生成虚拟机当前时刻的线程快照" class="headerlink" title="jstack :生成虚拟机当前时刻的线程快照"></a><strong><code>jstack</code></strong> :生成虚拟机当前时刻的线程快照</h3><p><code>jstack</code>（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.</p><p>生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过<code>jstack</code>来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。</p><p><strong>下面是一个线程死锁的代码。我们下面会通过 <code>jstack</code> 命令进行死锁检查，输出死锁信息，找到发生死锁的线程。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource1 = <span class="keyword">new</span> Object();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource2 = <span class="keyword">new</span> Object();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource2"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程 1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource1"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程 2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]waiting get resource1</span><br></pre></td></tr></table></figure><p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p><p><strong>通过 <code>jstack</code> 命令分析：</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jps</span><br><span class="line"><span class="number">13792</span> KotlinCompileDaemon</span><br><span class="line"><span class="number">7360</span> NettyClient2</span><br><span class="line"><span class="number">17396</span></span><br><span class="line"><span class="number">7972</span> Launcher</span><br><span class="line"><span class="number">8932</span> Launcher</span><br><span class="line"><span class="number">9256</span> DeadLockDemo</span><br><span class="line"><span class="number">10764</span> Jps</span><br><span class="line"><span class="number">17340</span> NettyServer</span><br><span class="line"></span><br><span class="line">C:\Users\SnailClimb&gt;jstack <span class="number">9256</span></span><br></pre></td></tr></table></figure><p>输出的部分内容如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Found one Java<span class="literal">-level</span> deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">"线程 2"</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0</span>x000000000333e668 (object <span class="number">0</span>x00000000d5efe1c0, a java.lang.Object),</span><br><span class="line">  which is held by <span class="string">"线程 1"</span></span><br><span class="line"><span class="string">"线程 1"</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0</span>x000000000333be88 (object <span class="number">0</span>x00000000d5efe1d0, a java.lang.Object),</span><br><span class="line">  which is held by <span class="string">"线程 2"</span></span><br><span class="line"></span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">"线程 2"</span>:</span><br><span class="line">        at DeadLockDemo.lambda<span class="variable">$main</span><span class="variable">$1</span>(DeadLockDemo.java:<span class="number">31</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0</span>x00000000d5efe1c0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0</span>x00000000d5efe1d0&gt; (a java.lang.Object)</span><br><span class="line">        at DeadLockDemo<span class="variable">$</span><span class="variable">$Lambda</span><span class="variable">$2</span>/<span class="number">1078694789</span>.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="string">"线程 1"</span>:</span><br><span class="line">        at DeadLockDemo.lambda<span class="variable">$main</span><span class="variable">$0</span>(DeadLockDemo.java:<span class="number">16</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0</span>x00000000d5efe1d0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0</span>x00000000d5efe1c0&gt; (a java.lang.Object)</span><br><span class="line">        at DeadLockDemo<span class="variable">$</span><span class="variable">$Lambda</span><span class="variable">$1</span>/<span class="number">1324119927</span>.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">Found <span class="number">1</span> deadlock.</span><br></pre></td></tr></table></figure><p>可以看到 <code>jstack</code> 命令已经帮我们找到发生死锁的线程的具体信息。</p><h2 id="JDK-可视化分析工具"><a href="#JDK-可视化分析工具" class="headerlink" title="JDK 可视化分析工具"></a>JDK 可视化分析工具</h2><h3 id="JConsole-Java-监视与管理控制台"><a href="#JConsole-Java-监视与管理控制台" class="headerlink" title="JConsole:Java 监视与管理控制台"></a>JConsole:Java 监视与管理控制台</h3><p>JConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。你可以在控制台输出<code>console</code>命令启动或者在 JDK 目录下的 bin 目录找到<code>jconsole.exe</code>然后双击启动。</p><h4 id="连接-Jconsole"><a href="#连接-Jconsole" class="headerlink" title="连接 Jconsole"></a>连接 Jconsole</h4><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/1JConsole%E8%BF%9E%E6%8E%A5.png" alt="连接 Jconsole"></p><p>如果需要使用 JConsole 连接远程进程，可以在远程 Java 程序启动时加上下面这些参数:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-Djava.rmi.server.hostname</span>=<span class="string">外网访问 ip 地址 </span></span><br><span class="line"><span class="meta">-Dcom.sun.management.jmxremote.port</span>=<span class="string">60001   //监控的端口号</span></span><br><span class="line"><span class="meta">-Dcom.sun.management.jmxremote.authenticate</span>=<span class="string">false   //关闭认证</span></span><br><span class="line"><span class="meta">-Dcom.sun.management.jmxremote.ssl</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><p>在使用 JConsole 连接时，远程进程地址如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外网访问 ip 地址:60001</span><br></pre></td></tr></table></figure><h4 id="查看-Java-程序概况"><a href="#查看-Java-程序概况" class="headerlink" title="查看 Java 程序概况"></a>查看 Java 程序概况</h4><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/2%E6%9F%A5%E7%9C%8BJava%E7%A8%8B%E5%BA%8F%E6%A6%82%E5%86%B5.png" alt="查看 Java 程序概况 "></p><h4 id="内存监控"><a href="#内存监控" class="headerlink" title="内存监控"></a>内存监控</h4><p>JConsole 可以显示当前内存的详细信息。不仅包括堆内存/非堆内存的整体信息，还可以细化到 eden 区、survivor 区等的使用情况，如下图所示。</p><p>点击右边的“执行 GC(G)”按钮可以强制应用程序执行一个 Full GC。</p><blockquote><ul><li><strong>新生代 GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</li><li><strong>老年代 GC（Major GC/Full GC）</strong>:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</li></ul></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/3%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7.png" alt="内存监控 "></p><h4 id="线程监控"><a href="#线程监控" class="headerlink" title="线程监控"></a>线程监控</h4><p>类似我们前面讲的 <code>jstack</code> 命令，不过这个是可视化的。</p><p>最下面有一个”检测死锁 (D)”按钮，点击这个按钮可以自动为你找到发生死锁的线程以及它们的详细信息 。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/4%E7%BA%BF%E7%A8%8B%E7%9B%91%E6%8E%A7.png" alt="线程监控 "></p><h3 id="Visual-VM-多合一故障处理工具"><a href="#Visual-VM-多合一故障处理工具" class="headerlink" title="Visual VM:多合一故障处理工具"></a>Visual VM:多合一故障处理工具</h3><p>VisualVM 提供在 Java 虚拟机 (Java Virutal Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。Visual VM 官网：<a href="https://visualvm.github.io/" target="_blank" rel="noopener">https://visualvm.github.io/</a> 。Visual VM 中文文档:<a href="https://visualvm.github.io/documentation.html" target="_blank" rel="noopener">https://visualvm.github.io/documentation.html</a>。</p><p>下面这段话摘自《深入理解 Java 虚拟机》。</p><blockquote><p>VisualVM（All-in-One Java Troubleshooting Tool）是到目前为止随 JDK 发布的功能最强大的运行监视和故障处理程序，官方在 VisualVM 的软件说明中写上了“All-in-One”的描述字样，预示着他除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析（Profiling）。VisualVM 的性能分析功能甚至比起 JProfiler、YourKit 等专业且收费的 Profiling 工具都不会逊色多少，而且 VisualVM 还有一个很大的优点：不需要被监视的程序基于特殊 Agent 运行，因此他对应用程序的实际性能的影响很小，使得他可以直接应用在生产环境中。这个优点是 JProfiler、YourKit 等工具无法与之媲美的。</p></blockquote><p> VisualVM 基于 NetBeans 平台开发，因此他一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM 可以做到：</p><ul><li><strong>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。</strong></li><li><strong>监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。</strong></li><li><strong>dump 以及分析堆转储快照（jmap、jhat）。</strong></li><li><strong>方法级的程序运行性能分析，找到被调用最多、运行时间最长的方法。</strong></li><li><strong>离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。</strong></li><li><strong>其他 plugins 的无限的可能性……</strong></li></ul><p>这里就不具体介绍 VisualVM 的使用，如果想了解的话可以看:</p><ul><li><a href="https://visualvm.github.io/documentation.html" target="_blank" rel="noopener">https://visualvm.github.io/documentation.html</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html</a></li></ul><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p><p><strong>《Java面试突击》:</strong> 由本文档衍生的专为面试而生的《Java面试突击》V2.0 PDF 版本公众号后台回复 <strong>“Java面试突击”</strong> 即可免费领取！</p><p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。 </p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/qrcode_for_gh_ea338256af79_258.jpg" alt="我的公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 垃圾回收</title>
      <link href="/posts/47582f6c/"/>
      <url>/posts/47582f6c/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><p>点击关注<a href="#公众号">公众号</a>及时获取笔主最新更新文章，并可免费领取本文档配套的《Java面试突击》以及Java工程师必备学习资源。</p><h1 id="JVM-垃圾回收"><a href="#JVM-垃圾回收" class="headerlink" title="JVM 垃圾回收"></a>JVM 垃圾回收</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><h3 id="本节常见面试题"><a href="#本节常见面试题" class="headerlink" title="本节常见面试题"></a>本节常见面试题</h3><p>问题答案在文中都有提到</p><ul><li>如何判断对象是否死亡（两种方法）。</li><li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</li><li>如何判断一个常量是废弃常量</li><li>如何判断一个类是无用的类</li><li>垃圾收集有哪些算法，各自的特点？</li><li>HotSpot 为什么要分为新生代和老年代？</li><li>常见的垃圾回收器有哪些？</li><li>介绍一下 CMS,G1 收集器。</li><li>Minor Gc 和 Full GC 有什么不同呢？</li></ul><h3 id="本文导火索"><a href="#本文导火索" class="headerlink" title="本文导火索"></a>本文导火索</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/29176325.jpg" alt=""></p><p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p><h2 id="1-揭开-JVM-内存分配与回收的神秘面纱"><a href="#1-揭开-JVM-内存分配与回收的神秘面纱" class="headerlink" title="1  揭开 JVM 内存分配与回收的神秘面纱"></a>1  揭开 JVM 内存分配与回收的神秘面纱</h2><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p><strong>堆空间的基本结构：</strong></p><div align="center">  <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3堆结构.png" width="400px"/></div><p>上图所示的 eden 区、s0(“From”) 区、s1(“To”) 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。经过这次GC后，Eden区和”From”区已经被清空。这个时候，”From”和”To”会交换他们的角色，也就是新的”To”就是上次GC前的“From”，新的”From”就是上次GC前的”To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，”To”区被填满之后，会将所有对象移动到老年代中。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%A0%86%E5%86%85%E5%AD%98.jpg" alt="堆内存常见分配策略 "></p><h3 id="1-1-对象优先在-eden-区分配"><a href="#1-1-对象优先在-eden-区分配" class="headerlink" title="1.1 对象优先在 eden 区分配"></a>1.1 对象优先在 eden 区分配</h3><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.下面我们来进行实际测试以下。</p><p>在测试之前我们先来看看 <strong>Minor GC 和 Full GC 有什么不同呢？</strong></p><ul><li><strong>新生代 GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</li><li><strong>老年代 GC（Major GC/Full GC）</strong>:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</li></ul><blockquote><p><a href="https://github.com/Snailclimb/JavaGuide/issues/664" target="_blank" rel="noopener">issue#664 </a> :<strong><a href="https://github.com/guang19" target="_blank" rel="noopener">guang19</a></strong> 补充：个人在网上查阅相关资料的时候发现如题所说的观点。有的文章说 Major GC 与 Full GC 一样是属于对老年代的GC，也有的文章说 Major GC 是对整个堆区的GC，所以这点需要各位同学自行分辨 Major GC 语义。见: <a href="https://www.zhihu.com/question/41922036" target="_blank" rel="noopener">知乎讨论</a></p></blockquote><p><strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] allocation1, allocation2;</span><br><span class="line">allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">30900</span>*<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//allocation2 = new byte[900*1024];</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以下方式运行：<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/25178350.jpg" alt=""></p><p>添加的参数：<code>-XX:+PrintGCDetails</code><br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/10317146.jpg" alt=""></p><p>运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/28954286.jpg" alt=""></p><p>从上图我们可以看出 eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。假如我们再为 allocation2 分配内存会出现什么情况呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">900</span>*<span class="number">1024</span>];</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/28128785.jpg" alt=""></p><p><strong>简单解释一下为什么会出现这种情况：</strong> 因为给 allocation2 分配内存的时候 eden 区内存几乎已经被分配完了，我们刚刚讲了当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 eden 区的话，还是会在 eden 区分配内存。可以执行如下代码验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] allocation1, allocation2,allocation3,allocation4,allocation5;</span><br><span class="line">allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">32000</span>*<span class="number">1024</span>];</span><br><span class="line">allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">allocation5 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-大对象直接进入老年代"><a href="#1-2-大对象直接进入老年代" class="headerlink" title="1.2 大对象直接进入老年代"></a>1.2 大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p><p><strong>为什么要这样呢？</strong></p><p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><h3 id="1-3-长期存活的对象将进入老年代"><a href="#1-3-长期存活的对象将进入老年代" class="headerlink" title="1.3 长期存活的对象将进入老年代"></a>1.3 长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><h3 id="1-4-动态对象年龄判定"><a href="#1-4-动态对象年龄判定" class="headerlink" title="1.4 动态对象年龄判定"></a>1.4 动态对象年龄判定</h3><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加  1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><blockquote><p>修正（<a href="https://github.com/Snailclimb/JavaGuide/issues/552" target="_blank" rel="noopener">issue552</a>）：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。</p><p><strong>动态年龄计算的代码如下</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="keyword">size_t</span> survivor_capacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line"><span class="keyword">size_t</span> desired_survivor_size = (<span class="keyword">size_t</span>)((((<span class="keyword">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line"><span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">uint age = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line"> total += sizes[age];<span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line"> <span class="keyword">if</span> (total &gt; desired_survivor_size) <span class="keyword">break</span>;</span><br><span class="line"> age++;</span><br><span class="line">&#125;</span><br><span class="line">uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>额外补充说明(<a href="https://github.com/Snailclimb/JavaGuide/issues/672" target="_blank" rel="noopener">issue672</a>)：<strong>关于默认的晋升年龄是15，这个说法的来源大部分都是《深入理解Java虚拟机》这本书。</strong><br>如果你去Oracle的官网阅读<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">相关的虚拟机参数</a>，你会发现<code>-XX:MaxTenuringThreshold=threshold</code>这里有个说明</p><p><strong>Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.默认晋升年龄并不都是15，这个是要区分垃圾收集器的，CMS就是6.</strong></p></blockquote><h2 id="2-对象已经死亡？"><a href="#2-对象已经死亡？" class="headerlink" title="2 对象已经死亡？"></a>2 对象已经死亡？</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/11034259.jpg" alt=""></p><h3 id="2-1-引用计数法"><a href="#2-1-引用计数法" class="headerlink" title="2.1 引用计数法"></a>2.1 引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGc</span> </span>&#123;</span><br><span class="line">    Object instance = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ReferenceCountingGc objA = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">ReferenceCountingGc objB = <span class="keyword">new</span> ReferenceCountingGc();</span><br><span class="line">objA.instance = objB;</span><br><span class="line">objB.instance = objA;</span><br><span class="line">objA = <span class="keyword">null</span>;</span><br><span class="line">objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-可达性分析算法"><a href="#2-2-可达性分析算法" class="headerlink" title="2.2 可达性分析算法"></a>2.2 可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/72762049.jpg" alt="可达性分析算法 "></p><h3 id="2-3-再谈引用"><a href="#2-3-再谈引用" class="headerlink" title="2.3 再谈引用"></a>2.3 再谈引用</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><p><strong>1．强引用（StrongReference）</strong></p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p><strong>2．软引用（SoftReference）</strong></p><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>3．弱引用（WeakReference）</strong></p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 </p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 </p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="2-4-不可达的对象并非“非死不可”"><a href="#2-4-不可达的对象并非“非死不可”" class="headerlink" title="2.4 不可达的对象并非“非死不可”"></a>2.4 不可达的对象并非“非死不可”</h3><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p><p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><h3 id="2-5-如何判断一个常量是废弃常量"><a href="#2-5-如何判断一个常量是废弃常量" class="headerlink" title="2.5 如何判断一个常量是废弃常量"></a>2.5 如何判断一个常量是废弃常量</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p><p>假如在常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。</p><p>注意：我们在 <a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484303&idx=1&sn=af0fd436cef755463f59ee4dd0720cbd&chksm=fd9855eecaefdcf8d94ac581cfda4e16c8a730bda60c3b50bc55c124b92f23b6217f7f8e58d5&token=506869459&lang=zh_CN#rd" target="_blank" rel="noopener">可能是把 Java 内存区域讲的最清楚的一篇文章 </a> 也讲了 JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</p><h3 id="2-6-如何判断一个类是无用的类"><a href="#2-6-如何判断一个类是无用的类" class="headerlink" title="2.6 如何判断一个类是无用的类"></a>2.6 如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3 垃圾收集算法"></a>3 垃圾收集算法</h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.jpg" alt="垃圾收集算法分类"></p><h3 id="3-1-标记-清除算法"><a href="#3-1-标记-清除算法" class="headerlink" title="3.1 标记-清除算法"></a>3.1 标记-清除算法</h3><p>该算法分为“标记”和“清除”阶段：首先比较出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p><ol><li><strong>效率问题</strong></li><li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li></ol><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/63707281.jpg" alt="公众号" width="500px"><h3 id="3-2-复制算法"><a href="#3-2-复制算法" class="headerlink" title="3.2 复制算法"></a>3.2 复制算法</h3><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/90984624.jpg" alt="公众号" width="500px"><h3 id="3-3-标记-整理算法"><a href="#3-3-标记-整理算法" class="headerlink" title="3.3 标记-整理算法"></a>3.3 标记-整理算法</h3><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/94057049.jpg" alt="标记-整理算法 "></p><h3 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p><p><strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？</p><p>根据上面的对分代收集算法的介绍回答。</p><h2 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4 垃圾收集器"></a>4 垃圾收集器</h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="垃圾收集器分类"></p><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p><h3 id="4-1-Serial-收集器"><a href="#4-1-Serial-收集器" class="headerlink" title="4.1 Serial 收集器"></a>4.1 Serial 收集器</h3><p>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p> <strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/46873026.jpg" alt=" Serial 收集器 "></p><p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p><h3 id="4-2-ParNew-收集器"><a href="#4-2-ParNew-收集器" class="headerlink" title="4.2 ParNew 收集器"></a>4.2 ParNew 收集器</h3><p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p><p> <strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/22018368.jpg" alt="ParNew 收集器 "></p><p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><p><strong>并行和并发概念补充：</strong></p><ul><li><p><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p></li><li><p><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</p></li></ul><h3 id="4-3-Parallel-Scavenge-收集器"><a href="#4-3-Parallel-Scavenge-收集器" class="headerlink" title="4.3 Parallel Scavenge 收集器"></a>4.3 Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器也是使用复制算法的多线程收集器，它看上去几乎和ParNew都一样。 <strong>那么它有什么特别之处呢？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC </span><br><span class="line"></span><br><span class="line">    使用 Parallel 收集器+ 老年代串行</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line"></span><br><span class="line">    使用 Parallel 收集器+ 老年代并行</span><br></pre></td></tr></table></figure><p><strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在困难的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><p> <strong>新生代采用复制算法，老年代采用标记-整理算法。</strong><br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/22018368.jpg" alt="Parallel Scavenge 收集器 "></p><h3 id="4-4-Serial-Old-收集器"><a href="#4-4-Serial-Old-收集器" class="headerlink" title="4.4.Serial Old 收集器"></a>4.4.Serial Old 收集器</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><h3 id="4-5-Parallel-Old-收集器"><a href="#4-5-Parallel-Old-收集器" class="headerlink" title="4.5 Parallel Old 收集器"></a>4.5 Parallel Old 收集器</h3><p> <strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><h3 id="4-6-CMS-收集器"><a href="#4-6-CMS-收集器" class="headerlink" title="4.6 CMS 收集器"></a>4.6 CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/82825079.jpg" alt="CMS 垃圾收集器 "></p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h3 id="4-7-G1-收集器"><a href="#4-7-G1-收集器" class="headerlink" title="4.7 G1 收集器"></a>4.7 G1 收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记–清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong>。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li><li><a href="https://my.oschina.net/hosee/blog/644618" target="_blank" rel="noopener">https://my.oschina.net/hosee/blog/644618</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></li></ul><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p><p><strong>《Java面试突击》:</strong> 由本文档衍生的专为面试而生的《Java面试突击》V2.0 PDF 版本<a href="#公众号">公众号</a>后台回复 <strong>“Java面试突击”</strong> 即可免费领取！</p><p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源<a href="#公众号">公众号</a>后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。 </p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/qrcode_for_gh_ea338256af79_258.jpg" alt="我的公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 内存区域详解</title>
      <link href="/posts/482f70b7/"/>
      <url>/posts/482f70b7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><p>点击关注<a href="#公众号">公众号</a>及时获取笔主最新更新文章，并可免费领取本文档配套的《Java面试突击》以及Java工程师必备学习资源。</p><h1 id="Java-内存区域详解"><a href="#Java-内存区域详解" class="headerlink" title="Java 内存区域详解"></a>Java 内存区域详解</h1><p>如果没有特殊说明，都是针对的是 HotSpot 虚拟机。</p><h2 id="写在前面-常见面试题"><a href="#写在前面-常见面试题" class="headerlink" title="写在前面 (常见面试题)"></a>写在前面 (常见面试题)</h2><h3 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h3><ul><li><strong>介绍下 Java 内存区域（运行时数据区）</strong></li><li><strong>Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）</strong></li><li><strong>对象的访问定位的两种方式（句柄和直接指针两种方式）</strong></li></ul><h3 id="拓展问题"><a href="#拓展问题" class="headerlink" title="拓展问题"></a>拓展问题</h3><ul><li><strong>String 类和常量池</strong></li><li><strong>8 种基本类型的包装类和常量池</strong></li></ul><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p><h2 id="二-运行时数据区域"><a href="#二-运行时数据区域" class="headerlink" title="二 运行时数据区域"></a>二 运行时数据区域</h2><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK. 1.8 和之前的版本略有不同，下面会介绍到。</p><p><strong>JDK 1.8 之前：</strong></p><div align="center">  <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/JVM运行时数据区域.png" width="600px"/></div>**JDK 1.8 ：**<div align="center">  <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3Java运行时数据区域JDK1.8.png" width="600px"/></div><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区</li><li>直接内存 (非运行时数据区的一部分)</li></ul><h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p><p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p><p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p><strong>注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p><h3 id="2-2-Java-虚拟机栈"><a href="#2-2-Java-虚拟机栈" class="headerlink" title="2.2 Java 虚拟机栈"></a>2.2 Java 虚拟机栈</h3><p><strong>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p><p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p><p><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p><strong>Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。</strong></p><ul><li><strong>StackOverFlowError：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li><li><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 错误。</li></ul><p>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p><p><strong>扩展：那么方法/函数如何调用？</strong></p><p>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p><p>Java 方法有两种返回方式：</p><ol><li>return 语句。</li><li>抛出异常。</li></ol><p>不管哪种返回方式都会导致栈帧被弹出。</p><h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。</p><h3 id="2-4-堆"><a href="#2-4-堆" class="headerlink" title="2.4 堆"></a>2.4 堆</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p><strong>Java世界中“几乎”所有的对象都在堆中分配，但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</strong></p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p>在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永生代(Permanent Generation)</li></ol><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-JDK7.jpg" alt="JVM堆内存结构-JDK7"></p><p>JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-jdk8.jpg" alt="JVM堆内存结构-JDK8"></p><p><strong>上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。</strong></p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加  1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><blockquote><p>修正（<a href="https://github.com/Snailclimb/JavaGuide/issues/552" target="_blank" rel="noopener">issue552</a>）：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。</p><p><strong>动态年龄计算的代码如下</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="keyword">size_t</span> survivor_capacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line">  <span class="keyword">size_t</span> desired_survivor_size = (<span class="keyword">size_t</span>)((((<span class="keyword">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">  uint age = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line">    total += sizes[age];<span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line">    <span class="keyword">if</span> (total &gt; desired_survivor_size) <span class="keyword">break</span>;</span><br><span class="line">    age++;</span><br><span class="line">  &#125;</span><br><span class="line">  uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>堆这里最容易出现的就是  OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p><ol><li><strong><code>OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li><li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发<code>java.lang.OutOfMemoryError: Java heap space</code> 错误。(和本机物理内存无关，和你配置的内存大小有关！)</li><li>……</li></ol><h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p><p>方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。</p><h4 id="2-5-1-方法区和永久代的关系"><a href="#2-5-1-方法区和永久代的关系" class="headerlink" title="2.5.1 方法区和永久代的关系"></a>2.5.1 方法区和永久代的关系</h4><blockquote><p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。  <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p></blockquote><h4 id="2-5-2-常用参数"><a href="#2-5-2-常用参数" class="headerlink" title="2.5.2 常用参数"></a>2.5.2 常用参数</h4><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N <span class="comment">//方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></table></figure><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p><p>下面是一些常用参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure><p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p><h4 id="2-5-3-为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢"><a href="#2-5-3-为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢" class="headerlink" title="2.5.3 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?"></a>2.5.3 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</h4><ol><li>整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。<blockquote><p>当你元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p></blockquote></li></ol><p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。  </p><ol start="2"><li><p>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。  </p></li><li><p>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p></li></ol><h3 id="2-6-运行时常量池"><a href="#2-6-运行时常量池" class="headerlink" title="2.6 运行时常量池"></a>2.6 运行时常量池</h3><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p><p><del><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></del> </p><blockquote><p>修正(<a href="https://github.com/Snailclimb/JavaGuide/issues/747" target="_blank" rel="noopener">issue747</a>，<a href="https://blog.csdn.net/q5706503/article/details/84640762" target="_blank" rel="noopener">reference</a>)： </p><ol><li><strong>JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代</strong></li><li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代</strong> 。</li><li><strong>JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong> </li></ol></blockquote><p>相关问题：JVM 常量池中存储的是对象还是引用呢？： <a href="https://www.zhihu.com/question/57109429/answer/151717241" target="_blank" rel="noopener">https://www.zhihu.com/question/57109429/answer/151717241</a>  by RednaxelaFX</p><h3 id="2-7-直接内存"><a href="#2-7-直接内存" class="headerlink" title="2.7 直接内存"></a>2.7 直接内存</h3><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong></p><p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p><p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><h2 id="三-HotSpot-虚拟机对象探秘"><a href="#三-HotSpot-虚拟机对象探秘" class="headerlink" title="三 HotSpot 虚拟机对象探秘"></a>三 HotSpot 虚拟机对象探秘</h2><p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p><h3 id="3-1-对象的创建"><a href="#3-1-对象的创建" class="headerlink" title="3.1 对象的创建"></a>3.1 对象的创建</h3><p>下图便是 Java 对象的创建过程，我建议最好是能默写出来，并且要掌握每一步在做什么。<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="Java创建对象的过程"></p><h4 id="Step1-类加载检查"><a href="#Step1-类加载检查" class="headerlink" title="Step1:类加载检查"></a>Step1:类加载检查</h4><p> 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h4 id="Step2-分配内存"><a href="#Step2-分配内存" class="headerlink" title="Step2:分配内存"></a>Step2:分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong>内存分配的两种方式：（补充内容，需要掌握）</strong></p><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.png" alt="内存分配的两种方式"></p><p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li></ul><h4 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3:初始化零值"></a>Step3:初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4:设置对象头"></a>Step4:设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="Step5-执行-init-方法"><a href="#Step5-执行-init-方法" class="headerlink" title="Step5:执行 init 方法"></a>Step5:执行 init 方法</h4><p> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="3-2-对象的内存布局"><a href="#3-2-对象的内存布局" class="headerlink" title="3.2 对象的内存布局"></a>3.2 对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="3-3-对象的访问定位"><a href="#3-3-对象的访问定位" class="headerlink" title="3.3 对象的访问定位"></a>3.3 对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>①使用句柄</strong>和<strong>②直接指针</strong>两种：</p><ol><li><p><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.png" alt="对象的访问定位-使用句柄"></p></li><li><p><strong>直接指针：</strong>  如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</p></li></ol><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png" alt="对象的访问定位-直接指针"></p><p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p><h2 id="四-重点补充内容"><a href="#四-重点补充内容" class="headerlink" title="四  重点补充内容"></a>四  重点补充内容</h2><h3 id="4-1-String-类和常量池"><a href="#4-1-String-类和常量池" class="headerlink" title="4.1 String 类和常量池"></a>4.1 String 类和常量池</h3><p><strong>String 对象的两种创建方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abcd"</span>;<span class="comment">//先检查字符串常量池中有没有"abcd"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向"abcd""；</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);<span class="comment">//堆中创建一个新的对象</span></span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);<span class="comment">//堆中创建一个新的对象</span></span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str2==str3);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>这两种不同的创建方法是有差别的。</p><ul><li>第一种方式是在常量池中拿对象；</li><li>第二种方式是直接在堆内存空间创建一个新的对象。</li></ul><p>记住一点：<strong>只要使用 new 方法，便需要创建新的对象。</strong></p><p>再给大家一个图应该更容易理解，图片来源：<a href="https://www.journaldev.com/797/what-is-java-string-pool" target="_blank" rel="noopener">https://www.journaldev.com/797/what-is-java-string-pool</a>：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3String-Pool-Java1-450x249.png" alt="String-Pool-Java"></p><p><strong>String 类型的常量池比较特殊。它的主要使用方法有两种：</strong></p><ul><li>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</li><li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"计算机"</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 = <span class="string">"计算机"</span>;</span><br><span class="line">System.out.println(s2);<span class="comment">//计算机</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，</span></span><br><span class="line">System.out.println(s3 == s2);<span class="comment">//true，因为两个都是常量池中的 String 对象</span></span><br></pre></td></tr></table></figure><p><strong>字符串拼接:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"str"</span>;</span><br><span class="line">String str2 = <span class="string">"ing"</span>;</span><br><span class="line"> </span><br><span class="line">String str3 = <span class="string">"str"</span> + <span class="string">"ing"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">String str4 = str1 + str2; <span class="comment">//在堆上创建的新的对象  </span></span><br><span class="line">String str5 = <span class="string">"string"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5-%E5%B8%B8%E9%87%8F%E6%B1%A02.png" alt="字符串拼接"></p><p>尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。</p><h3 id="4-2-String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#4-2-String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="4.2 String s1 = new String(“abc”);这句话创建了几个字符串对象？"></a>4.2 String s1 = new String(“abc”);这句话创建了几个字符串对象？</h3><p><strong>将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</strong></p><p><strong>验证：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);<span class="comment">// 堆内存的地址值</span></span><br><span class="line">String s2 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。</span></span><br><span class="line">System.out.println(s1.equals(s2));<span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure><h3 id="4-3-8-种基本类型的包装类和常量池"><a href="#4-3-8-种基本类型的包装类和常量池" class="headerlink" title="4.3 8 种基本类型的包装类和常量池"></a>4.3 8 种基本类型的包装类和常量池</h3><p><strong>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。</strong> 为啥把缓存设置为[-128，127]区间？（<a href="https://github.com/Snailclimb/JavaGuide/issues/461" target="_blank" rel="noopener">参见issue/461</a>）性能和资源之间的权衡。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterCache</span> </span>&#123;         </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CharacterCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> Character[<span class="number">127</span> + <span class="number">1</span>];          </span><br><span class="line">    <span class="keyword">static</span> &#123;             </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)                 </span><br><span class="line">            cache[i] = <span class="keyword">new</span> Character((<span class="keyword">char</span>)i);         </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">33</span>;</span><br><span class="line">Integer i2 = <span class="number">33</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// 输出 true</span></span><br><span class="line">Integer i11 = <span class="number">333</span>;</span><br><span class="line">Integer i22 = <span class="number">333</span>;</span><br><span class="line">System.out.println(i11 == i22);<span class="comment">// 输出 false</span></span><br><span class="line">Double i3 = <span class="number">1.2</span>;</span><br><span class="line">Double i4 = <span class="number">1.2</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure><p><strong>Integer 缓存源代码：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>应用场景：</strong></p><ol><li>Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。</li><li>Integer i1 = new Integer(40);这种情况下会创建新的对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//输出 false</span></span><br></pre></td></tr></table></figure><p><strong>Integer 比较更丰富的一个例子:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"i1=i2   "</span> + (i1 == i2));</span><br><span class="line">System.out.println(<span class="string">"i1=i2+i3   "</span> + (i1 == i2 + i3));</span><br><span class="line">System.out.println(<span class="string">"i1=i4   "</span> + (i1 == i4));</span><br><span class="line">System.out.println(<span class="string">"i4=i5   "</span> + (i4 == i5));</span><br><span class="line">System.out.println(<span class="string">"i4=i5+i6   "</span> + (i4 == i5 + i6));   </span><br><span class="line">System.out.println(<span class="string">"40=i5+i6   "</span> + (<span class="number">40</span> == i5 + i6));</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i1&#x3D;i2   true</span><br><span class="line">i1&#x3D;i2+i3   true</span><br><span class="line">i1&#x3D;i4   false</span><br><span class="line">i4&#x3D;i5   false</span><br><span class="line">i4&#x3D;i5+i6   true</span><br><span class="line">40&#x3D;i5+i6   true</span><br></pre></td></tr></table></figure><p>解释：</p><p>语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li><li>《实战 java 虚拟机》</li><li><a href="https://docs.oracle.com/javase/specs/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/index.html</a></li><li><a href="http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/" target="_blank" rel="noopener">http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/</a></li><li><a href="https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou" target="_blank" rel="noopener">https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou</a></li><li><a href="https://stackoverflow.com/questions/9095748/method-area-and-permgen" target="_blank" rel="noopener">https://stackoverflow.com/questions/9095748/method-area-and-permgen</a></li><li>深入解析String#intern<a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></li></ul><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p><p><strong>《Java面试突击》:</strong> 由本文档衍生的专为面试而生的《Java面试突击》V2.0 PDF 版本<a href="#公众号">公众号</a>后台回复 <strong>“Java面试突击”</strong> 即可免费领取！</p><p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源<a href="#公众号">公众号</a>后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。 </p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/qrcode_for_gh_ea338256af79_258.jpg" alt="我的公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载器</title>
      <link href="/posts/e1bf9df3/"/>
      <url>/posts/e1bf9df3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><p>点击关注<a href="#公众号">公众号</a>及时获取笔主最新更新文章，并可免费领取本文档配套的《Java面试突击》以及Java工程师必备学习资源。</p><blockquote><p>公众号JavaGuide 后台回复关键字“1”，免费获取JavaGuide配套的Java工程师必备学习资源(文末有公众号二维码)。</p></blockquote><h2 id="回顾一下类加载过程"><a href="#回顾一下类加载过程" class="headerlink" title="回顾一下类加载过程"></a>回顾一下类加载过程</h2><p>类加载过程：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步:<strong>验证-&gt;准备-&gt;解析</strong>。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="类加载过程"></p><p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</p><p>所有的类都由类加载器加载，加载的作用就是将 .class文件加载到内存。</p><h2 id="类加载器总结"><a href="#类加载器总结" class="headerlink" title="类加载器总结"></a>类加载器总结</h2><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p><ol><li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的jar包和类或者或被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li><li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的jar包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的jar包。</li><li><strong>AppClassLoader(应用程序类加载器)</strong> :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。</li></ol><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h3 id="双亲委派模型介绍"><a href="#双亲委派模型介绍" class="headerlink" title="双亲委派模型介绍"></a>双亲委派模型介绍</h3><p>每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 <strong>双亲委派模型</strong> 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/classloader_WPS%E5%9B%BE%E7%89%87.png" alt="ClassLoader"></p><p>每个类加载都有一个父类加载器，我们通过下面的程序来验证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ClassLodarDemo's ClassLoader is "</span> + ClassLoaderDemo<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        System.out.println(<span class="string">"The Parent of ClassLodarDemo's ClassLoader is "</span> + ClassLoaderDemo<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>().<span class="title">getParent</span>())</span>;</span><br><span class="line">        System.out.println(<span class="string">"The GrandParent of ClassLodarDemo's ClassLoader is "</span> + ClassLoaderDemo<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>().<span class="title">getParent</span>().<span class="title">getParent</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLodarDemo&#39;s ClassLoader is sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">The Parent of ClassLodarDemo&#39;s ClassLoader is sun.misc.Launcher$ExtClassLoader@1b6d3586</span><br><span class="line">The GrandParent of ClassLodarDemo&#39;s ClassLoader is null</span><br></pre></td></tr></table></figure><p><code>AppClassLoader</code>的父类加载器为<code>ExtClassLoader</code><br><code>ExtClassLoader</code>的父类加载器为null，<strong>null并不代表<code>ExtClassLoader</code>没有父类加载器，而是 <code>BootstrapClassLoader</code></strong> 。</p><p>其实这个双亲翻译的容易让别人误解，我们一般理解的双亲都是父母，这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个 Mother ClassLoader 和一个 Father ClassLoader 。另外，类加载器之间的“父子”关系也不是通过继承来体现的，是由“优先级”来决定。官方API文档对这部分的描述如下:</p><blockquote><p>The Java platform uses a delegation model for loading classes. <strong>The basic idea is that every class loader has a “parent” class loader.</strong> When loading a class, a class loader first “delegates” the search for the class to its parent class loader before attempting to find the class itself.</p></blockquote><h3 id="双亲委派模型实现源码分析"><a href="#双亲委派模型实现源码分析" class="headerlink" title="双亲委派模型实现源码分析"></a>双亲委派模型实现源码分析</h3><p>双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 <code>java.lang.ClassLoader</code> 的 <code>loadClass()</code> 中，相关代码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent; </span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先，检查请求的类是否已经被加载过</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;<span class="comment">//父加载器不为空，调用父加载器loadClass()方法处理</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                   <span class="comment">//抛出异常说明父类加载器无法完成加载请求</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    <span class="comment">//自己尝试加载</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h3><p>双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</p><h3 id="如果我们不想用双亲委派模型怎么办？"><a href="#如果我们不想用双亲委派模型怎么办？" class="headerlink" title="如果我们不想用双亲委派模型怎么办？"></a>如果我们不想用双亲委派模型怎么办？</h3><p>为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写 <code>loadClass()</code> 即可。</p><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>除了 <code>BootstrapClassLoader</code> 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>。如果我们要自定义自己的类加载器，很明显需要继承 <code>ClassLoader</code>。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://blog.csdn.net/xyang81/article/details/7292380" target="_blank" rel="noopener">https://blog.csdn.net/xyang81/article/details/7292380</a></li><li><a href="https://juejin.im/post/5c04892351882516e70dcc9b" target="_blank" rel="noopener">https://juejin.im/post/5c04892351882516e70dcc9b</a></li><li><a href="http://gityuan.com/2016/01/24/java-classloader/" target="_blank" rel="noopener">http://gityuan.com/2016/01/24/java-classloader/</a></li></ul><h3 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h3><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p><p><strong>《Java面试突击》:</strong> 由本文档衍生的专为面试而生的《Java面试突击》V2.0 PDF 版本<a href="#公众号">公众号</a>后台回复 <strong>“Java面试突击”</strong> 即可免费领取！</p><p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源<a href="#公众号">公众号</a>后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。 </p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/qrcode_for_gh_ea338256af79_258.jpg" alt="我的公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类文件结构</title>
      <link href="/posts/e1bf9df3/"/>
      <url>/posts/e1bf9df3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><p>点击关注<a href="#公众号">公众号</a>及时获取笔主最新更新文章，并可免费领取本文档配套的《Java面试突击》以及Java工程师必备学习资源。</p><h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><p>Clojure（Lisp 语言的一种方言）、Groovy、Scala 等语言都是运行在 Java 虚拟机之上。下图展示了不同的语言被不同的编译器编译成<code>.class</code>文件最终运行在 Java 虚拟机之上。<code>.class</code>文件的二进制格式可以使用 <a href="https://www.x-ways.net/winhex/" target="_blank" rel="noopener">WinHex</a> 查看。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/bg/desktop%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88.png" alt="java虚拟机"></p><p><strong>可以说<code>.class</code>文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。</strong></p><h2 id="二-Class-文件结构总结"><a href="#二-Class-文件结构总结" class="headerlink" title="二 Class 文件结构总结"></a>二 Class 文件结构总结</h2><p>根据 Java 虚拟机规范，类文件由单个 ClassFile 结构组成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面详细介绍一下 Class 文件结构涉及到的一些组件。</p><p><strong>Class文件字节码结构组织示意图</strong> （之前在网上保存的，非常不错，原出处不明）：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E7%BB%84%E7%BB%87%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="类文件字节码结构组织示意图"></p><h3 id="2-1-魔数"><a href="#2-1-魔数" class="headerlink" title="2.1 魔数"></a>2.1 魔数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4             magic; <span class="comment">//Class 文件的标志</span></span><br></pre></td></tr></table></figure><p>每个 Class 文件的头四个字节称为魔数（Magic Number）,它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接收的 Class 文件</strong>。 </p><p>程序设计者很多时候都喜欢用一些特殊的数字表示固定的文件类型或者其它特殊的含义。</p><h3 id="2-2-Class-文件版本"><a href="#2-2-Class-文件版本" class="headerlink" title="2.2 Class 文件版本"></a>2.2 Class 文件版本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">u2             major_version;<span class="comment">//Class 的大版本号</span></span><br></pre></td></tr></table></figure><p>紧接着魔数的四个字节存储的是 Class 文件的版本号：第五和第六是<strong>次版本号</strong>，第七和第八是<strong>主版本号</strong>。</p><p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。</p><h3 id="2-3-常量池"><a href="#2-3-常量池" class="headerlink" title="2.3 常量池"></a>2.3 常量池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br></pre></td></tr></table></figure><p>紧接着主次版本号之后的是常量池，常量池的数量是 constant_pool_count-1（<strong>常量池计数器是从1开始计数的，将第0项常量空出来是有特殊考虑的，索引值为0代表“不引用任何一个常量池项”</strong>）。</p><p>常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量： </p><ul><li>类和接口的全限定名 </li><li>字段的名称和描述符 </li><li>方法的名称和描述符</li></ul><p>常量池中每一项常量都是一个表，这14种表有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．</strong></p><table><thead><tr><th align="center">类型</th><th align="center">标志（tag）</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">CONSTANT_utf8_info</td><td align="center">1</td><td align="center">UTF-8编码的字符串</td></tr><tr><td align="center">CONSTANT_Integer_info</td><td align="center">3</td><td align="center">整形字面量</td></tr><tr><td align="center">CONSTANT_Float_info</td><td align="center">4</td><td align="center">浮点型字面量</td></tr><tr><td align="center">CONSTANT_Long_info</td><td align="center">５</td><td align="center">长整型字面量</td></tr><tr><td align="center">CONSTANT_Double_info</td><td align="center">６</td><td align="center">双精度浮点型字面量</td></tr><tr><td align="center">CONSTANT_Class_info</td><td align="center">７</td><td align="center">类或接口的符号引用</td></tr><tr><td align="center">CONSTANT_String_info</td><td align="center">８</td><td align="center">字符串类型字面量</td></tr><tr><td align="center">CONSTANT_Fieldref_info</td><td align="center">９</td><td align="center">字段的符号引用</td></tr><tr><td align="center">CONSTANT_Methodref_info</td><td align="center">10</td><td align="center">类中方法的符号引用</td></tr><tr><td align="center">CONSTANT_InterfaceMethodref_info</td><td align="center">11</td><td align="center">接口中方法的符号引用</td></tr><tr><td align="center">CONSTANT_NameAndType_info</td><td align="center">12</td><td align="center">字段或方法的符号引用</td></tr><tr><td align="center">CONSTANT_MothodType_info</td><td align="center">16</td><td align="center">标志方法类型</td></tr><tr><td align="center">CONSTANT_MethodHandle_info</td><td align="center">15</td><td align="center">表示方法句柄</td></tr><tr><td align="center">CONSTANT_InvokeDynamic_info</td><td align="center">18</td><td align="center">表示一个动态方法调用点</td></tr></tbody></table><p><code>.class</code> 文件可以通过<code>javap -v class类名</code> 指令来看一下其常量池中的信息(<code>javap -v  class类名-&gt; temp.txt</code> ：将结果输出到 temp.txt 文件)。</p><h3 id="2-4-访问标志"><a href="#2-4-访问标志" class="headerlink" title="2.4 访问标志"></a>2.4 访问标志</h3><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</p><p>类访问和属性修饰符:</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt="类访问和属性修饰符"></p><p>我们定义了一个 Employee 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.snailclimb.bean;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>javap -v class类名</code> 指令来看一下类的访问标志。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%9F%A5%E7%9C%8B%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt="查看类的访问标志"></p><h3 id="2-5-当前类索引-父类索引与接口索引集合"><a href="#2-5-当前类索引-父类索引与接口索引集合" class="headerlink" title="2.5 当前类索引,父类索引与接口索引集合"></a>2.5 当前类索引,父类索引与接口索引集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br></pre></td></tr></table></figure><p><strong>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</strong></p><p><strong>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按<code>implents</code>(如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</strong></p><h3 id="2-6-字段表集合"><a href="#2-6-字段表集合" class="headerlink" title="2.6 字段表集合"></a>2.6 字段表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段的个数</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br></pre></td></tr></table></figure><p>字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</p><p><strong>field info(字段表) 的结构:</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="字段表的结构 "></p><ul><li><strong>access_flags:</strong>  字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</li><li><strong>name_index:</strong> 对常量池的引用，表示的字段的名称；</li><li><strong>descriptor_index:</strong> 对常量池的引用，表示字段和方法的描述符；</li><li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li><li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li></ul><p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p><p><strong>字段的 access_flags 的取值:</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%AD%97%E6%AE%B5%E7%9A%84access_flags%E7%9A%84%E5%8F%96%E5%80%BC.png" alt="字段的access_flags的取值"></p><h3 id="2-7-方法表集合"><a href="#2-7-方法表集合" class="headerlink" title="2.7 方法表集合"></a>2.7 方法表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;<span class="comment">//Class 文件的方法的数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br></pre></td></tr></table></figure><p>methods_count 表示方法的数量，而 method_info 表示的方法表。</p><p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。 </p><p><strong>method_info(方法表的) 结构:</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="方法表的结构"></p><p><strong>方法表的 access_flag 取值：</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84access_flag%E7%9A%84%E6%89%80%E6%9C%89%E6%A0%87%E5%BF%97%E4%BD%8D.png" alt="方法表的 access_flag 取值"></p><p>注意：因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p><h3 id="2-8-属性表集合"><a href="#2-8-属性表集合" class="headerlink" title="2.8 属性表集合"></a>2.8 属性表集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br></pre></td></tr></table></figure><p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html</a></li><li><a href="https://coolshell.cn/articles/9229.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9229.html</a></li><li><a href="https://blog.csdn.net/luanlouis/article/details/39960815" target="_blank" rel="noopener">https://blog.csdn.net/luanlouis/article/details/39960815</a></li><li>《实战 Java 虚拟机》</li></ul><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p><p><strong>《Java面试突击》:</strong> 由本文档衍生的专为面试而生的《Java面试突击》V2.0 PDF 版本<a href="#公众号">公众号</a>后台回复 <strong>“Java面试突击”</strong> 即可免费领取！</p><p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源<a href="#公众号">公众号</a>后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。 </p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/qrcode_for_gh_ea338256af79_258.jpg" alt="我的公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载过程</title>
      <link href="/posts/6da5924e/"/>
      <url>/posts/6da5924e/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><p>点击关注<a href="#公众号">公众号</a>及时获取笔主最新更新文章，并可免费领取本文档配套的《Java面试突击》以及Java工程师必备学习资源。</p><blockquote><p>公众号JavaGuide 后台回复关键字“1”，免费获取JavaGuide配套的Java工程师必备学习资源(文末有公众号二维码)。</p></blockquote><h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>一个类的完整生命周期如下：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E5%AE%8C%E5%96%84.png" alt=""></p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</p><p>系统加载 Class 类型的文件主要三步:<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步:<strong>验证-&gt;准备-&gt;解析</strong>。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt=""></p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>类加载过程的第一步，主要完成下面3件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口</li></ol><p>虚拟机规范多上面这3点并不具体，因此是非常灵活的。比如：”通过全类名获取定义此类的二进制字节流” 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 ZIP 包中读取（日后出现的JAR、EAR、WAR格式的基础）、其他文件生成（典型应用就是JSP）等等。</p><p><strong>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</strong></p><p>类加载器、双亲委派模型也是非常重要的知识点，这部分内容会在后面的文章中单独介绍到。</p><p>加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5.png" alt="验证阶段示意图"></p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ol><li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>这里所设置的初始值”通常情况”下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 fianl 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被赋值为 111。</li></ol><p><strong>基本数据类型的零值：</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png" alt="基本数据类型的零值"></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</p><p>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器 <code>&lt;clinit&gt; ()</code>方法的过程。</p><p>对于<code>&lt;clinit&gt;（）</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt;（）</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。</p><p>对于初始化阶段，虚拟机严格规范了有且只有5种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p><ol><li>当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。<ul><li>当jvm执行new指令时会初始化类。即当程序创建一个类的实例对象。</li><li>当jvm执行getstatic指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li><li>当jvm执行putstatic指令时会初始化类。即程序给类的静态变量赋值。</li><li>当jvm执行invokestatic指令时会初始化类。即程序调用类的静态方法。</li></ul></li><li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如Class.forname(“…”),newInstance()等等。 ，如果类没初始化，需要触发其初始化。</li><li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li><li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。</li><li>MethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用，<br>就必须先使用findStaticVarHandle来初始化要调用的类。</li><li><strong>「补充，来自<a href="https://github.com/Snailclimb/JavaGuide/issues/745" target="_blank" rel="noopener">issue745</a>」</strong> 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><blockquote><p>卸载这部分内容来自 <a href="https://github.com/Snailclimb/JavaGuide/issues/662" target="_blank" rel="noopener">issue#662</a>由 <strong><a href="https://github.com/guang19" target="_blank" rel="noopener">guang19</a></strong>  补充完善。</p></blockquote><p>卸载类即该类的Class对象被GC。</p><p>卸载类需要满足3个要求:</p><ol><li>该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被GC</li></ol><p>所以，在JVM生命周期类，由jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p><p>只要想通一点就好了，jdk自带的BootstrapClassLoader,PlatformClassLoader,AppClassLoader负责加载jdk提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p><p><strong>参考</strong></p><ul><li>《深入理解Java虚拟机》</li><li>《实战Java虚拟机》</li><li><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html</a></li></ul><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p><p><strong>《Java面试突击》:</strong> 由本文档衍生的专为面试而生的《Java面试突击》V2.0 PDF 版本<a href="#公众号">公众号</a>后台回复 <strong>“Java面试突击”</strong> 即可免费领取！</p><p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源<a href="#公众号">公众号</a>后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。 </p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/qrcode_for_gh_ea338256af79_258.jpg" alt="我的公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM知识点汇总</title>
      <link href="/posts/f1c16df7/"/>
      <url>/posts/f1c16df7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><p>无论什么级别的Java从业者，JVM都是进阶时必须迈过的坎。不管是工作还是面试中，JVM都是必考题。如果不懂JVM的话，薪酬会非常吃亏（近70%的面试者挂在JVM上了）。</p><p>掌握了JVM机制，就等于学会了深层次解决问题的方法。对于Java开发者而言，只有熟悉底层虚拟机的运行机制，才能通过JVM日志深入到字节码的层次去分析排查问题，发现隐性的系统缺陷，进而提升系统性能。</p><p>一些技术人员开发工具用得很熟练，触及JVM问题时却是模棱两可，甚至连内存模型和内存区域，HotSpot和JVM规范，都混淆不清。工作很长时间，在生产时还在用缺省参数来直接启动，以致系统运行时出现性能、稳定性等问题时束手无措，不知该如何追踪排查。久而久之，这对自己的职业成长是极为不利的。</p><p>掌握JVM，是深入Java技术栈的必经之路。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://i.loli.net/2019/09/10/HsJXU8S4oVtCTM7.png" alt="jv.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大白话带你认识JVM</title>
      <link href="/posts/b9af30d5/"/>
      <url>/posts/b9af30d5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>来自掘金用户：<a href="https://juejin.im/user/5c2400afe51d45451758aa96" target="_blank" rel="noopener">说出你的愿望吧丷</a>投稿，原文地址：<a href="https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28" target="_blank" rel="noopener">https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果在文中用词或者理解方面出现问题，欢迎指出。此文旨在提及和而不深究，但会尽量效率地把知识点都抛出来</p><h2 id="一、JVM的基本介绍"><a href="#一、JVM的基本介绍" class="headerlink" title="一、JVM的基本介绍"></a>一、JVM的基本介绍</h2><p>JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现···</p><p>好，其实抛开这么专业的句子不说，就知道JVM其实就类似于一台小电脑运行在windows或者linux这些操作系统环境下即可。它直接和操作系统进行交互，与硬件不直接交互，可操作系统可以帮我们完成和硬件进行交互的工作。<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/d947f91e44c44c6c80222b49c2dee859-new-image19a36451-d673-486e-9c8e-3c7d8ab66929.png" alt=""></p><h3 id="1-1-Java文件是如何被运行的"><a href="#1-1-Java文件是如何被运行的" class="headerlink" title="1.1 Java文件是如何被运行的"></a>1.1 Java文件是如何被运行的</h3><p>比如我们现在写了一个 HelloWorld.java 好了，那这个 HelloWorld.java 抛开所有东西不谈，那是不是就类似于一个文本文件，只是这个文本文件它写的都是英文，而且有一定的缩进而已。</p><p>那我们的 <strong>JVM</strong> 是不认识文本文件的，所以它需要一个 <strong>编译</strong> ，让其成为一个它会读二进制文件的 <strong>HelloWorld.class</strong> </p><h4 id="①-类加载器"><a href="#①-类加载器" class="headerlink" title="① 类加载器"></a>① 类加载器</h4><p>如果 <strong>JVM</strong> 想要执行这个 <strong>.class</strong> 文件，我们需要将其装进一个 <strong>类加载器</strong> 中，它就像一个搬运工一样，会把所有的 <strong>.class</strong> 文件全部搬进JVM里面来。<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/81f1813f371c40ffa1c1f6d78bc49ed9-new-image28314ec8-066f-451e-8373-4517917d6bf7.png" alt=""></p><h4 id="②-方法区"><a href="#②-方法区" class="headerlink" title="② 方法区"></a>② 方法区</h4><p><strong>方法区</strong> 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等</p><p>类加载器将 .class 文件搬过来就是先丢到这一块上</p><h4 id="③-堆"><a href="#③-堆" class="headerlink" title="③ 堆"></a>③ 堆</h4><p><strong>堆</strong> 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 <strong>线程共享区域</strong> 。也就是说它们都是 <strong>线程不安全</strong> 的</p><h4 id="④-栈"><a href="#④-栈" class="headerlink" title="④ 栈"></a>④ 栈</h4><p><strong>栈</strong> 这是我们的代码运行空间。我们编写的每一个方法都会放到 <strong>栈</strong> 里面运行。</p><p>我们会听说过 本地方法栈 或者 本地方法接口 这两个名词，不过我们基本不会涉及这两块的内容，它俩底层是使用C来进行工作的，和Java没有太大的关系。</p><h4 id="⑤-程序计数器"><a href="#⑤-程序计数器" class="headerlink" title="⑤ 程序计数器"></a>⑤ 程序计数器</h4><p>主要就是完成一个加载工作，类似于一个指针一样的，指向下一行我们需要执行的代码。和栈一样，都是 <strong>线程独享</strong> 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/897863ee5ecb4d92b9119d065f468262-new-imagef7287f0b-c9f0-4f22-9eb4-6968bbaa5a82.png" alt=""></p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><ol><li>Java文件经过编译后变成 .class 字节码文件</li><li>字节码文件通过类加载器被搬运到 JVM 虚拟机中</li><li>虚拟机主要的5大块：方法区，堆都为线程共享区域，有线程安全问题，栈和本地方法栈和计数器都是独享区域，不存在线程安全问题，而 JVM 的调优主要就是围绕堆，栈两大块进行</li></ol><h3 id="1-2-简单的代码例子"><a href="#1-2-简单的代码例子" class="headerlink" title="1.2 简单的代码例子"></a>1.2 简单的代码例子</h3><p>一个简单的学生类<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/29046a721c2548e0a0680ec5baf4ea95-new-imageb0b42e5e-8e25-409e-b7b9-6586a39a0b8d.png" alt=""></p><p>一个main方法<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/a3d34d33eab74f6f8743ecf62807445c-new-image08506a9e-5101-4f30-b0bc-3abbcb8f1894.png" alt=""></p><p>执行main方法的步骤如下:</p><ol><li>编译好 App.java 后得到 App.class 后，执行 App.class，系统会启动一个 JVM 进程，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载</li><li>JVM 找到 App 的主程序入口，执行main方法</li><li>这个main中的第一条语句为 Student student = new Student(“tellUrDream”) ，就是让 JVM 创建一个Student对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中</li><li>加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 <strong>指向方法区中的 Student 类的类型信息</strong> 的引用</li><li>执行student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。</li><li>执行sayName()</li></ol><p>其实也不用管太多，只需要知道对象实例初始化时会去方法区中找类信息，完成后再到栈那里去运行方法。找方法就在方法表中找。</p><h2 id="二、类加载器的介绍"><a href="#二、类加载器的介绍" class="headerlink" title="二、类加载器的介绍"></a>二、类加载器的介绍</h2><p>之前也提到了它是负责加载.class文件的，它们在文件开头会有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，并且ClassLoader只负责class文件的加载，而是否能够运行则由 Execution Engine 来决定</p><h3 id="2-1-类加载器的流程"><a href="#2-1-类加载器的流程" class="headerlink" title="2.1 类加载器的流程"></a>2.1 类加载器的流程</h3><p>从类被加载到虚拟机内存中开始，到释放内存总共有7个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中<strong>验证，准备，解析三个部分统称为连接</strong></p><h4 id="2-1-1-加载"><a href="#2-1-1-加载" class="headerlink" title="2.1.1 加载"></a>2.1.1 加载</h4><ol><li>将class文件加载到内存</li><li>将静态数据结构转化成方法区中运行时的数据结构</li><li>在堆中生成一个代表这个类的 java.lang.Class对象作为数据访问的入口</li></ol><h4 id="2-1-2-链接"><a href="#2-1-2-链接" class="headerlink" title="2.1.2 链接"></a>2.1.2 链接</h4><ol><li>验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查</li><li>准备：为static变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）</li><li>解析：虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如我现在import java.util.ArrayList这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）</li></ol><h4 id="2-1-3-初始化"><a href="#2-1-3-初始化" class="headerlink" title="2.1.3 初始化"></a>2.1.3 初始化</h4><p>初始化其实就是一个赋值的操作，它会执行一个类构造器的&lt;<clinit>clinit&gt;()方法。由编译器自动收集类中所有变量的赋值动作，此时准备阶段时的那个 static int a = 3 的例子，在这个时候就正式赋值为3</p><h4 id="2-1-4-卸载"><a href="#2-1-4-卸载" class="headerlink" title="2.1.4 卸载"></a>2.1.4 卸载</h4><p>GC将无用对象从内存中卸载</p><h3 id="2-2-类加载器的加载顺序"><a href="#2-2-类加载器的加载顺序" class="headerlink" title="2.2 类加载器的加载顺序"></a>2.2 类加载器的加载顺序</h3><p>加载一个Class类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的</p><ol><li>BootStrap ClassLoader：rt.jar</li><li>Extention ClassLoader: 加载扩展的jar包</li><li>App ClassLoader：指定的classpath下面的jar包</li><li>Custom ClassLoader：自定义的类加载器</li></ol><h3 id="2-3-双亲委派机制"><a href="#2-3-双亲委派机制" class="headerlink" title="2.3 双亲委派机制"></a>2.3 双亲委派机制</h3><p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成，比如我现在要new一个Person，这个Person是我们自定义的类，如果我们要加载它，就会先委派App ClassLoader，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的Class）时，子类加载器才会自行尝试加载</p><p>这样做的好处是，加载位于rt.jar包中的类时不管是哪个加载器加载，最终都会委托到BootStrap ClassLoader进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。</p><p>其实这个也是一个隔离的作用，避免了我们的代码影响了JDK的代码，比如我现在要来一个</p><pre><code>public class String(){    public static void main(){sout;}}</code></pre><p>这种时候，我们的代码肯定会报错，因为在加载的时候其实是找到了rt.jar中的String.class，然后发现这也没有main方法</p><h2 id="三、运行时数据区"><a href="#三、运行时数据区" class="headerlink" title="三、运行时数据区"></a>三、运行时数据区</h2><h3 id="3-1-本地方法栈和程序计数器"><a href="#3-1-本地方法栈和程序计数器" class="headerlink" title="3.1 本地方法栈和程序计数器"></a>3.1 本地方法栈和程序计数器</h3><p>比如说我们现在点开Thread类的源码，会看到它的start0方法带有一个native关键字修饰，而且不存在方法体，这种用native修饰的方法就是本地方法，这是使用C来实现的，然后一般这些方法都会放到一个叫做本地方法栈的区域。</p><p>程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现OutOfMemoryError的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。</p><p>如果执行的是native方法，那这个指针就不工作了。</p><h3 id="3-2-方法区"><a href="#3-2-方法区" class="headerlink" title="3.2 方法区"></a>3.2 方法区</h3><p>方法区主要的作用技术存放类的元数据信息，常量和静态变量···等。当它存储的信息过大时，会在无法满足内存分配时报错。</p><h3 id="3-3-虚拟机栈和虚拟机堆"><a href="#3-3-虚拟机栈和虚拟机堆" class="headerlink" title="3.3 虚拟机栈和虚拟机堆"></a>3.3 虚拟机栈和虚拟机堆</h3><p>一句话便是：栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。</p><h4 id="3-3-1-虚拟机栈的概念"><a href="#3-3-1-虚拟机栈的概念" class="headerlink" title="3.3.1 虚拟机栈的概念"></a>3.3.1 虚拟机栈的概念</h4><p>它是Java方法执行的内存模型。里面会对局部变量，动态链表，方法出口，栈的操作（入栈和出栈）进行存储，且线程独享。同时如果我们听到局部变量表，那也是在说虚拟机栈</p><pre><code>public class Person{    int a = 1;    public void doSomething(){        int b = 2;    }}</code></pre><h4 id="3-3-2-虚拟机栈存在的异常"><a href="#3-3-2-虚拟机栈存在的异常" class="headerlink" title="3.3.2 虚拟机栈存在的异常"></a>3.3.2 虚拟机栈存在的异常</h4><p>如果线程请求的栈的深度大于虚拟机栈的最大深度，就会报 <strong>StackOverflowError</strong> （这种错误经常出现在递归中）。Java虚拟机也可以动态扩展，但随着扩展会不断地申请内存，当无法申请足够内存时就会报错 <strong>OutOfMemoryError</strong>。</p><h4 id="3-3-3-虚拟机栈的生命周期"><a href="#3-3-3-虚拟机栈的生命周期" class="headerlink" title="3.3.3 虚拟机栈的生命周期"></a>3.3.3 虚拟机栈的生命周期</h4><p>对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。</p><p>这里补充一句：8种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存。</p><h4 id="3-3-4-虚拟机栈的执行"><a href="#3-3-4-虚拟机栈的执行" class="headerlink" title="3.3.4 虚拟机栈的执行"></a>3.3.4 虚拟机栈的执行</h4><p>我们经常说的栈帧数据，说白了在JVM中叫栈帧，放到Java中其实就是方法，它也是存放在栈中的。</p><p>栈中的数据都是以栈帧的格式存在，它是一个关于方法和运行期数据的数据集。比如我们执行一个方法a，就会对应产生一个栈帧A1，然后A1会被压入栈中。同理方法b会有一个B1，方法c会有一个C1，等到这个线程执行完毕后，栈会先弹出C1，后B1,A1。它是一个先进后出，后进先出原则。</p><h4 id="3-3-5-局部变量的复用"><a href="#3-3-5-局部变量的复用" class="headerlink" title="3.3.5 局部变量的复用"></a>3.3.5 局部变量的复用</h4><p>局部变量表用于存放方法参数和方法内部所定义的局部变量。它的容量是以Slot为最小单位，一个slot可以存放32位以内的数据类型。</p><p>虚拟机通过索引定位的方式使用局部变量表，范围为[0,局部变量表的slot的数量]。方法中的参数就会按一定顺序排列在这个局部变量表中，至于怎么排的我们可以先不关心。而为了节省栈帧空间，这些slot是可以复用的，当方法执行位置超过了某个变量，那么这个变量的slot可以被其它变量复用。当然如果需要复用，那我们的垃圾回收自然就不会去动这些内存。</p><h4 id="3-3-6-虚拟机堆的概念"><a href="#3-3-6-虚拟机堆的概念" class="headerlink" title="3.3.6 虚拟机堆的概念"></a>3.3.6 虚拟机堆的概念</h4><p>JVM内存会划分为堆内存和非堆内存，堆内存中也会划分为<strong>年轻代</strong>和<strong>老年代</strong>，而非堆内存则为<strong>永久代</strong>。年轻代又会分为<strong>Eden</strong>和<strong>Survivor</strong>区。Survivor也会分为<strong>FromPlace</strong>和<strong>ToPlace</strong>，toPlace的survivor区域是空的。Eden，FromPlace和ToPlace的默认占比为 <strong>8:1:1</strong>。当然这个东西其实也可以通过一个 -XX:+UsePSAdaptiveSurvivorSizePolicy 参数来根据生成对象的速率动态调整</p><p>堆内存中存放的是对象，垃圾收集就是收集这些对象然后交给GC算法进行回收。非堆内存其实我们已经说过了，就是方法区。在1.8中已经移除永久代，替代品是一个元空间(MetaSpace)，最大区别是metaSpace是不存在于JVM中的，它使用的是本地内存。并有两个参数</p><pre><code>MetaspaceSize：初始化元空间大小，控制发生GCMaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。</code></pre><p>移除的原因可以大致了解一下：融合HotSpot JVM和JRockit VM而做出的改变，因为JRockit是没有永久代的，不过这也间接性地解决了永久代的OOM问题。</p><h4 id="3-3-7-Eden年轻代的介绍"><a href="#3-3-7-Eden年轻代的介绍" class="headerlink" title="3.3.7 Eden年轻代的介绍"></a>3.3.7 Eden年轻代的介绍</h4><p>当我们new一个对象后，会先放到Eden划分出来的一块作为存储空间的内存，但是我们知道对堆内存是线程共享的，所以有可能会出现两个对象共用一个内存的情况。这里JVM的处理是每个线程都会预先申请好一块连续的内存空间并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作我们会称作TLAB，有兴趣可以了解一下。</p><p>当Eden空间满了之后，会触发一个叫做Minor GC（就是一个发生在年轻代的GC）的操作，存活下来的对象移动到Survivor0区。Survivor0区满后触发 Minor GC，就会将存活对象移动到Survivor1区，此时还会把from和to两个指针交换，这样保证了一段时间内总有一个survivor区为空且to所指向的survivor区为空。经过多次的 Minor GC后仍然存活的对象（<strong>这里的存活判断是15次，对应到虚拟机参数为 -XX:MaxTenuringThreshold 。为什么是15，因为HotSpot会在对象投中的标记字段里记录年龄，分配到的空间仅有4位，所以最多只能记录到15</strong>）会移动到老年代。老年代是存储长期存活的对象的，占满时就会触发我们最常听说的Full GC，期间会停止所有线程等待GC的完成。所以对于响应要求高的应用应该尽量去减少发生Full GC从而避免响应超时的问题。</p><p>而且当老年区执行了full gc之后仍然无法进行对象保存的操作，就会产生OOM，这时候就是虚拟机中的堆内存不足，原因可能会是堆内存设置的大小过小，这个可以通过参数-Xms、-Xms来调整。也可能是代码中创建的对象大且多，而且它们一直在被引用从而长时间垃圾收集无法收集它们。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/c02ecba3c33f43429a765987b928e423-new-image93b46f3d-33f9-46f9-a825-ec7129b004f6.png" alt=""></p><p>补充说明：关于-XX:TargetSurvivorRatio参数的问题。其实也不一定是要满足-XX:MaxTenuringThreshold才移动到老年代。可以举个例子：如对象年龄5的占30%，年龄6的占36%，年龄7的占34%，加入某个年龄段（如例子中的年龄6）后，总占用超过Survivor空间*TargetSurvivorRatio的时候，从该年龄段开始及大于的年龄对象就要进入老年代（即例子中的年龄6对象，就是年龄6和年龄7晋升到老年代），这时候无需等到MaxTenuringThreshold中要求的15</p><h4 id="3-3-8-如何判断一个对象需要被干掉"><a href="#3-3-8-如何判断一个对象需要被干掉" class="headerlink" title="3.3.8 如何判断一个对象需要被干掉"></a>3.3.8 如何判断一个对象需要被干掉</h4><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/1c1d85b5fb8b47239af2a5c0436eb2d7-new-image0cd10827-2f96-433c-9b16-93d4fe491d88.png" alt=""></p><p>图中程序计数器、虚拟机栈、本地方法栈，3个区域随着线程的生存而生存的。内存分配和回收都是确定的。随着线程的结束内存自然就被回收了，因此不需要考虑垃圾回收的问题。而Java堆和方法区则不一样，各线程共享，内存的分配和回收都是动态的。因此垃圾收集器所关注的都是堆和方法这部分内存。</p><p>在进行回收前就要判断哪些对象还存活，哪些已经死去。下面介绍两个基础的计算方法</p><p>1.引用计数器计算：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于0时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时GC没法回收。</p><p>2.可达性分析计算：这是一种类似于二叉树的实现，将一系列的GC ROOTS作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到GC Roots没有使用任何引用链时，则说明该对象是不可用的。主流的商用程序语言，例如Java，C#等都是靠这招去判定对象是否存活的。</p><p>（了解一下即可）在Java语言汇总能作为GC Roots的对象分为以下几种：</p><ol><li>虚拟机栈（栈帧中的本地方法表）中引用的对象（局部变量）</li><li>方法区中静态变量所引用的对象（静态变量）</li><li>方法区中常量引用的对象</li><li>本地方法栈（即native修饰的方法）中JNI引用的对象（JNI是Java虚拟机调用对应的C函数的方式，通过JNI函数也可以创建新的Java对象。且JNI对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收）</li><li>已启动的且未终止的Java线程</li></ol><p>这种方法的优点是能够解决循环引用的问题，可它的实现需要耗费大量资源和时间，也需要GC（它的分析过程引用关系不能发生变化，所以需要停止所有进程）</p><h4 id="3-3-9-如何宣告一个对象的真正死亡"><a href="#3-3-9-如何宣告一个对象的真正死亡" class="headerlink" title="3.3.9 如何宣告一个对象的真正死亡"></a>3.3.9 如何宣告一个对象的真正死亡</h4><p>首先必须要提到的是一个名叫 <strong>finalize()</strong> 的方法</p><p>finalize()是Object类的一个方法、一个对象的finalize()方法只会被系统自动调用一次，经过finalize()方法逃脱死亡的对象，第二次不会再调用。</p><p>补充一句：并不提倡在程序中调用finalize()来进行自救。建议忘掉Java程序中该方法的存在。因为它执行的时间不确定，甚至是否被执行也不确定（Java程序的不正常退出），而且运行代价高昂，无法保证各个对象的调用顺序（甚至有不同线程中调用）。在Java9中已经被标记为 <strong>deprecated</strong> ，且java.lang.ref.Cleaner（也就是强、软、弱、幻象引用的那一套）中已经逐步替换掉它，会比finalize来的更加的轻量及可靠。<br>　　<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/c807dab33f8b42329c1910d609e7ed21-new-image565aeab2-6d3e-4c2c-80f6-7a7b0f629fda.png" alt=""></p><p>判断一个对象的死亡至少需要两次标记</p><ol><li>如果对象进行可达性分析之后没发现与GC Roots相连的引用链，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行finalize()方法。如果对象有必要执行finalize()方法，则被放入F-Queue队列中。</li><li>GC对F-Queue队列中的对象进行二次标记。如果对象在finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。</li></ol><p>如果确定对象已经死亡，我们又该如何回收这些垃圾呢</p><h3 id="3-4-垃圾回收算法"><a href="#3-4-垃圾回收算法" class="headerlink" title="3.4 垃圾回收算法"></a>3.4 垃圾回收算法</h3><p>不会非常详细的展开，常用的有标记清除，复制，标记整理和分代收集算法</p><h4 id="3-4-1-标记清除算法"><a href="#3-4-1-标记清除算法" class="headerlink" title="3.4.1 标记清除算法"></a>3.4.1 标记清除算法</h4><p>标记清除算法就是分为“标记”和“清除”两个阶段。标记出所有需要回收的对象，标记结束后统一回收。这个套路很简单，也存在不足，后续的算法都是根据这个基础来加以改进的。</p><p>其实它就是把已死亡的对象标记为空闲内存，然后记录在一个空闲列表中，当我们需要new一个对象时，内存管理模块会从空闲列表中寻找空闲的内存来分给新的对象。</p><p>不足的方面就是标记和清除的效率比较低下。且这种做法会让内存中的碎片非常多。这个导致了如果我们需要使用到较大的内存块时，无法分配到足够的连续内存。比如下图</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/01605d96d85f4daab9bfa5e7000f0d31-new-image78e03b85-fbef-4df9-b41e-2b63d78d119f.png" alt=""></p><p>此时可使用的内存块都是零零散散的，导致了刚刚提到的大内存对象问题</p><h4 id="3-4-2-复制算法"><a href="#3-4-2-复制算法" class="headerlink" title="3.4.2 复制算法"></a>3.4.2 复制算法</h4><p>为了解决效率问题，复制算法就出现了。它将可用内存按容量划分成两等分，每次只使用其中的一块。和survivor一样也是用from和to两个指针这样的玩法。fromPlace存满了，就把存活的对象copy到另一块toPlace上，然后交换指针的内容。这样就解决了碎片的问题。</p><p>这个算法的代价就是把内存缩水了，这样堆内存的使用效率就会变得十分低下了</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/fc349fbb9b204495a5321febe27818d4-new-image45920a9a-552c-4656-94d6-e3ca45ff9b76.png" alt=""></p><p>不过它们分配的时候也不是按照1:1这样进行分配的，就类似于Eden和Survivor也不是等价分配是一个道理。</p><h4 id="3-4-3-标记整理算法"><a href="#3-4-3-标记整理算法" class="headerlink" title="3.4.3 标记整理算法"></a>3.4.3 标记整理算法</h4><p>复制算法在对象存活率高的时候会有一定的效率问题，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/2599e9f722074d34a3f7fd9f0076f121-new-imagec76192ec-b63a-43e3-a6d6-cf01f749953f.png" alt=""></p><h4 id="3-4-4-分代收集算法"><a href="#3-4-4-分代收集算法" class="headerlink" title="3.4.4 分代收集算法"></a>3.4.4 分代收集算法</h4><p>这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p><p>说白了就是八仙过海各显神通，具体问题具体分析了而已。</p><h3 id="3-5-（了解）各种各样的垃圾回收器"><a href="#3-5-（了解）各种各样的垃圾回收器" class="headerlink" title="3.5 （了解）各种各样的垃圾回收器"></a>3.5 （了解）各种各样的垃圾回收器</h3><p>HotSpot VM中的垃圾回收器，以及适用场景<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/11e9dcd0f1ee4f25836e6f1c47104c51-new-image69e1c56a-1d40-493a-9901-6efc647a01f3.png" alt=""></p><p>到jdk8为止，默认的垃圾收集器是Parallel Scavenge 和 Parallel Old</p><p>从jdk9开始，G1收集器成为默认的垃圾收集器<br>目前来看，G1回收器停顿时间最短而且没有明显缺点，非常适合Web应用。在jdk8中测试Web应用，堆内存6G，新生代4.5G的情况下，Parallel Scavenge 回收新生代停顿长达1.5秒。G1回收器回收同样大小的新生代只停顿0.2秒。</p><h3 id="3-6-（了解）JVM的常用参数"><a href="#3-6-（了解）JVM的常用参数" class="headerlink" title="3.6 （了解）JVM的常用参数"></a>3.6 （了解）JVM的常用参数</h3><p>JVM的参数非常之多，这里只列举比较重要的几个，通过各种各样的搜索引擎也可以得知这些信息。</p><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td><td>物理内存的1/64(&lt;1GB)</td><td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td></tr><tr><td>-Xmx</td><td>最大堆大小</td><td>物理内存的1/4(&lt;1GB)</td><td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td></tr><tr><td>-Xmn</td><td>年轻代大小(1.4or lator)</td><td></td><td>注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 老年代大小 + 持久代（永久代）大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td></tr><tr><td>-XX:NewSize</td><td>设置年轻代大小(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:MaxNewSize</td><td>年轻代最大值(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:PermSize</td><td>设置持久代(perm gen)初始值</td><td>物理内存的1/64</td><td></td></tr><tr><td>-XX:MaxPermSize</td><td>设置持久代最大值</td><td>物理内存的1/4</td><td></td></tr><tr><td>-Xss</td><td>每个线程的堆栈大小</td><td></td><td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了</td></tr><tr><td>-XX:NewRatio</td><td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td><td></td><td>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td></tr><tr><td>-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td><td></td><td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td></tr><tr><td>-XX:+DisableExplicitGC</td><td>关闭System.gc()</td><td></td><td>这个参数需要严格的测试</td></tr><tr><td>-XX:PretenureSizeThreshold</td><td>对象超过多大是直接在旧生代分配</td><td>0</td><td>单位字节 新生代采用Parallel ScavengeGC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td></tr><tr><td>-XX:ParallelGCThreads</td><td>并行收集器的线程数</td><td></td><td>此值最好配置与处理器数目相等 同样适用于CMS</td></tr><tr><td>-XX:MaxGCPauseMillis</td><td>每次年轻代垃圾回收的最长时间(最大暂停时间)</td><td></td><td>如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.</td></tr></tbody></table><p>其实还有一些打印及CMS方面的参数，这里就不以一一列举了</p><h2 id="四、关于JVM调优的一些方面"><a href="#四、关于JVM调优的一些方面" class="headerlink" title="四、关于JVM调优的一些方面"></a>四、关于JVM调优的一些方面</h2><p>根据刚刚涉及的jvm的知识点，我们可以尝试对JVM进行调优，主要就是堆内存那块</p><p>所有线程共享数据区大小=新生代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m。所以java堆中增大年轻代后，将会减小年老代大小（因为老年代的清理是使用fullgc，所以老年代过小的话反而是会增多fullgc的）。此值对系统性能影响较大，Sun官方推荐配置为java堆的3/8。</p><h3 id="4-1-调整最大堆内存和最小堆内存"><a href="#4-1-调整最大堆内存和最小堆内存" class="headerlink" title="4.1 调整最大堆内存和最小堆内存"></a>4.1 调整最大堆内存和最小堆内存</h3><p>-Xmx –Xms：指定java堆最大值（默认值是物理内存的1/4(&lt;1GB)）和初始java堆最小值（默认值是物理内存的1/64(&lt;1GB))</p><p>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.，默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。简单点来说，你不停地往堆内存里面丢数据，等它剩余大小小于40%了，JVM就会动态申请内存空间不过会小于-Xmx，如果剩余大小大于70%，又会动态缩小不过不会小于–Xms。就这么简单</p><p>开发过程中，通常会将 -Xms 与 -Xmx两个参数的配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。</p><p>我们执行下面的代码</p><pre><code>System.out.println(&quot;Xmx=&quot; + Runtime.getRuntime().maxMemory() / 1024.0 / 1024 + &quot;M&quot;);    //系统的最大空间System.out.println(&quot;free mem=&quot; + Runtime.getRuntime().freeMemory() / 1024.0 / 1024 + &quot;M&quot;);  //系统的空闲空间System.out.println(&quot;total mem=&quot; + Runtime.getRuntime().totalMemory() / 1024.0 / 1024 + &quot;M&quot;);  //当前可用的总空间</code></pre><p>注意：此处设置的是Java堆大小，也就是新生代大小 + 老年代大小<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/5e7b352c16d74c789c665af46d3a2509-new-imagedd645dae-307d-4572-b6e2-b5a9925a46cd.png" alt=""></p><p>设置一个VM options的参数</p><pre><code>-Xmx20m -Xms5m -XX:+PrintGCDetails</code></pre><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/fe99e355f4754fa4be7427cb65261f3d-new-imagebb5cf485-99f8-43eb-8809-2a89e6a1768e.png" alt=""></p><p>再次启动main方法</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/300539f6560043dd8a3fe085d28420e6-new-image3c581a2e-196f-4b01-90f1-c27731b4610b.png" alt=""><br>这里GC弹出了一个Allocation Failure分配失败，这个事情发生在PSYoungGen，也就是年轻代中</p><p>这时候申请到的内存为18M，空闲内存为4.214195251464844M</p><p>我们此时创建一个字节数组看看，执行下面的代码</p><pre><code>byte[] b = new byte[1 * 1024 * 1024];System.out.println(&quot;分配了1M空间给数组&quot;);System.out.println(&quot;Xmx=&quot; + Runtime.getRuntime().maxMemory() / 1024.0 / 1024 + &quot;M&quot;);  //系统的最大空间System.out.println(&quot;free mem=&quot; + Runtime.getRuntime().freeMemory() / 1024.0 / 1024 + &quot;M&quot;);  //系统的空闲空间System.out.println(&quot;total mem=&quot; + Runtime.getRuntime().totalMemory() / 1024.0 / 1024 + &quot;M&quot;);</code></pre><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/bdd717d0a3394be7a733760052773374-new-image371b5d59-0020-4091-9874-603c0ab0073d.png" alt=""></p><p>此时free memory就又缩水了，不过total memory是没有变化的。Java会尽可能将total mem的值维持在最小堆内存大小</p><pre><code>byte[] b = new byte[10 * 1024 * 1024];System.out.println(&quot;分配了10M空间给数组&quot;);System.out.println(&quot;Xmx=&quot; + Runtime.getRuntime().maxMemory() / 1024.0 / 1024 + &quot;M&quot;);  //系统的最大空间System.out.println(&quot;free mem=&quot; + Runtime.getRuntime().freeMemory() / 1024.0 / 1024 + &quot;M&quot;);  //系统的空闲空间System.out.println(&quot;total mem=&quot; + Runtime.getRuntime().totalMemory() / 1024.0 / 1024 + &quot;M&quot;);  //当前可用的总空间</code></pre><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/0fd7550ae2144adca8ed2ede12d5fb96-new-image0c31ff20-289d-4088-8c67-a846d0c5d1e0.png" alt=""></p><p>这时候我们创建了一个10M的字节数据，这时候最小堆内存是顶不住的。我们会发现现在的total memory已经变成了15M，这就是已经申请了一次内存的结果。</p><p>此时我们再跑一下这个代码</p><pre><code>System.gc();System.out.println(&quot;Xmx=&quot; + Runtime.getRuntime().maxMemory() / 1024.0 / 1024 + &quot;M&quot;);    //系统的最大空间System.out.println(&quot;free mem=&quot; + Runtime.getRuntime().freeMemory() / 1024.0 / 1024 + &quot;M&quot;);  //系统的空闲空间System.out.println(&quot;total mem=&quot; + Runtime.getRuntime().totalMemory() / 1024.0 / 1024 + &quot;M&quot;);  //当前可用的总空间</code></pre><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/4cc44b5d5d1c40c48640ece6a296b1ac-new-image4b57baf6-085b-4150-9c60-ac51b0f815d7.png" alt=""></p><p>此时我们手动执行了一次fullgc，此时total memory的内存空间又变回5.5M了，此时又是把申请的内存释放掉的结果。</p><h3 id="4-2-调整新生代和老年代的比值"><a href="#4-2-调整新生代和老年代的比值" class="headerlink" title="4.2 调整新生代和老年代的比值"></a>4.2 调整新生代和老年代的比值</h3><p>-XX:NewRatio — 新生代（eden+2*Survivor）和老年代（不包含永久区）的比值</p><p>例如：-XX:NewRatio=4，表示新生代:老年代=1:4，即新生代占整个堆的1/5。在Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</p><h3 id="4-3-调整Survivor区和Eden区的比值"><a href="#4-3-调整Survivor区和Eden区的比值" class="headerlink" title="4.3 调整Survivor区和Eden区的比值"></a>4.3 调整Survivor区和Eden区的比值</h3><p>-XX:SurvivorRatio（幸存代）— 设置两个Survivor区和eden的比值</p><p>例如：8，表示两个Survivor:eden=2:8，即一个Survivor占年轻代的1/10</p><h3 id="4-4-设置年轻代和老年代的大小"><a href="#4-4-设置年轻代和老年代的大小" class="headerlink" title="4.4 设置年轻代和老年代的大小"></a>4.4 设置年轻代和老年代的大小</h3><p>-XX:NewSize — 设置年轻代大小</p><p>-XX:MaxNewSize — 设置年轻代最大值</p><p>可以通过设置不同参数来测试不同的情况，反正最优解当然就是官方的Eden和Survivor的占比为8:1:1，然后在刚刚介绍这些参数的时候都已经附带了一些说明，感兴趣的也可以看看。反正最大堆内存和最小堆内存如果数值不同会导致多次的gc，需要注意。</p><h3 id="4-5-小总结"><a href="#4-5-小总结" class="headerlink" title="4.5 小总结"></a>4.5 小总结</h3><p>根据实际事情调整新生代和幸存代的大小，官方推荐新生代占java堆的3/8，幸存代占新生代的1/10</p><p>在OOM时，记得Dump出堆，确保可以排查现场问题，通过下面命令你可以输出一个.dump文件，这个文件可以使用VisualVM或者Java自带的Java VisualVM工具。</p><pre><code>-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=你要输出的日志路径</code></pre><p>一般我们也可以通过编写脚本的方式来让OOM出现时给我们报个信，可以通过发送邮件或者重启程序等来解决。</p><h3 id="4-6-永久区的设置"><a href="#4-6-永久区的设置" class="headerlink" title="4.6 永久区的设置"></a>4.6 永久区的设置</h3><pre><code>-XX:PermSize -XX:MaxPermSize</code></pre><p>初始空间（默认为物理内存的1/64）和最大空间（默认为物理内存的1/4）。也就是说，jvm启动时，永久区一开始就占用了PermSize大小的空间，如果空间还不够，可以继续扩展，但是不能超过MaxPermSize，否则会OOM。</p><p>tips：如果堆空间没有用完也抛出了OOM，有可能是永久区导致的。堆空间实际占用非常少，但是永久区溢出 一样抛出OOM。</p><h3 id="4-7-JVM的栈参数调优"><a href="#4-7-JVM的栈参数调优" class="headerlink" title="4.7 JVM的栈参数调优"></a>4.7 JVM的栈参数调优</h3><h4 id="4-7-1-调整每个线程栈空间的大小"><a href="#4-7-1-调整每个线程栈空间的大小" class="headerlink" title="4.7.1 调整每个线程栈空间的大小"></a>4.7.1 调整每个线程栈空间的大小</h4><p>可以通过-Xss：调整每个线程栈空间的大小</p><p>JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。在相同物理内存下,减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右</p><h4 id="4-7-2-设置线程栈的大小"><a href="#4-7-2-设置线程栈的大小" class="headerlink" title="4.7.2 设置线程栈的大小"></a>4.7.2 设置线程栈的大小</h4><pre><code>-XXThreadStackSize：    设置线程栈的大小(0 means use default stack size)</code></pre><p>这些参数都是可以通过自己编写程序去简单测试的，这里碍于篇幅问题就不再提供demo了</p><h3 id="4-8-可以直接跳过了-JVM其他参数介绍"><a href="#4-8-可以直接跳过了-JVM其他参数介绍" class="headerlink" title="4.8 (可以直接跳过了)JVM其他参数介绍"></a>4.8 (可以直接跳过了)JVM其他参数介绍</h3><p>形形色色的参数很多，就不会说把所有都扯个遍了，因为大家其实也不会说一定要去深究到底。</p><h4 id="4-8-1-设置内存页的大小"><a href="#4-8-1-设置内存页的大小" class="headerlink" title="4.8.1 设置内存页的大小"></a>4.8.1 设置内存页的大小</h4><pre><code>-XXThreadStackSize：    设置内存页的大小，不可设置过大，会影响Perm的大小</code></pre><h4 id="4-8-2-设置原始类型的快速优化"><a href="#4-8-2-设置原始类型的快速优化" class="headerlink" title="4.8.2 设置原始类型的快速优化"></a>4.8.2 设置原始类型的快速优化</h4><pre><code>-XX:+UseFastAccessorMethods：    设置原始类型的快速优化</code></pre><h4 id="4-8-3-设置关闭手动GC"><a href="#4-8-3-设置关闭手动GC" class="headerlink" title="4.8.3 设置关闭手动GC"></a>4.8.3 设置关闭手动GC</h4><pre><code>-XX:+DisableExplicitGC：    设置关闭System.gc()(这个参数需要严格的测试)</code></pre><h4 id="4-8-4-设置垃圾最大年龄"><a href="#4-8-4-设置垃圾最大年龄" class="headerlink" title="4.8.4 设置垃圾最大年龄"></a>4.8.4 设置垃圾最大年龄</h4><pre><code>-XX:MaxTenuringThreshold    设置垃圾最大年龄。如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代.    对于年老代比较多的应用,可以提高效率。如果将此值设置为一个较大值,    则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活时间,    增加在年轻代即被回收的概率。该参数只有在串行GC时才有效.</code></pre><h4 id="4-8-5-加快编译速度"><a href="#4-8-5-加快编译速度" class="headerlink" title="4.8.5 加快编译速度"></a>4.8.5 加快编译速度</h4><pre><code>-XX:+AggressiveOpts</code></pre><p>加快编译速度</p><h4 id="4-8-6-改善锁机制性能"><a href="#4-8-6-改善锁机制性能" class="headerlink" title="4.8.6 改善锁机制性能"></a>4.8.6 改善锁机制性能</h4><pre><code>-XX:+UseBiasedLocking</code></pre><h4 id="4-8-7-禁用垃圾回收"><a href="#4-8-7-禁用垃圾回收" class="headerlink" title="4.8.7 禁用垃圾回收"></a>4.8.7 禁用垃圾回收</h4><pre><code>-Xnoclassgc</code></pre><h4 id="4-8-8-设置堆空间存活时间"><a href="#4-8-8-设置堆空间存活时间" class="headerlink" title="4.8.8 设置堆空间存活时间"></a>4.8.8 设置堆空间存活时间</h4><pre><code>-XX:SoftRefLRUPolicyMSPerMB    设置每兆堆空闲空间中SoftReference的存活时间，默认值是1s。</code></pre><h4 id="4-8-9-设置对象直接分配在老年代"><a href="#4-8-9-设置对象直接分配在老年代" class="headerlink" title="4.8.9 设置对象直接分配在老年代"></a>4.8.9 设置对象直接分配在老年代</h4><pre><code>-XX:PretenureSizeThreshold    设置对象超过多大时直接在老年代分配，默认值是0。</code></pre><h4 id="4-8-10-设置TLAB占eden区的比例"><a href="#4-8-10-设置TLAB占eden区的比例" class="headerlink" title="4.8.10 设置TLAB占eden区的比例"></a>4.8.10 设置TLAB占eden区的比例</h4><pre><code>-XX:TLABWasteTargetPercent    设置TLAB占eden区的百分比，默认值是1% 。 </code></pre><h4 id="4-8-11设置是否优先YGC"><a href="#4-8-11设置是否优先YGC" class="headerlink" title="4.8.11设置是否优先YGC"></a>4.8.11设置是否优先YGC</h4><pre><code>-XX:+CollectGen0First    设置FullGC时是否先YGC，默认值是false。</code></pre><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>真的扯了很久这东西，参考了多方的资料，有极客时间的《深入拆解虚拟机》和《Java核心技术面试精讲》，也有百度，也有自己在学习的一些线上课程的总结。希望对你有所帮助，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最重要的jvm参数</title>
      <link href="/posts/678b9be8/"/>
      <url>/posts/678b9be8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p> 本文由 <a href="原文链接：https://github.com/Snailclimb/JavaGuide">JavaGuide</a> 翻译自 <a href="https://www.baeldung.com/jvm-parameters，并对文章进行了大量的完善补充。翻译不易，如需转载请注明出处为：" target="_blank" rel="noopener">https://www.baeldung.com/jvm-parameters，并对文章进行了大量的完善补充。翻译不易，如需转载请注明出处为：</a>   作者： 。</p></blockquote><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>在本篇文章中，你将掌握最常用的 JVM 参数配置。如果对于下面提到了一些概念比如堆、</p><h2 id="2-堆内存相关"><a href="#2-堆内存相关" class="headerlink" title="2.堆内存相关"></a>2.堆内存相关</h2><blockquote><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p></blockquote><h3 id="2-1-显式指定堆内存–Xms和-Xmx"><a href="#2-1-显式指定堆内存–Xms和-Xmx" class="headerlink" title="2.1.显式指定堆内存–Xms和-Xmx"></a>2.1.显式指定堆内存<code>–Xms</code>和<code>-Xmx</code></h3><p>与性能有关的最常见实践之一是根据应用程序要求初始化堆内存。如果我们需要指定最小和最大堆大小（推荐显示指定大小），以下参数可以帮助你实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms&lt;heap size&gt;[unit] </span><br><span class="line">-Xmx&lt;heap size&gt;[unit]</span><br></pre></td></tr></table></figure><ul><li><strong>heap size</strong> 表示要初始化内存的具体大小。</li><li><strong>unit</strong> 表示要初始化内存的单位。单位为<strong><em>“ g”</em></strong> (GB) 、<strong><em>“ m”</em></strong>（MB）、<strong><em>“ k”</em></strong>（KB）。</li></ul><p>举个栗子🌰，如果我们要为JVM分配最小2 GB和最大5 GB的堆内存大小，我们的参数应该这样来写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms2G -Xmx5G</span><br></pre></td></tr></table></figure><h3 id="2-2-显式新生代内存-Young-Ceneration"><a href="#2-2-显式新生代内存-Young-Ceneration" class="headerlink" title="2.2.显式新生代内存(Young Ceneration)"></a>2.2.显式新生代内存(Young Ceneration)</h3><p>根据<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html" target="_blank" rel="noopener">Oracle官方文档</a>，在堆总可用内存配置完成之后，第二大影响因素是为 <code>Young Generation</code> 在堆内存所占的比例。默认情况下，YG 的最小大小为 1310 <em>MB</em>，最大大小为<em>无限制</em>。</p><p>一共有两种指定 新生代内存(Young Ceneration)大小的方法：</p><p><strong>1.通过<code>-XX:NewSize</code>和<code>-XX:MaxNewSize</code>指定</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize&#x3D;&lt;young size&gt;[unit] </span><br><span class="line">-XX:MaxNewSize&#x3D;&lt;young size&gt;[unit]</span><br></pre></td></tr></table></figure><p>举个栗子🌰，如果我们要为 新生代分配 最小256m 的内存，最大 1024m的内存我们的参数应该这样来写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize&#x3D;256m</span><br><span class="line">-XX:MaxNewSize&#x3D;1024m</span><br></pre></td></tr></table></figure><p><strong>2.通过<code>-Xmn&lt;young size&gt;[unit]</code>指定</strong></p><p>举个栗子🌰，如果我们要为 新生代分配256m的内存（NewSize与MaxNewSize设为一致），我们的参数应该这样来写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmn256m</span><br></pre></td></tr></table></figure><p>GC 调优策略中很重要的一条经验总结是这样说的：</p><blockquote><p>将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。</p></blockquote><p>另外，你还可以通过<strong><code>-XX:NewRatio=&lt;int&gt;</code></strong>来设置新生代和老年代内存的比值。</p><p>比如下面的参数就是设置新生代（包括Eden和两个Survivor区）与老年代的比值为1。也就是说：新生代与老年代所占比值为1：1，新生代占整个堆栈的 1/2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewRatio&#x3D;1</span><br></pre></td></tr></table></figure><h3 id="2-3-显示指定永久代-元空间的大小"><a href="#2-3-显示指定永久代-元空间的大小" class="headerlink" title="2.3.显示指定永久代/元空间的大小"></a>2.3.显示指定永久代/元空间的大小</h3><p><strong>从Java 8开始，如果我们没有指定 Metaspace 的大小，随着更多类的创建，虚拟机会耗尽所有可用的系统内存（永久代并不会出现这种情况）。</strong></p><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N <span class="comment">//方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></table></figure><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><p><strong>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</strong></p><p>下面是一些常用参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</span></span><br></pre></td></tr></table></figure><h2 id="3-垃圾收集相关"><a href="#3-垃圾收集相关" class="headerlink" title="3.垃圾收集相关"></a>3.垃圾收集相关</h2><h3 id="3-1-垃圾回收器"><a href="#3-1-垃圾回收器" class="headerlink" title="3.1.垃圾回收器"></a>3.1.垃圾回收器</h3><p>为了提高应用程序的稳定性，选择正确的<a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener">垃圾收集</a>算法至关重要。</p><p>JVM具有四种类型的<em>GC</em>实现：</p><ul><li>串行垃圾收集器</li><li>并行垃圾收集器</li><li>CMS垃圾收集器</li><li>G1垃圾收集器</li></ul><p>可以使用以下参数声明这些实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC</span><br><span class="line">-XX:+UseParallelGC</span><br><span class="line">-XX:+USeParNewGC</span><br><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure><p>有关<em>垃圾回收</em>实施的更多详细信息，请参见<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md" target="_blank" rel="noopener">此处</a>。</p><h3 id="3-2-GC记录"><a href="#3-2-GC记录" class="headerlink" title="3.2.GC记录"></a>3.2.GC记录</h3><p>为了严格监控应用程序的运行状况，我们应该始终检查JVM的<em>垃圾回收</em>性能。最简单的方法是以人类可读的格式记录<em>GC</em>活动。</p><p>使用以下参数，我们可以记录<em>GC</em>活动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseGCLogFileRotation </span><br><span class="line">-XX:NumberOfGCLogFiles&#x3D;&lt; number of log files &gt; </span><br><span class="line">-XX:GCLogFileSize&#x3D;&lt; file size &gt;[ unit ]</span><br><span class="line">-Xloggc:&#x2F;path&#x2F;to&#x2F;gc.log</span><br></pre></td></tr></table></figure><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.jianshu.com/p/832fc4d4cb53" target="_blank" rel="noopener">CMS GC 默认新生代是多大？</a></li><li><a href="https://www.cnblogs.com/hongdada/p/10277782.html" target="_blank" rel="noopener">CMS GC启动参数优化配置</a></li><li><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html" target="_blank" rel="noopener">从实际案例聊聊Java应用的GC优化-美团技术团队</a></li><li><a href="https://www.choupangxia.com/2019/11/11/interview-jvm-gc-08/" target="_blank" rel="noopener">JVM性能调优详解</a> （2019-11-11）</li><li><a href="https://segmentfault.com/a/1190000010603813" target="_blank" rel="noopener">JVM参数使用手册</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识</title>
      <link href="/posts/57ae6c03/"/>
      <url>/posts/57ae6c03/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>原文链接：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><h2 id="1-Java-基本功"><a href="#1-Java-基本功" class="headerlink" title="1. Java 基本功"></a>1. Java 基本功</h2><h3 id="1-1-Java-入门（基础概念与常识）"><a href="#1-1-Java-入门（基础概念与常识）" class="headerlink" title="1.1. Java 入门（基础概念与常识）"></a>1.1. Java 入门（基础概念与常识）</h3><h4 id="1-1-1-Java-语言有哪些特点"><a href="#1-1-1-Java-语言有哪些特点" class="headerlink" title="1.1.1. Java 语言有哪些特点?"></a>1.1.1. Java 语言有哪些特点?</h4><ol><li>简单易学；</li><li>面向对象（封装，继承，多态）；</li><li>平台无关性（ Java 虚拟机实现平台无关性）；</li><li>可靠性；</li><li>安全性；</li><li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li><li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li><li>编译与解释并存；</li></ol><blockquote><p>修正（参见： <a href="https://github.com/Snailclimb/JavaGuide/issues/544" target="_blank" rel="noopener">issue#544</a>）：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用<code>std::thread</code>和<code>std::async</code>来创建线程。参考链接：<a href="http://www.cplusplus.com/reference/thread/thread/?kw=thread" target="_blank" rel="noopener">http://www.cplusplus.com/reference/thread/thread/?kw=thread</a></p></blockquote><h4 id="1-1-2-关于-JVM-JDK-和-JRE-最详细通俗的解答"><a href="#1-1-2-关于-JVM-JDK-和-JRE-最详细通俗的解答" class="headerlink" title="1.1.2. 关于 JVM JDK 和 JRE 最详细通俗的解答"></a>1.1.2. 关于 JVM JDK 和 JRE 最详细通俗的解答</h4><h5 id="1-1-2-1-JVM"><a href="#1-1-2-1-JVM" class="headerlink" title="1.1.2.1. JVM"></a>1.1.2.1. JVM</h5><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p><p><strong>什么是字节码?采用字节码的好处是什么?</strong></p><blockquote><p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p></blockquote><p><strong>Java 程序从源代码到运行一般有下面 3 步：</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="Java程序运行过程"></p><p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p><blockquote><p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p></blockquote><p><strong>总结：</strong></p><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p><h5 id="1-1-2-2-JDK-和-JRE"><a href="#1-1-2-2-JDK-和-JRE" class="headerlink" title="1.1.2.2. JDK 和 JRE"></a>1.1.2.2. JDK 和 JRE</h5><p>JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p><p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p><p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p><h4 id="1-1-3-Oracle-JDK-和-OpenJDK-的对比"><a href="#1-1-3-Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="1.1.3. Oracle JDK 和 OpenJDK 的对比"></a>1.1.3. Oracle JDK 和 OpenJDK 的对比</h4><p>可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。</p><p>对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案：</p><blockquote><p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？</p><p>答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p></blockquote><p><strong>总结：</strong></p><ol><li>Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见：<a href="https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence" target="_blank" rel="noopener">https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence</a> 。</li><li>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；</li><li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li><li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</li><li>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li><li>Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li></ol><h4 id="1-1-4-Java-和-C-的区别"><a href="#1-1-4-Java-和-C-的区别" class="headerlink" title="1.1.4. Java 和 C++的区别?"></a>1.1.4. Java 和 C++的区别?</h4><p>我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来！</p><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li><li><strong>在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java 语言中没有结束符这一概念。</strong> 这是一个值得深度思考的问题，具体原因推荐看这篇文章： <a href="https://blog.csdn.net/sszgg2006/article/details/49148189" target="_blank" rel="noopener">https://blog.csdn.net/sszgg2006/article/details/49148189</a></li></ul><h4 id="1-1-5-什么是-Java-程序的主类-应用程序和小程序的主类有何不同"><a href="#1-1-5-什么是-Java-程序的主类-应用程序和小程序的主类有何不同" class="headerlink" title="1.1.5. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同?"></a>1.1.5. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同?</h4><p>一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这个主类是指包含 main（）方法的类。而在 Java 小程序中，这个主类是一个继承自系统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类。主类是 Java 程序执行的入口点。</p><h4 id="1-1-6-Java-应用程序与小程序之间有哪些差别"><a href="#1-1-6-Java-应用程序与小程序之间有哪些差别" class="headerlink" title="1.1.6. Java 应用程序与小程序之间有哪些差别?"></a>1.1.6. Java 应用程序与小程序之间有哪些差别?</h4><p>简单说应用程序是从主线程启动(也就是 <code>main()</code> 方法)。applet 小程序没有 <code>main()</code> 方法，主要是嵌在浏览器页面上运行(调用<code>init()</code>或者<code>run()</code>来启动)，嵌入浏览器这点跟 flash 的小游戏类似。</p><h4 id="1-1-7-import-java-和-javax-有什么区别？"><a href="#1-1-7-import-java-和-javax-有什么区别？" class="headerlink" title="1.1.7. import java 和 javax 有什么区别？"></a>1.1.7. import java 和 javax 有什么区别？</h4><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。</p><p>所以，实际上 java 和 javax 没有区别。这都是一个名字。</p><h4 id="1-1-8-为什么说-Java-语言“编译与解释并存”？"><a href="#1-1-8-为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="1.1.8. 为什么说 Java 语言“编译与解释并存”？"></a>1.1.8. 为什么说 Java 语言“编译与解释并存”？</h4><p>高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读，<br>有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</p><p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。</p><h3 id="1-2-Java-语法"><a href="#1-2-Java-语法" class="headerlink" title="1.2. Java 语法"></a>1.2. Java 语法</h3><h4 id="1-2-1-字符型常量和字符串常量的区别"><a href="#1-2-1-字符型常量和字符串常量的区别" class="headerlink" title="1.2.1. 字符型常量和字符串常量的区别?"></a>1.2.1. 字符型常量和字符串常量的区别?</h4><ol><li>形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符</li><li>含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</li><li>占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： char 在 Java 中占两个字节</strong>)</li></ol><blockquote><p>java 编程思想第四版：2.2.2 节<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-15/86735519.jpg" alt=""></p></blockquote><h4 id="1-2-2-关于注释？"><a href="#1-2-2-关于注释？" class="headerlink" title="1.2.2. 关于注释？"></a>1.2.2. 关于注释？</h4><p>Java 中的注释有三种：</p><ol><li><p>单行注释</p></li><li><p>多行注释</p></li><li><p>文档注释。</p></li></ol><p>在我们编写代码的时候，如果代码量比较少，我们自己或者团队其他成员还可以很轻易地看懂代码，但是当项目结构一旦复杂起来，我们就需要用到注释了。注释并不会执行，是我们程序员写给自己看的，注释是你的代码说明书，能够帮助看代码的人快速地理清代码之间的逻辑关系。因此，在写程序的时候随手加上注释是一个非常好的习惯。</p><p>《Clean Code》这本书明确指出：</p><blockquote><p><strong>代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</strong></p><p><strong>若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。</strong></p><p>举个例子：</p><p>去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check to see if the employee is eligible for full benefits</span></span><br><span class="line"><span class="keyword">if</span> ((employee.falgs &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt; <span class="number">65</span>))</span><br></pre></td></tr></table></figure><p>应替换为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (employee.isEligibleForFullBenefits())</span><br></pre></td></tr></table></figure></blockquote><h4 id="1-2-3-标识符和关键字的区别是什么？"><a href="#1-2-3-标识符和关键字的区别是什么？" class="headerlink" title="1.2.3. 标识符和关键字的区别是什么？"></a>1.2.3. 标识符和关键字的区别是什么？</h4><p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符，简单来说，标识符就是一个名字。但是有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这种特殊的标识符就是关键字。因此，关键字是被赋予特殊含义的标识符。比如，在我们的日常生活中 ，“警察局”这个名字已经被赋予了特殊的含义，所以如果你开一家店，店的名字不能叫“警察局”，“警察局”就是我们日常生活中的关键字。</p><h4 id="1-2-4-Java中有哪些常见的关键字？"><a href="#1-2-4-Java中有哪些常见的关键字？" class="headerlink" title="1.2.4. Java中有哪些常见的关键字？"></a>1.2.4. Java中有哪些常见的关键字？</h4><table><thead><tr><th>访问控制</th><th>private</th><th>protected</th><th>public</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>类，方法和变量修饰符</td><td>abstract</td><td>class</td><td>extends</td><td>final</td><td>implements</td><td>interface</td><td>native</td></tr><tr><td></td><td>new</td><td>static</td><td>strictfp</td><td>synchronized</td><td>transient</td><td>volatile</td><td></td></tr><tr><td>程序控制</td><td>break</td><td>continue</td><td>return</td><td>do</td><td>while</td><td>if</td><td>else</td></tr><tr><td></td><td>for</td><td>instanceof</td><td>switch</td><td>case</td><td>default</td><td></td><td></td></tr><tr><td>错误处理</td><td>try</td><td>catch</td><td>throw</td><td>throws</td><td>finally</td><td></td><td></td></tr><tr><td>包相关</td><td>import</td><td>package</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>基本类型</td><td>boolean</td><td>byte</td><td>char</td><td>double</td><td>float</td><td>int</td><td>long</td></tr><tr><td></td><td>short</td><td>null</td><td>true</td><td>false</td><td></td><td></td><td></td></tr><tr><td>变量引用</td><td>super</td><td>this</td><td>void</td><td></td><td></td><td></td><td></td></tr><tr><td>保留字</td><td>goto</td><td>const</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="1-2-5-自增自减运算符"><a href="#1-2-5-自增自减运算符" class="headerlink" title="1.2.5. 自增自减运算符"></a>1.2.5. 自增自减运算符</h4><p>在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（–）。</p><p>++和–运算符可以放在操作数之前，也可以放在操作数之后，当运算符放在操作数之前时，先自增/减，再赋值；当运算符放在操作数之后时，先赋值，再自增/减。例如，当“b=++a”时，先自增（自己增加 1），再赋值（赋值给 b）；当“b=a++”时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“符号在前就先加/减，符号在后就后加/减”。</p><h4 id="1-2-6-continue、break、和return的区别是什么？"><a href="#1-2-6-continue、break、和return的区别是什么？" class="headerlink" title="1.2.6. continue、break、和return的区别是什么？"></a>1.2.6. continue、break、和return的区别是什么？</h4><p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</p><ol><li>continue ：指跳出当前的这一次循环，继续下一次循环。</li><li>break ：指跳出整个循环体，继续执行循环下面的语句。</li></ol><p>return 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p><ol><li><code>return;</code> ：直接使用 return 结束方法执行，用于没有返回值函数的方法</li><li><code>return value;</code> ：return 一个特定值，用于有返回值函数的方法</li></ol><h4 id="1-2-7-Java泛型了解么？什么是类型擦除？介绍一下常用的通配符？"><a href="#1-2-7-Java泛型了解么？什么是类型擦除？介绍一下常用的通配符？" class="headerlink" title="1.2.7. Java泛型了解么？什么是类型擦除？介绍一下常用的通配符？"></a>1.2.7. Java泛型了解么？什么是类型擦除？介绍一下常用的通配符？</h4><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p><strong>Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</strong> 更多关于类型擦除的问题，可以查看这篇文章：<a href="https://www.cnblogs.com/wuqinglong/p/9456193.html" target="_blank" rel="noopener">《Java泛型类型擦除以及类型擦除带来的问题》</a> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">12</span>);</span><br><span class="line"><span class="comment">//这里直接添加会报错</span></span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br><span class="line">Class&lt;? extends List&gt; clazz = list.getClass();</span><br><span class="line">Method add = clazz.getDeclaredMethod(<span class="string">"add"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//但是通过反射添加，是可以的</span></span><br><span class="line">add.invoke(list, <span class="string">"kl"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(list)</span><br></pre></td></tr></table></figure><p>泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。</p><p><strong>1.泛型类</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何实例化泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure><p><strong>2.泛型接口</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，不指定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，指定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.泛型方法</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">( E[] inputArray )</span></span></span><br><span class="line"><span class="function"></span>&#123;         </span><br><span class="line">      <span class="keyword">for</span> ( E element : inputArray )&#123;        </span><br><span class="line">         System.out.printf( <span class="string">"%s "</span>, element );</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">"Hello"</span>, <span class="string">"World"</span> &#125;;</span><br><span class="line">printArray( intArray  ); </span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></table></figure><p><strong>常用的通配符为： T，E，K，V，？</strong></p><ul><li>？ 表示不确定的 java 类型</li><li>T (type) 表示具体的一个java类型</li><li>K V (key value) 分别代表java键值中的Key Value</li><li>E (element) 代表Element</li></ul><p>更多关于Java 泛型中的通配符可以查看这篇文章：<a href="https://juejin.im/post/5d5789d26fb9a06ad0056bd9" target="_blank" rel="noopener">《聊一聊-JAVA 泛型中的通配符 T，E，K，V，？》</a></p><h4 id="1-2-8-和equals的区别"><a href="#1-2-8-和equals的区别" class="headerlink" title="1.2.8. ==和equals的区别"></a>1.2.8. ==和equals的区别</h4><p><strong><code>==</code></strong> : 它的作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象。(<strong>基本数据类型==比较的是值，引用数据类型==比较的是内存地址</strong>)</p><blockquote><p>因为 Java 只有值传递，所以，对于 ==  来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p></blockquote><p><strong><code>equals()</code></strong> : 它的作用也是判断两个对象是否相等，它不能用于比较基本数据类型的变量。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。</p><p><code>Object</code>类<code>equals()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>equals()</code> 方法存在两种使用情况：</p><ul><li>情况 1：类没有覆盖 <code>equals()</code>方法。则通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象。使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li><li>情况 2：类覆盖了 <code>equals()</code>方法。一般，我们都覆盖 <code>equals()</code>方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。</li></ul><p><strong>举个例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aa==bb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">"a==b"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</li><li>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</li></ul><p><code>String</code>类<code>equals()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-9-hashCode-与-equals"><a href="#1-2-9-hashCode-与-equals" class="headerlink" title="1.2.9. hashCode()与 equals()"></a>1.2.9. hashCode()与 equals()</h4><p>面试官可能会问你：“你重写过 <code>hashcode</code> 和 <code>equals</code>么，为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？”</p><p><strong>1)hashCode()介绍:</strong></p><p><code>hashCode()</code> 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><p><strong>2)为什么要有 hashCode？</strong></p><p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 hashCode？</p><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head fist java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p><strong>3)为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？</strong></p><p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。<strong>因此，equals 方法被覆盖过，则 <code>hashCode</code> 方法也必须被覆盖。</strong></p><blockquote><p> <code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p></blockquote><p><strong>4)为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</strong></p><p>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。</p><p>因为 <code>hashCode()</code> 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code>。</p><p>我们刚刚也提到了 <code>HashSet</code>,如果 <code>HashSet</code> 在对比的时候，同样的 hashcode 有多个对象，它会使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashcode</code> 只是用来缩小查找成本。</p><p>更多关于 <code>hashcode()</code> 和 <code>equals()</code> 的内容可以查看：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="noopener">Java hashCode() 和 equals()的若干问题解答</a></p><h3 id="1-3-基本数据类型"><a href="#1-3-基本数据类型" class="headerlink" title="1.3. 基本数据类型"></a>1.3. 基本数据类型</h3><h4 id="1-3-1-Java中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？"><a href="#1-3-1-Java中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？" class="headerlink" title="1.3.1. Java中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？"></a>1.3.1. Java中的几种基本数据类型是什么？对应的包装类型是什么？各自占用多少字节呢？</h4><p>Java<strong>中</strong>有8种基本数据类型，分别为：</p><ol><li>6种数字类型 ：byte、short、int、long、float、double</li><li>1种字符类型：char</li><li>1中布尔型：boolean。 </li></ol><p>这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean</p><table><thead><tr><th align="left">基本类型</th><th align="left">位数</th><th align="left">字节</th><th>默认值</th></tr></thead><tbody><tr><td align="left">int</td><td align="left">32</td><td align="left">4</td><td>0</td></tr><tr><td align="left">short</td><td align="left">16</td><td align="left">2</td><td>0</td></tr><tr><td align="left">long</td><td align="left">64</td><td align="left">8</td><td>0L</td></tr><tr><td align="left">byte</td><td align="left">8</td><td align="left">1</td><td>0</td></tr><tr><td align="left">char</td><td align="left">16</td><td align="left">2</td><td>‘u0000’</td></tr><tr><td align="left">float</td><td align="left">32</td><td align="left">4</td><td>0f</td></tr><tr><td align="left">double</td><td align="left">64</td><td align="left">8</td><td>0d</td></tr><tr><td align="left">boolean</td><td align="left">1</td><td align="left"></td><td>false</td></tr></tbody></table><p>对于boolean，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1位，但是实际中会考虑计算机高效存储因素。</p><p>注意：</p><ol><li>Java 里使用 long 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析：</li><li><code>char a = &#39;h&#39;</code>char :单引号，<code>String a = &quot;hello&quot;</code> :双引号</li></ol><h4 id="1-3-2-自动装箱与拆箱"><a href="#1-3-2-自动装箱与拆箱" class="headerlink" title="1.3.2. 自动装箱与拆箱"></a>1.3.2. 自动装箱与拆箱</h4><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><p>更多内容见：<a href="https://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">深入剖析 Java 中的装箱和拆箱</a></p><h4 id="1-3-3-8种基本类型的包装类和常量池"><a href="#1-3-3-8种基本类型的包装类和常量池" class="headerlink" title="1.3.3. 8种基本类型的包装类和常量池"></a>1.3.3. 8种基本类型的包装类和常量池</h4><p><strong>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。</strong> 为啥把缓存设置为[-128，127]区间？（<a href="https://github.com/Snailclimb/JavaGuide/issues/461" target="_blank" rel="noopener">参见issue/461</a>）性能和资源之间的权衡。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterCache</span> </span>&#123;         </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CharacterCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> Character[<span class="number">127</span> + <span class="number">1</span>];          </span><br><span class="line">    <span class="keyword">static</span> &#123;             </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)                 </span><br><span class="line">            cache[i] = <span class="keyword">new</span> Character((<span class="keyword">char</span>)i);         </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">33</span>;</span><br><span class="line">Integer i2 = <span class="number">33</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// 输出 true</span></span><br><span class="line">Integer i11 = <span class="number">333</span>;</span><br><span class="line">Integer i22 = <span class="number">333</span>;</span><br><span class="line">System.out.println(i11 == i22);<span class="comment">// 输出 false</span></span><br><span class="line">Double i3 = <span class="number">1.2</span>;</span><br><span class="line">Double i4 = <span class="number">1.2</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure><p><strong>Integer 缓存源代码：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>应用场景：</strong></p><ol><li>Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。</li><li>Integer i1 = new Integer(40);这种情况下会创建新的对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//输出 false</span></span><br></pre></td></tr></table></figure><p><strong>Integer 比较更丰富的一个例子:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"i1=i2   "</span> + (i1 == i2));</span><br><span class="line">System.out.println(<span class="string">"i1=i2+i3   "</span> + (i1 == i2 + i3));</span><br><span class="line">System.out.println(<span class="string">"i1=i4   "</span> + (i1 == i4));</span><br><span class="line">System.out.println(<span class="string">"i4=i5   "</span> + (i4 == i5));</span><br><span class="line">System.out.println(<span class="string">"i4=i5+i6   "</span> + (i4 == i5 + i6));   </span><br><span class="line">System.out.println(<span class="string">"40=i5+i6   "</span> + (<span class="number">40</span> == i5 + i6));</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i1&#x3D;i2   true</span><br><span class="line">i1&#x3D;i2+i3   true</span><br><span class="line">i1&#x3D;i4   false</span><br><span class="line">i4&#x3D;i5   false</span><br><span class="line">i4&#x3D;i5+i6   true</span><br><span class="line">40&#x3D;i5+i6   true</span><br></pre></td></tr></table></figure><p>解释：</p><p>语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。</p><h3 id="1-4-方法（函数）"><a href="#1-4-方法（函数）" class="headerlink" title="1.4. 方法（函数）"></a>1.4. 方法（函数）</h3><h4 id="1-4-1-什么是方法的返回值-返回值在类的方法里的作用是什么"><a href="#1-4-1-什么是方法的返回值-返回值在类的方法里的作用是什么" class="headerlink" title="1.4.1. 什么是方法的返回值?返回值在类的方法里的作用是什么?"></a>1.4.1. 什么是方法的返回值?返回值在类的方法里的作用是什么?</h4><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！</p><h4 id="1-4-2-为什么-Java-中只有值传递？"><a href="#1-4-2-为什么-Java-中只有值传递？" class="headerlink" title="1.4.2. 为什么 Java 中只有值传递？"></a>1.4.2. 为什么 Java 中只有值传递？</h4><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong> 它用来描述各种程序设计语言（不只是 Java)中方法参数传递方式。</p><p><strong>Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p><p><strong>下面通过 3 个例子来给大家说明</strong></p><blockquote><p><strong>example 1</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"num1 = "</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">"num2 = "</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"a = "</span> + a);</span><br><span class="line">    System.out.println(<span class="string">"b = "</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 20</span><br><span class="line">b &#x3D; 10</span><br><span class="line">num1 &#x3D; 10</span><br><span class="line">num2 &#x3D; 20</span><br></pre></td></tr></table></figure><p><strong>解析：</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/22191348.jpg" alt="example 1 "></p><p>在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p><blockquote><p><strong>example 2</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">change(arr);</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>解析：</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/3825204.jpg" alt="example 2"></p><p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p><p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p><p><strong>很多程序设计语言（特别是，C++和 Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</strong></p><blockquote><p><strong>example 3</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="string">"小张"</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="string">"小李"</span>);</span><br><span class="line">Test.swap(s1, s2);</span><br><span class="line">System.out.println(<span class="string">"s1:"</span> + s1.getName());</span><br><span class="line">System.out.println(<span class="string">"s2:"</span> + s2.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Student x, Student y)</span> </span>&#123;</span><br><span class="line">Student temp = x;</span><br><span class="line">x = y;</span><br><span class="line">y = temp;</span><br><span class="line">System.out.println(<span class="string">"x:"</span> + x.getName());</span><br><span class="line">System.out.println(<span class="string">"y:"</span> + y.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x:小李</span><br><span class="line">y:小张</span><br><span class="line">s1:小张</span><br><span class="line">s2:小李</span><br></pre></td></tr></table></figure><p><strong>解析：</strong></p><p>交换之前：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/88729818.jpg" alt=""></p><p>交换之后：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-27/34384414.jpg" alt=""></p><p>通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p><blockquote><p><strong>总结</strong></p></blockquote><p>Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按<br>值传递的。</p><p>下面再总结一下 Java 中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><p><strong>参考：</strong></p><p>《Java 核心技术卷 Ⅰ》基础知识第十版第四章 4.5 小节</p><h4 id="1-4-3-重载和重写的区别"><a href="#1-4-3-重载和重写的区别" class="headerlink" title="1.4.3. 重载和重写的区别"></a>1.4.3. 重载和重写的区别</h4><blockquote><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p></blockquote><h6 id="1-4-3-1-重载"><a href="#1-4-3-1-重载" class="headerlink" title="1.4.3.1. 重载"></a>1.4.3.1. 重载</h6><p>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p>下面是《Java 核心技术》对重载这个概念的介绍：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/bg/desktopjava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E9%87%8D%E8%BD%BD.jpg" alt=""></p><p><strong>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</strong></p><h6 id="1-4-3-2-重写"><a href="#1-4-3-2-重写" class="headerlink" title="1.4.3.2. 重写"></a>1.4.3.2. 重写</h6><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><p><strong>综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</strong></p><p><strong>暖心的 Guide 哥最后再来个图标总结一下！</strong></p><table><thead><tr><th align="left">区别点</th><th align="left">重载方法</th><th align="left">重写方法</th></tr></thead><tbody><tr><td align="left">发生范围</td><td align="left">同一个类</td><td align="left">子类 中</td></tr><tr><td align="left">参数列表</td><td align="left">必须修改</td><td align="left">一定不能修改</td></tr><tr><td align="left">返回类型</td><td align="left">可修改</td><td align="left">一定不能修改</td></tr><tr><td align="left">异常</td><td align="left">可修改</td><td align="left">可以减少或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td align="left">访问修饰符</td><td align="left">可修改</td><td align="left">一定不能做更严格的限制（可以降低限制）</td></tr><tr><td align="left">发生阶段</td><td align="left">编译期</td><td align="left">运行期</td></tr></tbody></table><h4 id="1-4-4-深拷贝-vs-浅拷贝"><a href="#1-4-4-深拷贝-vs-浅拷贝" class="headerlink" title="1.4.4. 深拷贝 vs 浅拷贝"></a>1.4.4. 深拷贝 vs 浅拷贝</h4><ol><li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li><li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li></ol><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/java-deep-and-shallow-copy.jpg" alt="deep and shallow copy"></p><h4 id="1-4-5-方法的四种类型"><a href="#1-4-5-方法的四种类型" class="headerlink" title="1.4.5. 方法的四种类型"></a>1.4.5. 方法的四种类型</h4><p>1、无参数无返回值的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参数无返回值的方法(如果方法没有返回值，不能不写，必须写void，表示没有返回值)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"无参数无返回值的方法"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、有参数无返回值的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 有参数无返回值的方法</span></span><br><span class="line"><span class="comment">* 参数列表由零组到多组“参数类型+形参名”组合而成，多组参数之间以英文逗号（,）隔开，形参类型和形参名之间以英文空格隔开</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> a, String b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    System.out.println(a + <span class="string">"--&gt;"</span> + b + <span class="string">"--&gt;"</span> + c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、有返回值无参数的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有返回值无参数的方法（返回值可以是任意的类型,在函数里面必须有return关键字返回对应的类型）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"有返回值无参数的方法"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、有返回值有参数的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有返回值有参数的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f4</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、return 在无返回值方法的特殊使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return在无返回值方法的特殊使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a&gt;<span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;<span class="comment">//表示结束所在方法 （f5方法）的执行,下方的输出语句不会执行</span></span><br><span class="line">&#125;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Java-面向对象"><a href="#2-Java-面向对象" class="headerlink" title="2. Java 面向对象"></a>2. Java 面向对象</h2><h3 id="2-1-类和对象"><a href="#2-1-类和对象" class="headerlink" title="2.1. 类和对象"></a>2.1. 类和对象</h3><h4 id="2-1-1-面向对象和面向过程的区别"><a href="#2-1-1-面向对象和面向过程的区别" class="headerlink" title="2.1.1. 面向对象和面向过程的区别"></a>2.1.1. 面向对象和面向过程的区别</h4><ul><li><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></li><li><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong>。</li></ul><p>参见 issue : <a href="https://github.com/Snailclimb/JavaGuide/issues/431" target="_blank" rel="noopener">面向过程 ：面向过程性能比面向对象高？？</a></p><blockquote><p>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。</p><p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。</p></blockquote><h4 id="2-1-2-构造器-Constructor-是否可被-override"><a href="#2-1-2-构造器-Constructor-是否可被-override" class="headerlink" title="2.1.2. 构造器 Constructor 是否可被 override?"></a>2.1.2. 构造器 Constructor 是否可被 override?</h4><p>Constructor 不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p><h4 id="2-1-3-在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#2-1-3-在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="2.1.3. 在 Java 中定义一个不做事且没有参数的构造方法的作用"></a>2.1.3. 在 Java 中定义一个不做事且没有参数的构造方法的作用</h4><p>Java 程序在执行子类的构造方法之前，如果没有用 <code>super()</code>来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 <code>super()</code>来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><h4 id="2-1-4-成员变量与局部变量的区别有哪些？"><a href="#2-1-4-成员变量与局部变量的区别有哪些？" class="headerlink" title="2.1.4. 成员变量与局部变量的区别有哪些？"></a>2.1.4. 成员变量与局部变量的区别有哪些？</h4><ol><li>从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li><li>从变量在内存中的存储方式来看:如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的，如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li><li>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ol><h4 id="2-1-5-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#2-1-5-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="2.1.5. 创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>2.1.5. 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h4><p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p><h4 id="2-1-6-一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么"><a href="#2-1-6-一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么" class="headerlink" title="2.1.6. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?"></a>2.1.6. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</h4><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p><h4 id="2-1-7-构造方法有哪些特性？"><a href="#2-1-7-构造方法有哪些特性？" class="headerlink" title="2.1.7. 构造方法有哪些特性？"></a>2.1.7. 构造方法有哪些特性？</h4><ol><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ol><h4 id="2-1-8-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是"><a href="#2-1-8-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是" class="headerlink" title="2.1.8. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?"></a>2.1.8. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?</h4><p>帮助子类做初始化工作。</p><h4 id="2-1-9-对象的相等与指向他们的引用相等-两者有什么不同"><a href="#2-1-9-对象的相等与指向他们的引用相等-两者有什么不同" class="headerlink" title="2.1.9. 对象的相等与指向他们的引用相等,两者有什么不同?"></a>2.1.9. 对象的相等与指向他们的引用相等,两者有什么不同?</h4><p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p><h3 id="2-2-面向对象三大特征"><a href="#2-2-面向对象三大特征" class="headerlink" title="2.2. 面向对象三大特征"></a>2.2. 面向对象三大特征</h3><h4 id="2-2-1-封装"><a href="#2-2-1-封装" class="headerlink" title="2.2.1. 封装"></a>2.2.1. 封装</h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//id属性私有化</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//name属性私有化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取id的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置id的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取name的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置name的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-继承"><a href="#2-2-2-继承" class="headerlink" title="2.2.2. 继承"></a>2.2.2. 继承</h4><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p><p><strong>关于继承如下 3 点请记住：</strong></p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ol><h4 id="2-2-3-多态"><a href="#2-2-3-多态" class="headerlink" title="2.2.3. 多态"></a>2.2.3. 多态</h4><p>多态，顾名思义，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。</p><p><strong>多态的特点:</strong></p><ul><li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li><li>对象类型不可变，引用类型可变；</li><li>方法具有多态性，属性不具有多态性；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul><h3 id="2-3-修饰符"><a href="#2-3-修饰符" class="headerlink" title="2.3. 修饰符"></a>2.3. 修饰符</h3><h4 id="2-3-1-在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#2-3-1-在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="2.3.1. 在一个静态方法内调用一个非静态成员为什么是非法的?"></a>2.3.1. 在一个静态方法内调用一个非静态成员为什么是非法的?</h4><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><h4 id="2-3-2-静态方法和实例方法有何不同"><a href="#2-3-2-静态方法和实例方法有何不同" class="headerlink" title="2.3.2. 静态方法和实例方法有何不同"></a>2.3.2. 静态方法和实例方法有何不同</h4><ol><li><p>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p></li><li><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</p></li></ol><h4 id="2-3-3-常见关键字总结-static-final-this-super"><a href="#2-3-3-常见关键字总结-static-final-this-super" class="headerlink" title="2.3.3. 常见关键字总结:static,final,this,super"></a>2.3.3. 常见关键字总结:static,final,this,super</h4><p>详见笔主的这篇文章: <a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basic/final,static,this,super" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/docs/java/basic/final,static,this,super</a></p><h3 id="2-4-接口和抽象类"><a href="#2-4-接口和抽象类" class="headerlink" title="2.4. 接口和抽象类"></a>2.4. 接口和抽象类</h3><h4 id="2-4-1-接口和抽象类的区别是什么？"><a href="#2-4-1-接口和抽象类的区别是什么？" class="headerlink" title="2.4.1. 接口和抽象类的区别是什么？"></a>2.4.1. 接口和抽象类的区别是什么？</h4><ol><li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li><li>接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。</li><li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。</li><li>接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。</li><li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li></ol><blockquote><p>备注：</p><ol><li>在 JDK8 中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。(详见 issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/146" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/issues/146</a>。</li><li>jdk9 的接口被允许定义私有方法 。</li></ol></blockquote><p>总结一下 jdk7~jdk9 Java 中接口概念的变化（<a href="https://www.geeksforgeeks.org/private-methods-java-9-interfaces/" target="_blank" rel="noopener">相关阅读</a>）：</p><ol><li>在 jdk 7 或更早版本中，接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。</li><li>jdk8 的时候接口可以有默认方法和静态方法功能。</li><li>Jdk 9 在接口中引入了私有方法和私有静态方法。</li></ol><h3 id="2-5-其它重要知识点"><a href="#2-5-其它重要知识点" class="headerlink" title="2.5. 其它重要知识点"></a>2.5. 其它重要知识点</h3><h4 id="2-5-1-String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的"><a href="#2-5-1-String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的" class="headerlink" title="2.5.1. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?"></a>2.5.1. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</h4><p>简单的来说：<code>String</code> 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以<code>String</code> 对象是不可变的。</p><blockquote><p>补充（来自<a href="https://github.com/Snailclimb/JavaGuide/issues/675" target="_blank" rel="noopener">issue 675</a>）：在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 <code>private final byte[] value</code>;</p></blockquote><p>而 <code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 <code>final</code> 关键字修饰，所以这两种对象都是可变的。</p><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 的构造方法都是调用父类构造方法也就是<code>AbstractStringBuilder</code> 实现的，大家可以自行查阅源码。</p><p><code>AbstractStringBuilder.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>线程安全性</strong></p><p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能</strong></p><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><strong>对于三者使用的总结：</strong></p><ol><li>操作少量的数据: 适用 <code>String</code></li><li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li><li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li></ol><h4 id="2-5-2-Object-类的常见方法总结"><a href="#2-5-2-Object-类的常见方法总结" class="headerlink" title="2.5.2. Object 类的常见方法总结"></a>2.5.2. Object 类的常见方法总结</h4><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()<span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span><span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException<span class="comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;<span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br></pre></td></tr></table></figure><h4 id="2-5-3-与-equals-重要"><a href="#2-5-3-与-equals-重要" class="headerlink" title="2.5.3. == 与 equals(重要)"></a>2.5.3. == 与 equals(重要)</h4><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。</p><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li>情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li><li>情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li></ul><p><strong>举个例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aa==bb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">"a==b"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li><li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li></ul><h4 id="2-5-4-hashCode-与-equals-重要"><a href="#2-5-4-hashCode-与-equals-重要" class="headerlink" title="2.5.4. hashCode 与 equals (重要)"></a>2.5.4. hashCode 与 equals (重要)</h4><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？”</p><h5 id="2-5-4-1-hashCode（）介绍"><a href="#2-5-4-1-hashCode（）介绍" class="headerlink" title="2.5.4.1. hashCode（）介绍"></a>2.5.4.1. hashCode（）介绍</h5><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><h5 id="2-5-4-2-为什么要有-hashCode"><a href="#2-5-4-2-为什么要有-hashCode" class="headerlink" title="2.5.4.2. 为什么要有 hashCode"></a>2.5.4.2. 为什么要有 hashCode</h5><p><strong>我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong> 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与该位置其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code>方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p>通过我们可以看出：<code>hashCode()</code> 的作用就是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回一个 int 整数。这个<strong>哈希码的作用</strong>是确定该对象在哈希表中的索引位置。<strong><code>hashCode()</code>在散列表中才有用，在其它情况下没用</strong>。在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p><h5 id="2-5-4-3-hashCode（）与-equals（）的相关规定"><a href="#2-5-4-3-hashCode（）与-equals（）的相关规定" class="headerlink" title="2.5.4.3. hashCode（）与 equals（）的相关规定"></a>2.5.4.3. hashCode（）与 equals（）的相关规定</h5><ol><li>如果两个对象相等，则 hashcode 一定也是相同的</li><li>两个对象相等,对两个对象分别调用 equals 方法都返回 true</li><li>两个对象有相同的 hashcode 值，它们也不一定是相等的</li><li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li><li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol><p>推荐阅读：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="noopener">Java hashCode() 和 equals()的若干问题解答</a></p><h4 id="2-5-5-Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#2-5-5-Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="2.5.5. Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>2.5.5. Java 序列化中如果有些字段不想进行序列化，怎么办？</h4><p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p><p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。</p><h4 id="2-5-6-获取用键盘输入常用的两种方法"><a href="#2-5-6-获取用键盘输入常用的两种方法" class="headerlink" title="2.5.6. 获取用键盘输入常用的两种方法"></a>2.5.6. 获取用键盘输入常用的两种方法</h4><p>方法 1：通过 Scanner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure><p>方法 2：通过 BufferedReader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure><h2 id="3-Java-核心技术"><a href="#3-Java-核心技术" class="headerlink" title="3. Java 核心技术"></a>3. Java 核心技术</h2><h3 id="3-1-集合"><a href="#3-1-集合" class="headerlink" title="3.1. 集合"></a>3.1. 集合</h3><h4 id="3-1-1-Collections-工具类和-Arrays-工具类常见方法总结"><a href="#3-1-1-Collections-工具类和-Arrays-工具类常见方法总结" class="headerlink" title="3.1.1. Collections 工具类和 Arrays 工具类常见方法总结"></a>3.1.1. Collections 工具类和 Arrays 工具类常见方法总结</h4><p>详见笔主的这篇文章: <a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/Arrays,CollectionsCommonMethods.md" target="_blank" rel="noopener">https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/Arrays,CollectionsCommonMethods.md</a></p><h3 id="3-2-异常"><a href="#3-2-异常" class="headerlink" title="3.2. 异常"></a>3.2. 异常</h3><h4 id="3-2-1-Java-异常类层次结构图"><a href="#3-2-1-Java-异常类层次结构图" class="headerlink" title="3.2.1. Java 异常类层次结构图"></a>3.2.1. Java 异常类层次结构图</h4><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://imgkr.cn-bj.ufileos.com/199703ce-a1b6-4968-9eb0-161a8217507e.png" alt=""></p><p style="font-size:13px;text-align:right">图片来自：https://simplesnippets.tech/exception-handling-in-java-part-1/</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://imgkr.cn-bj.ufileos.com/3c45529f-8915-448b-816a-360f8cb73fc7.png" alt=""></p><p style="font-size:13px;text-align:right">图片来自：https://chercher.tech/java-programming/exceptions-java</p><p>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 <strong>Throwable 类</strong>。Throwable： 有两个重要的子类：<strong>Exception（异常）</strong> 和 <strong>Error（错误）</strong> ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><p><strong>Error（错误）:是程序无法处理的错误</strong>，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java 虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p><p>这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如 Java 虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java 中，错误通过 Error 的子类描述。</p><p><strong>Exception（异常）:是程序本身可以处理的异常</strong>。</font>Exception 类有一个重要的子类 <strong>RuntimeException</strong>。RuntimeException 异常由 Java 虚拟机抛出。<strong>NullPointerException</strong>（要访问的变量没有引用任何对象时，抛出该异常）、<strong>ArithmeticException</strong>（算术运算异常，一个整数除以 0 时，抛出该异常）和 <strong>ArrayIndexOutOfBoundsException</strong> （下标越界异常）。</p><p><strong>注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。</strong></p><h4 id="3-2-2-Throwable-类常用方法"><a href="#3-2-2-Throwable-类常用方法" class="headerlink" title="3.2.2. Throwable 类常用方法"></a>3.2.2. Throwable 类常用方法</h4><ul><li><strong><code>public string getMessage()</code></strong>:返回异常发生时的简要描述</li><li><strong><code>public string toString()</code></strong>:返回异常发生时的详细信息</li><li><strong><code>public string getLocalizedMessage()</code></strong>:返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage（）</code>返回的结果相同</li><li><strong><code>public void printStackTrace()</code></strong>:在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li></ul><h4 id="3-2-3-try-catch-finally"><a href="#3-2-3-try-catch-finally" class="headerlink" title="3.2.3. try-catch-finally"></a>3.2.3. try-catch-finally</h4><ul><li><strong>try 块：</strong> 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li><li><strong>catch 块：</strong> 用于处理 try 捕获到的异常。</li><li><strong>finally 块：</strong> 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li></ul><p><strong>在以下 4 种特殊情况下，finally 块不会被执行：</strong></p><ol><li>在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行</li><li>在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行</li><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol><p>下面这部分内容来自 issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/190" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/issues/190</a>。</p><p><strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value * value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果调用 <code>f(2)</code>，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。</p><h4 id="3-2-4-使用-try-with-resources-来代替try-catch-finally"><a href="#3-2-4-使用-try-with-resources-来代替try-catch-finally" class="headerlink" title="3.2.4. 使用 try-with-resources 来代替try-catch-finally"></a>3.2.4. 使用 <code>try-with-resources</code> 来代替<code>try-catch-finally</code></h4><p>《Effecitve Java》中明确指出：</p><blockquote><p>面对必须要关闭的资源，我们总是应该优先使用try-with-resources而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p></blockquote><p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code> 、<code>Scanner</code> 、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line">Scanner scanner = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"D://read.txt"</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Java 7之后的 <code>try-with-resources</code> 语句改造上面的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"test.txt"</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code>  实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p><p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源：</p><h3 id="3-3-多线程"><a href="#3-3-多线程" class="headerlink" title="3.3. 多线程"></a>3.3. 多线程</h3><h4 id="3-3-1-简述线程、程序、进程的基本概念。以及他们之间关系是什么"><a href="#3-3-1-简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="headerlink" title="3.3.1. 简述线程、程序、进程的基本概念。以及他们之间关系是什么?"></a>3.3.1. 简述线程、程序、进程的基本概念。以及他们之间关系是什么?</h4><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p><p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。<br>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p><h4 id="3-3-2-线程有哪些基本状态"><a href="#3-3-2-线程有哪些基本状态" class="headerlink" title="3.3.2. 线程有哪些基本状态?"></a>3.3.2. 线程有哪些基本状态?</h4><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="Java线程的状态"></p><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%20%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png" alt="Java线程状态变迁"></p><p>由上图可以看出：</p><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><blockquote><p>操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/" target="_blank" rel="noopener">HowToDoInJava</a>：<a href="https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/" target="_blank" rel="noopener">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/RUNNABLE-VS-RUNNING.png" alt="RUNNABLE-VS-RUNNING"></p><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong>状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p><h3 id="3-4-文件与-I-O-流"><a href="#3-4-文件与-I-O-流" class="headerlink" title="3.4. 文件与 I\O 流"></a>3.4. 文件与 I\O 流</h3><h4 id="3-4-1-Java-中-IO-流分为几种"><a href="#3-4-1-Java-中-IO-流分为几种" class="headerlink" title="3.4.1. Java 中 IO 流分为几种?"></a>3.4.1. Java 中 IO 流分为几种?</h4><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><p>Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p>按操作方式分类结构图：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/IO-%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB.png" alt="IO-操作方式分类"></p><p>按操作对象分类结构图：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/IO-%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB.png" alt="IO-操作对象分类"></p><h5 id="3-4-1-1-既然有了字节流-为什么还要有字符流"><a href="#3-4-1-1-既然有了字节流-为什么还要有字符流" class="headerlink" title="3.4.1.1. 既然有了字节流,为什么还要有字符流?"></a>3.4.1.1. 既然有了字节流,为什么还要有字符流?</h5><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p><p>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><h5 id="3-4-1-2-BIO-NIO-AIO-有什么区别"><a href="#3-4-1-2-BIO-NIO-AIO-有什么区别" class="headerlink" title="3.4.1.2. BIO,NIO,AIO 有什么区别?"></a>3.4.1.2. BIO,NIO,AIO 有什么区别?</h5><ul><li><strong>BIO (Blocking I/O):</strong> 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li><li><strong>NIO (Non-blocking/New I/O):</strong> NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li><li><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li></ul><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ul><li><a href="https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre" target="_blank" rel="noopener">https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre</a></li><li><a href="https://www.educba.com/oracle-vs-openjdk/" target="_blank" rel="noopener">https://www.educba.com/oracle-vs-openjdk/</a></li><li><a href="https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk?answertab=active#tab-top" target="_blank" rel="noopener">https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk?answertab=active#tab-top</a></li></ul><h2 id="5-公众号"><a href="#5-公众号" class="headerlink" title="5. 公众号"></a>5. 公众号</h2><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p><p><strong>Java 工程师必备学习资源:</strong> 一些 Java 工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/qrcode_for_gh_ea338256af79_258.jpg" alt="我的公众号"></p>]]></content>
      
      
      <categories>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>valine自定义表情正确打开方式</title>
      <link href="/posts/a07c0e77/"/>
      <url>/posts/a07c0e77/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>​       博客建好了，评论系统没有好看又个性的表情包是万万不行的，所以我今天就来搞事情了，我也是看别人的博客才做的，其实不是很难，但也有坑，好了，废话不多说，现在开始</p></blockquote><p>​           我用的hexo主题是<a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener">butterfly</a>，此博客是基于此的，原理是相通的，</p><p>打开主题的配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># valine 评论系统开关</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="string">xxxxxxxxxx</span> <span class="comment"># leancloud application app id</span></span><br><span class="line">  <span class="attr">appKey:</span> <span class="string">xxxxxxxxx</span> <span class="comment"># leancloud application app key</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># valine mail notify (true/false) Deprecated in v1.4.0+</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># valine verify code (true/false) Deprecated in v1.4.0+</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># comment list page size</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">monsterid</span> <span class="comment"># gravatar style https://valine.js.org/#/avatar</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">zh-CN</span> <span class="comment"># i18n: zh-CN/zh-TW/en/ja</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">请开始你的表演，请文明发言哦！</span> <span class="comment"># valine comment input placeholder(like: Please leave your footprints )</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment">#valine comment header info</span></span><br><span class="line">  <span class="attr">recordIP:</span> <span class="literal">false</span> <span class="comment"># Record reviewer IP</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="comment"># This configuration is suitable for domestic custom domain name users, overseas version will be automatically detected (no need to manually fill in)</span></span><br><span class="line">  <span class="attr">emojiCDN:</span> <span class="string">'//i0.hdslb.com/bfs/emote/'</span> <span class="comment"># 存放表情的cdn库</span></span><br><span class="line">  <span class="attr">enableQQ:</span> <span class="literal">true</span> <span class="comment"># </span></span><br><span class="line">  <span class="attr">requiredFields:</span> <span class="string">nick,mail</span> <span class="comment"># required fields nick/mail/link</span></span><br><span class="line">  <span class="attr">bg:</span> <span class="string">images/mapleblog/t.png</span> <span class="comment"># valine background</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span> <span class="comment"># dispaly comment count in top_img</span></span><br><span class="line">  <span class="attr">emojiMaps:</span> <span class="string">&#123;&#125;</span> <span class="comment"># 存放表情yaml文件的 这是我后来加上的</span></span><br></pre></td></tr></table></figure><h3 id="添加属性emojiMaps"><a href="#添加属性emojiMaps" class="headerlink" title="添加属性emojiMaps"></a>添加属性emojiMaps</h3><p>原配置文件中是没有<strong>emojiMaps</strong>的，需要自己加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emojiMaps: &#123;&#125; # 存放表情yaml文件的</span><br></pre></td></tr></table></figure><h3 id="创建自己的CDN或引入别人的CDN"><a href="#创建自己的CDN或引入别人的CDN" class="headerlink" title="创建自己的CDN或引入别人的CDN"></a>创建自己的CDN或引入别人的CDN</h3><p>​        <strong>emojiCDN</strong> 这个是用来放<a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">CDN</a>路径的，我用的是哔哩哔哩的cdn，当然你也可以自己创建CDN，比较常见的方式是在github上去创建一个代码库，把你千辛万苦抠来的表情存到仓库，然后用法也特别简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载任何GitHub版本，提交或分支</span></span><br><span class="line">https:<span class="comment">//cdn.jsdelivr.net/gh/你的用户名/仓库名@版本号/文件路径</span></span><br></pre></td></tr></table></figure><h3 id="创建emojiMaps的yaml文件-官方用的是json文件也行，配置方式不一样"><a href="#创建emojiMaps的yaml文件-官方用的是json文件也行，配置方式不一样" class="headerlink" title="创建emojiMaps的yaml文件(官方用的是json文件也行，配置方式不一样)"></a>创建emojiMaps的yaml文件(官方用的是json文件也行，配置方式不一样)</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[tv_白眼]:</span> <span class="string">c1d59f439e379ee50eef488bcb5e5378e5044ea4.png</span> </span><br><span class="line"><span class="string">[tv_doge]:</span> <span class="string">6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png</span> </span><br><span class="line"><span class="string">[tv_坏笑]:</span> <span class="string">1f0b87f731a671079842116e0991c91c2c88645a.png</span> </span><br><span class="line"><span class="string">[tv_难过]:</span> <span class="string">87f46748d3f142ebc6586ff58860d0e2fc8263ba.png</span>  </span><br><span class="line"><span class="string">[tv_生气]:</span> <span class="string">26702dcafdab5e8225b43ffd23c94ac1ff932654.png</span>  </span><br><span class="line"><span class="string">[tv_委屈]:</span> <span class="string">d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png</span> </span><br><span class="line"><span class="string">[tv_斜眼笑]:</span> <span class="string">911f987aa8bc1bee12d52aafe62bc41ef4474e6c.png</span> </span><br><span class="line"><span class="string">[tv_呆]:</span> <span class="string">fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png</span> </span><br><span class="line"><span class="string">[tv_发怒]:</span> <span class="string">34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png</span></span><br></pre></td></tr></table></figure><h4 id="注意！文件名是有要求的"><a href="#注意！文件名是有要求的" class="headerlink" title="注意！文件名是有要求的"></a><font color=#FF0000 >注意！</font>文件名是有要求的</h4><p>以<a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener">butterfly</a>为例，打开butterfly主题目录<code>&gt;</code>layout<code>&gt;</code>includes<code>&gt;</code>comments<code>&gt;</code>valine.pug   你就会看到如下内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">let</span> emojiMaps = <span class="string">'""'</span></span><br><span class="line">if site.data.valine  #这是引入valine.yaml文件，文件名：valine</span><br><span class="line">  - emojiMaps = <span class="built_in">JSON</span>.stringify(site.data.valine)</span><br></pre></td></tr></table></figure><h3 id="写好之后存在哪呢？"><a href="#写好之后存在哪呢？" class="headerlink" title="写好之后存在哪呢？"></a>写好之后存在哪呢？</h3><p>（if site.data.valine  #这是引入valine.yaml文件，文件名：valine）</p><p>hexo的全局变量：<strong>site</strong>，指向的是hexo根目录下的source目录，data指的是source目录下_data目录（没有就自己建一个），由此可知valine.yml文件应存放到 _data目录下。</p><p>与哔哩哔哩对应的valine.yml文件我放在<a href="https://github.com/hongmaple/CDN/blob/master/emojs/valine.yml" target="_blank" rel="noopener">这里</a>了，自己拿</p><p>提交或启动看效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><h3 id="附加QQ头像问题"><a href="#附加QQ头像问题" class="headerlink" title="附加QQ头像问题"></a>附加QQ头像问题</h3><p>valine.pug</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#vcomment.vcomment</span><br><span class="line">script(src=url_for(theme.CDN.valine)) valine 的js文件CDN路径</span><br></pre></td></tr></table></figure><p>首先要自己去<a href="https://valine.js.org/" target="_blank" rel="noopener">官网</a>下载js文件，再引入</p><p>具体教程请看<a href="https://diary.dorcandy.cn/posts/916e8670/" target="_blank" rel="noopener">火喵</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> git </tag>
            
            <tag> nodejs </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thymeleaf快速入门</title>
      <link href="/posts/af48cd43/"/>
      <url>/posts/af48cd43/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="5-Thymeleaf快速入门"><a href="#5-Thymeleaf快速入门" class="headerlink" title="5.Thymeleaf快速入门"></a>5.Thymeleaf快速入门</h1><p>SpringBoot并不推荐使用jsp，但是支持一些模板引擎技术：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1525517263421.png" alt="1525517263421"></p><p>以前大家用的比较多的是Freemarker，但是我们今天的主角是Thymeleaf！</p><h2 id="5-1-为什么是Thymeleaf？"><a href="#5-1-为什么是Thymeleaf？" class="headerlink" title="5.1.为什么是Thymeleaf？"></a>5.1.为什么是Thymeleaf？</h2><p>简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较于其他的模板引擎，它有如下四个极吸引人的特点：</p><ul><li>动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</li><li>开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、改jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。</li><li>多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。</li><li>与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。</li></ul><p>接下来，我们就通过入门案例来体会Thymeleaf的魅力：</p><h2 id="5-2-提供数据"><a href="#5-2-提供数据" class="headerlink" title="5.2.提供数据"></a>5.2.提供数据</h2><p>编写一个controller方法，返回一些用户数据，放入模型中，将来在页面渲染</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/all"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">all</span><span class="params">(ModelMap model)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询用户</span></span><br><span class="line">    List&lt;User&gt; users = <span class="keyword">this</span>.userService.queryAll();</span><br><span class="line">    <span class="comment">// 放入模型</span></span><br><span class="line">    model.addAttribute(<span class="string">"users"</span>, users);</span><br><span class="line">    <span class="comment">// 返回模板名称（就是classpath:/templates/目录下的html文件名）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"users"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-引入启动器"><a href="#5-3-引入启动器" class="headerlink" title="5.3.引入启动器"></a>5.3.引入启动器</h2><p>直接引入启动器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot会自动为Thymeleaf注册一个视图解析器：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1528133744136.png" alt="1528133744136"></p><p>与解析JSP的InternalViewResolver类似，Thymeleaf也会根据前缀和后缀来确定模板文件的位置：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1528133816179.png" alt="1528133816179"></p><ul><li>默认前缀：<code>classpath:/templates/</code></li><li>默认后缀：<code>.html</code></li></ul><p>所以如果我们返回视图：<code>users</code>，会指向到 <code>classpath:/templates/users.html</code></p><p>一般我们无需进行修改，默认即可。</p><h2 id="5-4-静态页面"><a href="#5-4-静态页面" class="headerlink" title="5.4.静态页面"></a>5.4.静态页面</h2><p>根据上面的文档介绍，模板默认放在classpath下的templates文件夹，我们新建一个html文件放入其中：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1528134057401.png" alt="1528134057401"></p><p>编写html模板，渲染模型中的数据：</p><p>注意，把html 的名称空间，改成：<code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code> 会有语法提示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">table</span> &#123;<span class="attribute">border-collapse</span>: collapse; <span class="attribute">font-size</span>: <span class="number">14px</span>; <span class="attribute">width</span>: <span class="number">80%</span>; <span class="attribute">margin</span>: auto&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">table</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span> &#123;<span class="attribute">border</span>: <span class="number">1px</span> solid darkslategray;<span class="attribute">padding</span>: <span class="number">10px</span>&#125;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align: center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"color: darkslategray; font-size: 30px"</span>&gt;</span>欢迎光临！<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>生日<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"user : $&#123;users&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.id&#125;"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.name&#125;"</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.userName&#125;"</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.age&#125;"</span>&gt;</span>20<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.sex&#125;"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.birthday&#125;"</span>&gt;</span>1980-02-30<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们看到这里使用了以下语法：</p><ul><li><code>${}</code> ：这个类似与el表达式，但其实是ognl的语法，比el表达式更加强大</li><li><code>th-</code>指令：<code>th-</code>是利用了Html5中的自定义属性来实现的。如果不支持H5，可以用<code>data-th-</code>来代替<ul><li><code>th:each</code>：类似于<code>c:foreach</code>  遍历集合，但是语法更加简洁</li><li><code>th:text</code>：声明标签中的文本<ul><li>例如<code>&lt;td th-text=&#39;${user.id}&#39;&gt;1&lt;/td&gt;</code>，如果user.id有值，会覆盖默认的1</li><li>如果没有值，则会显示td中默认的1。这正是thymeleaf能够动静结合的原因，模板解析失败不影响页面的显示效果，因为会显示默认值！</li></ul></li></ul></li></ul><h2 id="5-5-测试"><a href="#5-5-测试" class="headerlink" title="5.5.测试"></a>5.5.测试</h2><p>接下来，我们打开页面测试一下：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1528134027726.png" alt="1528134027726"></p><h2 id="5-6-模板缓存"><a href="#5-6-模板缓存" class="headerlink" title="5.6.模板缓存"></a>5.6.模板缓存</h2><p>Thymeleaf会在第一次对模板解析之后进行缓存，极大的提高了并发处理能力。但是这给我们开发带来了不便，修改页面后并不会立刻看到效果，我们开发阶段可以关掉缓存使用：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开发阶段关闭thymeleaf的模板缓存</span></span><br><span class="line"><span class="meta">spring.thymeleaf.cache</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><pre><code>在Idea中，我们需要在修改页面后按快捷键：`Ctrl + Shift + F9` 对项目进行rebuild才可以。eclipse中没有测试过。</code></pre><p>我们可以修改页面，测试一下。</p>]]></content>
      
      
      <categories>
          
          <category> springboot教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> iade </tag>
            
            <tag> javaweb </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot实战</title>
      <link href="/posts/4d04312d/"/>
      <url>/posts/4d04312d/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="4-SpringBoot实战"><a href="#4-SpringBoot实战" class="headerlink" title="4.SpringBoot实战"></a>4.SpringBoot实战</h1><p>接下来，我们来看看如何用SpringBoot来玩转以前的SSM,我们沿用之前讲解SSM用到的数据库tb_user和实体类User</p><h2 id="4-1-创建工程"><a href="#4-1-创建工程" class="headerlink" title="4.1.创建工程"></a>4.1.创建工程</h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1540896476056.png" alt="1540896476056"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1540896950344.png" alt="1540896950344"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1540896657008.png" alt="1540896657008"></p><h2 id="4-2-编写基本代码"><a href="#4-2-编写基本代码" class="headerlink" title="4.2.编写基本代码"></a>4.2.编写基本代码</h2><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1540898508682.png" alt="1540898508682"></p><p>pom.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.user<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itcast-user<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参照上边的项目，编写引导类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(UserApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写UserController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello ssm"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-整合SpringMVC"><a href="#4-3-整合SpringMVC" class="headerlink" title="4.3.整合SpringMVC"></a>4.3.整合SpringMVC</h2><p>虽然默认配置已经可以使用SpringMVC了，不过我们有时候需要进行自定义配置。</p><h3 id="4-3-1-修改端口"><a href="#4-3-1-修改端口" class="headerlink" title="4.3.1.修改端口"></a>4.3.1.修改端口</h3><p>添加全局配置文件：application.properties</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1540898582724.png" alt="1540898582724"></p><p>端口通过以下方式配置</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1540898053088.png" alt="1540898053088"></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 映射端口</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">80</span></span><br></pre></td></tr></table></figure><p>重启服务后测试：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1528116232569.png" alt="1528116232569"></p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1528116322747.png" alt="1528116322747"></p><h3 id="4-3-2-访问静态资源"><a href="#4-3-2-访问静态资源" class="headerlink" title="4.3.2.访问静态资源"></a>4.3.2.访问静态资源</h3><p>现在，我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？</p><p>回顾我们上面看的源码，有一个叫做ResourceProperties的类，里面就定义了静态资源的默认查找路径： <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1528096892588.png" alt="1528096892588"></p><p>默认的静态资源路径为：</p><ul><li>classpath:/META-INF/resources/</li><li>classpath:/resources/</li><li>classpath:/static/</li><li>classpath:/public/</li></ul><p>只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。</p><p>我们习惯会把静态资源放在<code>classpath:/static/</code>目录下。我们创建目录，并且添加一些静态资源：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1540898730442.png" alt="1540898730442"></p><p>重启项目后测试：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1540898831238.png" alt="1540898831238"></p><h3 id="4-3-3-添加拦截器"><a href="#4-3-3-添加拦截器" class="headerlink" title="4.3.3.添加拦截器"></a>4.3.3.添加拦截器</h3><p>拦截器也是我们经常需要使用的，在SpringBoot中该如何配置呢？</p><p>拦截器不是一个普通属性，而是一个类，所以就要用到java配置方式了。在SpringBoot官方文档中有这么一段说明：</p><blockquote><p>If you want to keep Spring Boot MVC features and you want to add additional <a href="https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">MVC configuration</a> (interceptors, formatters, view controllers, and other features), you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurer</code> but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code>, or <code>ExceptionHandlerExceptionResolver</code>, you can declare a <code>WebMvcRegistrationsAdapter</code> instance to provide such components.</p><p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</p></blockquote><p>翻译：</p><blockquote><p>如果你想要保持Spring Boot 的一些默认MVC特征，同时又想自定义一些MVC配置（包括：拦截器，格式化器, 视图控制器、消息转换器 等等），你应该让一个类实现<code>WebMvcConfigurer</code>，并且添加<code>@Configuration</code>注解，但是<strong>千万不要</strong>加<code>@EnableWebMvc</code>注解。如果你想要自定义<code>HandlerMapping</code>、<code>HandlerAdapter</code>、<code>ExceptionResolver</code>等组件，你可以创建一个<code>WebMvcRegistrationsAdapter</code>实例 来提供以上组件。</p><p>如果你想要完全自定义SpringMVC，不保留SpringBoot提供的一切特征，你可以自己定义类并且添加<code>@Configuration</code>注解和<code>@EnableWebMvc</code>注解</p></blockquote><p>总结：通过实现<code>WebMvcConfigurer</code>并添加<code>@Configuration</code>注解来实现自定义部分SpringMvc配置。</p><p>实现如下：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1540899012303.png" alt="1540899012303"></p><p>首先我们定义一个拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"preHandle method is running!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"postHandle method is running!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"afterCompletion method is running!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义配置类，注册拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HandlerInterceptor myInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写接口中的addInterceptors方法，添加自定义拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(myInterceptor).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来运行并查看日志：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">preHandle method is running!</span><br><span class="line">postHandle method is running!</span><br><span class="line">afterCompletion method is running!</span><br></pre></td></tr></table></figure><p>你会发现日志中只有这些打印信息，springMVC的日志信息都没有，因为springMVC记录的log级别是debug，springboot默认是显示info以上，我们需要进行配置。</p><p>SpringBoot通过<code>logging.level.*=debug</code>来配置日志级别，*填写包名</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置org.springframework包的日志级别为debug</span></span><br><span class="line"><span class="meta">logging.level.org.springframework</span>=<span class="string">debug</span></span><br></pre></td></tr></table></figure><p>再次运行查看：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1540899090277.png" alt="1540899090277"></p><h2 id="4-4-整合连接池"><a href="#4-4-整合连接池" class="headerlink" title="4.4.整合连接池"></a>4.4.整合连接池</h2><p>jdbc连接池是spring配置中的重要一环，在SpringBoot中该如何处理呢？</p><p>答案是不需要处理，我们只要找到SpringBoot提供的启动器即可：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1528126755717.png" alt="1528126755717"></p><p>在pom.xml中引入jdbc的启动器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--jdbc的启动器，默认使用HikariCP连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--不要忘记数据库驱动，因为springboot不知道我们使用的什么数据库，这里选择mysql--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot已经自动帮我们引入了一个连接池：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1528126862203.png" alt="1528126862203"></p><p>HikariCP应该是目前速度最快的连接池了，我们看看它与c3p0的对比：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1525516441005.png" alt="1525516441005"></p><p>因此，我们只需要指定连接池参数即可：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接四大参数</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/heima</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">root</span></span><br><span class="line"><span class="comment"># 可省略，SpringBoot自动推断</span></span><br><span class="line"><span class="meta">spring.datasource.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.datasource.hikari.idle-timeout</span>=<span class="string">60000</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.maximum-pool-size</span>=<span class="string">30</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.minimum-idle</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure><p>当然，如果你更喜欢Druid连接池，也可以使用Druid官方提供的启动器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Druid连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而连接信息的配置与上面是类似的，只不过在连接池特有属性上，方式略有不同：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#初始化连接数</span></span><br><span class="line"><span class="meta">spring.datasource.druid.initial-size</span>=<span class="string">1</span></span><br><span class="line"><span class="comment">#最小空闲连接</span></span><br><span class="line"><span class="meta">spring.datasource.druid.min-idle</span>=<span class="string">1</span></span><br><span class="line"><span class="comment">#最大活动连接</span></span><br><span class="line"><span class="meta">spring.datasource.druid.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#获取连接时测试是否可用</span></span><br><span class="line"><span class="meta">spring.datasource.druid.test-on-borrow</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#监控页面启动</span></span><br><span class="line"><span class="meta">spring.datasource.druid.stat-view-servlet.allow</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h2 id="4-5-整合mybatis"><a href="#4-5-整合mybatis" class="headerlink" title="4.5.整合mybatis"></a>4.5.整合mybatis</h2><h3 id="4-5-1-mybatis"><a href="#4-5-1-mybatis" class="headerlink" title="4.5.1.mybatis"></a>4.5.1.mybatis</h3><p>SpringBoot官方并没有提供Mybatis的启动器，不过Mybatis<a href="https://github.com/mybatis/spring-boot-starter" target="_blank" rel="noopener">官方</a>自己实现了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置，基本没有需要配置的：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mybatis 别名扫描</span></span><br><span class="line"><span class="meta">mybatis.type-aliases-package</span>=<span class="string">cn.itcast.pojo</span></span><br><span class="line"><span class="comment"># mapper.xml文件位置,如果没有映射文件，请注释掉</span></span><br><span class="line"><span class="meta">mybatis.mapper-locations</span>=<span class="string">classpath:mappers/*.xml</span></span><br></pre></td></tr></table></figure><p>需要注意，这里没有配置mapper接口扫描包，因此我们需要给每一个Mapper接口添加<code>@Mapper</code>注解，才能被识别。</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1528128785010.png" alt="1528128785010"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>user对象参照课前资料，需要通用mapper的注解：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1540899330478.png" alt="1540899330478"></p><p>接下来，就去集成通用mapper。</p><h3 id="4-5-2-通用mapper"><a href="#4-5-2-通用mapper" class="headerlink" title="4.5.2.通用mapper"></a>4.5.2.通用mapper</h3><p>通用Mapper的作者也为自己的插件编写了启动器，我们直接引入即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通用mapper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不需要做任何配置就可以使用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">tk</span>.<span class="title">mybatis</span>.<span class="title">mapper</span>.<span class="title">common</span>.<span class="title">Mapper</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-整合事务"><a href="#4-6-整合事务" class="headerlink" title="4.6.整合事务"></a>4.6.整合事务</h2><p>其实，我们引入jdbc或者web的启动器，就已经引入事务相关的依赖及默认配置了</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1528128711716.png" alt="1528128711716"></p><p>至于事务，SpringBoot中通过注解来控制。就是我们熟知的<code>@Transactional</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userMapper.selectByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper.deleteByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-7-启动测试"><a href="#4-7-启动测试" class="headerlink" title="4.7.启动测试"></a>4.7.启动测试</h2><p>在UserController中添加测试方法，内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span>Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userService.queryById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello ssm"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们启动项目，查看：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1540900351215.png" alt="1540900351215"></p><h2 id="4-8-完整项目结构"><a href="#4-8-完整项目结构" class="headerlink" title="4.8.完整项目结构"></a>4.8.完整项目结构</h2><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1540900302611.png" alt="1540900302611"></p><p>完整的pom.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.user<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itcast-user<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--jdbc的启动器，默认使用HikariCP连接池--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--不要忘记数据库驱动，因为springboot不知道我们使用的什么数据库，这里选择mysql--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--mybatis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 通用mapper --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完整的application.properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">logging.level.org.springframework</span>=<span class="string">debug</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/heima</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mybatis 别名扫描</span></span><br><span class="line"><span class="meta">mybatis.type-aliases-package</span>=<span class="string">cn.itcast.pojo</span></span><br><span class="line"><span class="comment"># mapper.xml文件位置,如果没有映射文件，请注释掉</span></span><br><span class="line"><span class="comment"># mybatis.mapper-locations=classpath:mappers/*.xml</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springboot教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> iade </tag>
            
            <tag> javaweb </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot默认配置原理</title>
      <link href="/posts/d5325d54/"/>
      <url>/posts/d5325d54/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="3-默认配置原理"><a href="#3-默认配置原理" class="headerlink" title="3.默认配置原理"></a>3.默认配置原理</h1><p>springboot的默认配置方式和我们之前玩的配置方式不太一样，没有任何的xml。那么如果自己要新增配置该怎么办？比如我们要配置一个数据库连接池，以前会这么玩：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在该怎么做呢?</p><h2 id="3-1-回顾历史"><a href="#3-1-回顾历史" class="headerlink" title="3.1.回顾历史"></a>3.1.回顾历史</h2><p>事实上，在Spring3.0开始，Spring官方就已经开始推荐使用java配置来代替传统的xml配置了，我们不妨来回顾一下Spring的历史：</p><ul><li><p>Spring1.0时代</p><p>在此时因为jdk1.5刚刚出来，注解开发并未盛行，因此一切Spring配置都是xml格式，想象一下所有的bean都用xml配置，细思极恐啊，心疼那个时候的程序员2秒</p></li><li><p>Spring2.0时代</p><p>Spring引入了注解开发，但是因为并不完善，因此并未完全替代xml，此时的程序员往往是把xml与注解进行结合，貌似我们之前都是这种方式。</p></li><li><p>Spring3.0及以后</p><p>3.0以后Spring的注解已经非常完善了，因此Spring推荐大家使用完全的java配置来代替以前的xml，不过似乎在国内并未推广盛行。然后当SpringBoot来临，人们才慢慢认识到java配置的优雅。</p></li></ul><p>有句古话说的好：拥抱变化，拥抱未来。所以我们也应该顺应时代潮流，做时尚的弄潮儿，一起来学习下java配置的玩法。</p><h2 id="3-2-尝试java配置"><a href="#3-2-尝试java配置" class="headerlink" title="3.2.尝试java配置"></a>3.2.尝试java配置</h2><p>java配置主要靠java类和一些注解来达到和xml配置一样的效果，比较常用的注解有：</p><ul><li><code>@Configuration</code>：声明一个类作为配置类，代替xml文件</li><li><code>@Bean</code>：声明在方法上，将方法的返回值加入Bean容器，代替<code>&lt;bean&gt;</code>标签</li><li><code>@Value</code>：属性注入 </li><li><code>@PropertySource</code>：指定外部属性文件。</li></ul><p>我们接下来用java配置来尝试实现连接池配置</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1540895699735.png" alt="1540895699735"></p><h3 id="3-2-1-引入依赖"><a href="#3-2-1-引入依赖" class="headerlink" title="3.2.1.引入依赖"></a>3.2.1.引入依赖</h3><p>首先在pom.xml中，引入Druid连接池依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.drtrang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot2-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-2-添加jdbc-properties"><a href="#3-2-2-添加jdbc-properties" class="headerlink" title="3.2.2.添加jdbc.properties"></a>3.2.2.添加jdbc.properties</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/leyou</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure><h3 id="3-2-3-配置数据源"><a href="#3-2-3-配置数据源" class="headerlink" title="3.2.3.配置数据源"></a>3.2.3.配置数据源</h3><p>创建JdbcConfiguration类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:jdbc.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.url&#125;"</span>)</span><br><span class="line">    String url;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.driverClassName&#125;"</span>)</span><br><span class="line">    String driverClassName;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.username&#125;"</span>)</span><br><span class="line">    String username;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.password&#125;"</span>)</span><br><span class="line">    String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解读：</p><ul><li><code>@Configuration</code>：声明<code>JdbcConfiguration</code>是一个配置类。</li><li><code>@PropertySource</code>：指定属性文件的路径是:<code>classpath:jdbc.properties</code></li><li>通过<code>@Value</code>为属性注入值。</li><li>通过@Bean将 <code>dataSource()</code>方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。相当于以前的bean标签</li></ul><p>然后就可以在任意位置通过<code>@Autowired</code>注入DataSource了！</p><h3 id="3-2-4-测试"><a href="#3-2-4-测试" class="headerlink" title="3.2.4.测试"></a>3.2.4.测试</h3><p>我们在<code>HelloController</code>中测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"show"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello Spring Boot!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在test方法中打一个断点，然后Debug运行并查看：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1528098961065.png" alt="1528098961065"></p><p>属性注入成功了！</p><h2 id="3-3-SpringBoot的属性注入"><a href="#3-3-SpringBoot的属性注入" class="headerlink" title="3.3.SpringBoot的属性注入"></a>3.3.SpringBoot的属性注入</h2><p>在上面的案例中，我们实验了java配置方式。不过属性注入使用的是@Value注解。这种方式虽然可行，但是不够强大，因为它只能注入基本类型值。</p><p>在SpringBoot中，提供了一种新的属性注入方式，支持各种java基本数据类型及复杂类型的注入。</p><p>1）新建<code>JdbcProperties</code>，用来进行属性注入：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1540895952978.png" alt="1540895952978"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"jdbc"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    <span class="comment">// getters 和 setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在类上通过@ConfigurationProperties注解声明当前类为属性读取类</p></li><li><p><code>prefix=&quot;jdbc&quot;</code>读取属性文件中，前缀为jdbc的值。</p></li><li><p>在类上定义各个属性，名称必须与属性文件中<code>jdbc.</code>后面部分一致，并且必须具有getter和setter方法</p></li><li><p>需要注意的是，这里我们并没有指定属性文件的地址，SpringBoot默认会读取文件名为application.properties的资源文件，所以我们<strong>把jdbc.properties名称改为application.properties</strong></p></li></ul><p>2）在JdbcConfiguration中使用这个属性：</p><ul><li><p>通过<code>@EnableConfigurationProperties(JdbcProperties.class)</code>来声明要使用<code>JdbcProperties</code>这个类的对象</p></li><li><p>然后你可以通过以下方式在JdbcConfiguration类中注入JdbcProperties：</p><ol><li>@Autowired注入</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(JdbcProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">JdbcConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcProperties jdbcProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setUrl(jdbcProperties.getUrl());</span><br><span class="line">        dataSource.setDriverClassName(jdbcProperties.getDriverClassName());</span><br><span class="line">        dataSource.setUsername(jdbcProperties.getUsername());</span><br><span class="line">        dataSource.setPassword(jdbcProperties.getPassword());</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>构造函数注入</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(JdbcProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">JdbcConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcProperties jdbcProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdbcConfiguration</span><span class="params">(JdbcProperties jdbcProperties)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcProperties = jdbcProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>@Bean方法的参数注入</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(JdbcProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">JdbcConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(JdbcProperties jdbcProperties)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>本例中，我们采用第三种方式。</p><p>3）测试结果：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1527783292437.png" alt="1527783292437"></p><p>大家会觉得这种方式似乎更麻烦了，事实上这种方式有更强大的功能，也是SpringBoot推荐的注入方式。两者对比关系：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1528103259908.png" alt="1528103259908"></p><p>优势：</p><ul><li><p>Relaxed binding：松散绑定</p><ul><li>不严格要求属性文件中的属性名与成员变量名一致。支持驼峰，中划线，下划线等等转换，甚至支持对象引导。比如：user.friend.name：代表的是user对象中的friend属性中的name属性，显然friend也是对象。@value注解就难以完成这样的注入方式。</li><li>meta-data support：元数据支持，帮助IDE生成属性提示（写开源框架会用到）。</li></ul></li></ul><h2 id="3-4-更优雅的注入"><a href="#3-4-更优雅的注入" class="headerlink" title="3.4.更优雅的注入"></a>3.4.更优雅的注入</h2><p>事实上，如果一段属性只有一个Bean需要使用，我们无需将其注入到一个类（JdbcProperties）中。而是直接在需要的地方声明即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfiguration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 声明要注入的属性前缀，SpringBoot会自动把相关属性通过set方法注入到DataSource中</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"jdbc"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们直接把<code>@ConfigurationProperties(prefix = &quot;jdbc&quot;)</code>声明在需要使用的<code>@Bean</code>的方法上，然后SpringBoot就会自动调用这个Bean（此处是DataSource）的set方法，然后完成注入。使用的前提是：<strong>该类必须有对应属性的set方法！</strong></p><p>我们将jdbc的url改成：/heima，再次测试：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1528103369170.png" alt="1528103369170"></p><h2 id="3-5-SpringBoot中的默认配置"><a href="#3-5-SpringBoot中的默认配置" class="headerlink" title="3.5.SpringBoot中的默认配置"></a>3.5.SpringBoot中的默认配置</h2><p>通过刚才的学习，我们知道@EnableAutoConfiguration会开启SpringBoot的自动配置，并且根据你引入的依赖来生效对应的默认配置。那么问题来了：</p><ul><li>这些默认配置是怎么配置的，在哪里配置的呢？</li><li>为何依赖引入就会触发配置呢？</li><li>这些默认配置的属性来自哪里呢？</li></ul><p>其实在我们的项目中，已经引入了一个依赖：spring-boot-autoconfigure，其中定义了大量自动配置类：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1527931944702.png" alt="1527931944702"></p><p>还有：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1527931968031.png" alt="1527931968031"></p><p>非常多，几乎涵盖了现在主流的开源框架，例如：</p><ul><li>redis</li><li>jms</li><li>amqp</li><li>jdbc</li><li>jackson</li><li>mongodb</li><li>jpa</li><li>solr</li><li>elasticsearch</li></ul><p>… 等等</p><p>我们来看一个我们熟悉的，例如SpringMVC，查看mvc 的自动配置类：</p><p>  <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1527933162533.png" alt="1527933162533"></p><p>打开WebMvcAutoConfiguration：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1527933633048.png" alt="1527933633048"></p><p>我们看到这个类上的4个注解：</p><ul><li><p><code>@Configuration</code>：声明这个类是一个配置类</p></li><li><p><code>@ConditionalOnWebApplication(type = Type.SERVLET)</code></p><p>ConditionalOn，翻译就是在某个条件下，此处就是满足项目的类是是Type.SERVLET类型，也就是一个普通web工程，显然我们就是</p></li><li><p><code>@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })</code></p><p>这里的条件是OnClass，也就是满足以下类存在：Servlet、DispatcherServlet、WebMvcConfigurer，其中Servlet只要引入了tomcat依赖自然会有，后两个需要引入SpringMVC才会有。这里就是判断你是否引入了相关依赖，引入依赖后该条件成立，当前类的配置才会生效！</p></li><li><p><code>@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</code></p><p>这个条件与上面不同，OnMissingBean，是说环境中没有指定的Bean这个才生效。其实这就是自定义配置的入口，也就是说，如果我们自己配置了一个WebMVCConfigurationSupport的类，那么这个默认配置就会失效！</p></li></ul><p>接着，我们查看该类中定义了什么：</p><p>视图解析器：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1527933646831.png" alt="1527933646831"></p><p>处理器适配器（HandlerAdapter）：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1527933659948.png" alt="1527933659948"></p><p>还有很多，这里就不一一截图了。</p><p>另外，这些默认配置的属性来自哪里呢？</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1528096733440.png" alt="1528096733440"></p><p>我们看到，这里通过@EnableAutoConfiguration注解引入了两个属性：WebMvcProperties和ResourceProperties。</p><p>我们查看这两个属性类：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1528096851318.png" alt="1528096851318"></p><p>找到了内部资源视图解析器的prefix和suffix属性。</p><p>ResourceProperties中主要定义了静态资源（.js,.html,.css等)的路径：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1528096892588.png" alt="1528096892588"></p><p>如果我们要覆盖这些默认属性，只需要在application.properties中定义与其前缀prefix和字段名一致的属性即可。</p><h2 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6.总结"></a>3.6.总结</h2><p>SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个：</p><ul><li>你引入了相关依赖</li><li>你自己没有配置</li></ul><p>1）启动器</p><p>之所以，我们如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。</p><p>因此，玩SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器，参考课前资料中提供的《SpringBoot启动器.txt》</p><p>2）全局配置</p><p>另外，SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义<code>application.properties</code>文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。</p><p>因此，玩SpringBoot的第二件事情，就是通过<code>application.properties</code>来覆盖默认属性值，形成自定义配置。我们需要知道SpringBoot的默认属性key，非常多，参考课前资料提供的：《SpringBoot全局属性.md》</p>]]></content>
      
      
      <categories>
          
          <category> springboot教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> iade </tag>
            
            <tag> javaweb </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot快速入门</title>
      <link href="/posts/d36c7e56/"/>
      <url>/posts/d36c7e56/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h1><p>接下来，我们就来利用SpringBoot搭建一个web工程，体会一下SpringBoot的魅力所在！</p><p>环境要求：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springboot/1527695636167.png" alt="1527695636167"></p><h2 id="2-1-创建工程"><a href="#2-1-创建工程" class="headerlink" title="2.1.创建工程"></a>2.1.创建工程</h2><p>我们先新建一个空的demo工程，如下：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1527690475282.png" alt="1527690475282"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1527690564245.png" alt="1527690564245"></p><p>创建以moduel：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1527690810779.png" alt="1527690810779"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1527694194289.png" alt="1527694194289"></p><p>填写坐标信息：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1527694371964.png" alt="1527694371964"></p><p>目录结构：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1527694504570.png" alt="1527694504570"></p><p>创建完成后的目录结构：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1527694634778.png" alt="1527694634778"></p><h2 id="2-2-引入依赖"><a href="#2-2-引入依赖" class="headerlink" title="2.2.引入依赖"></a>2.2.引入依赖</h2><p>看到这里很多同学会有疑惑，前面说传统开发的问题之一就是依赖管理混乱，怎么这里我们还需要管理依赖呢？难道SpringBoot不帮我们管理吗？</p><p>别着急，现在我们的项目与SpringBoot还没有什么关联。SpringBoot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可！</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1527751740943.png" alt="1527751740943"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itcast-springboot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 所有的springboot的工程都以spring父工程为父工程 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-编写HelloController"><a href="#2-3-编写HelloController" class="headerlink" title="2.3.编写HelloController"></a>2.3.编写HelloController</h2><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1540894662227.png" alt="1540894662227"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"show"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello Spring Boot!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HelloController<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-启动测试"><a href="#2-4-启动测试" class="headerlink" title="2.4.启动测试"></a>2.4.启动测试</h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1527755353246.png" alt="1527755353246"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1527755521637.png" alt="1527755521637"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1527755975973.png" alt="1527755975973"></p><p>bingo！访问成功！</p><h2 id="2-5-详解"><a href="#2-5-详解" class="headerlink" title="2.5.详解"></a>2.5.详解</h2><p>入门工程中：pom.xml里引入了启动器的概念以@EnableAutoConfiguration注解。</p><h3 id="2-5-1-启动器"><a href="#2-5-1-启动器" class="headerlink" title="2.5.1.启动器"></a>2.5.1.启动器</h3><p>为了让SpringBoot帮我们完成各种自动配置，我们必须引入SpringBoot提供的自动配置依赖，我们称为<code>启动器</code>。spring-boot-starter-parent工程将依赖关系声明为一个或者多个启动器，我们可以根据项目需求引入相应的启动器，因为我们是web项目，这里我们引入web启动器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，我们并没有在这里指定版本信息。因为SpringBoot的父工程已经对版本进行了管理了。</p><p>这个时候，我们会发现项目中多出了大量的依赖：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1540894098029.png" alt="1540894098029"></p><p>这些都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。</p><h3 id="2-5-2-EnableAutoConfiguration"><a href="#2-5-2-EnableAutoConfiguration" class="headerlink" title="2.5.2.@EnableAutoConfiguration"></a>2.5.2.@EnableAutoConfiguration</h3><p>关于这个注解，官网上有一段说明：</p><blockquote><p>Enable auto-configuration of the Spring Application Context, attempting to guess and configure beans that you are likely to need. Auto-configuration classes are usually applied based on your classpath and what beans you have defined.</p></blockquote><p>简单翻译以下：</p><blockquote><p>开启spring应用程序的自动配置，SpringBoot基于你所添加的依赖和你自己定义的bean，试图去猜测并配置你想要的配置。比如我们引入了<code>spring-boot-starter-web</code>，而这个启动器中帮我们添加了<code>tomcat</code>、<code>SpringMVC</code>的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！</p></blockquote><p>总结，SpringBoot内部对大量的第三方库或Spring内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应库所需的依赖，如果有那么默认配置就会生效。</p><p>所以，我们使用SpringBoot构建一个项目，只需要引入所需依赖，配置就可以交给SpringBoot处理了。</p><h2 id="2-6-优化入门程序"><a href="#2-6-优化入门程序" class="headerlink" title="2.6.优化入门程序"></a>2.6.优化入门程序</h2><p>现在工程中只有一个Controller，可以这么玩；那么如果有多个Controller，怎么办呢？</p><p>添加Hello2Controller：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1527949030771.png" alt="1527949030771"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello2Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"show2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello Spring Boot2!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动重新启动，访问show2测试，失败：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1528087951866.png" alt="1528087951866"></p><p>难道要在每一个Controller中都添加一个main方法和@EnableAutoConfiguration注解，这样启动一个springboot程序也太麻烦了。也无法同时启动多个Controller，因为每个main方法都监听8080端口。所以，一个springboot程序应该只有一个springboot的main方法。</p><p>所以，springboot程序引入了一个全局的引导类。</p><h3 id="2-5-1-添加引导类"><a href="#2-5-1-添加引导类" class="headerlink" title="2.5.1.添加引导类"></a>2.5.1.添加引导类</h3><p>通常请求下，我们在一个springboot工程中都会在基包下创建一个引导类，一些springboot的全局注解（@EnableAutoConfiguration注解）以及springboot程序的入口main方法都放在该类中。</p><p>在springboot的程序的基包下（引导类和Controller包在同级目录下），创建TestApplication.class：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1527760765673.png" alt="1527760765673"></p><p>内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TestApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并修改HelloController，去掉main方法及@EnableAutoConfiguration：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"show"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello Spring Boot!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动引导类，访问show测试：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1528088990216.png" alt="1528088990216"></p><p>发现所有的Controller都不能访问，为什么？</p><p>回想以前程序，我们在配置文件中添加了注解扫描，它能扫描指定包下的所有Controller，而现在并没有。怎么解决——@ComponentScan注解</p><h3 id="2-5-2-ComponentScan"><a href="#2-5-2-ComponentScan" class="headerlink" title="2.5.2.@ComponentScan"></a>2.5.2.@ComponentScan</h3><p>spring框架除了提供配置方式的注解扫描<code>&lt;context:component-scan /&gt;</code>，还提供了注解方式的注解扫描<code>@ComponentScan</code>。</p><p>在TestApplication.class中，使用@ComponentScan注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TestApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动，访问show或者show2：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1528089792848.png" alt="1528089792848"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1527772795552.png" alt="1527772795552"></p><p>我们跟进该注解的源码，并没有看到什么特殊的地方。我们查看注释：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1527818066552.png" alt="1527818066552"></p><p>大概的意思：</p><blockquote><p>配置组件扫描的指令。提供了类似与<code>&lt;context:component-scan&gt;</code>标签的作用</p><p>通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包</p></blockquote><p>而我们的@ComponentScan注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。<strong>一般启动类会放在一个比较浅的包目录中。</strong></p><h3 id="2-5-3-SpringBootApplication"><a href="#2-5-3-SpringBootApplication" class="headerlink" title="2.5.3.@SpringBootApplication"></a>2.5.3.@SpringBootApplication</h3><p>我们现在的引导类中使用了@EnableAutoConfiguration和@ComponentScan注解，有点麻烦。springboot提供了一种简便的玩法：@SpringBootApplication注解</p><p>使用@SpringBootApplication改造TestApplication：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TestApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击进入，查看源码：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1528093556068.png" alt="1528093556068"></p><p>发现@SpringBootApplication其实是一个组合注解，这里重点的注解有3个：</p><ul><li>@SpringBootConfiguration</li><li>@EnableAutoConfiguration：开启自动配置</li><li>@ComponentScan：开启注解扫描</li></ul><h3 id="2-5-4-SpringBootConfiguration"><a href="#2-5-4-SpringBootConfiguration" class="headerlink" title="2.5.4.@SpringBootConfiguration"></a>2.5.4.@SpringBootConfiguration</h3><p>@SpringBootConfiguration注解的源码：</p><p>我们继续点击查看源码：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images//springboot/1528095223949.png" alt="1528095223949"></p><p>通过这段我们可以看出，在这个注解上面，又有一个<code>@Configuration</code>注解。通过上面的注释阅读我们知道：这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了<code>@Configuration</code>的类，并且读取其中的配置信息。而<code>@SpringBootConfiguration</code>是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。</p>]]></content>
      
      
      <categories>
          
          <category> springboot教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> iade </tag>
            
            <tag> javaweb </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo加快访问速度</title>
      <link href="/posts/c1420fa5/"/>
      <url>/posts/c1420fa5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="hexo加快访问速度"><a href="#hexo加快访问速度" class="headerlink" title="hexo加快访问速度"></a>hexo加快访问速度</h2><p>hexo+github访问速度超慢！！！这两天算是领悟到了它的龟速暴击。。。原因只有一个，托管网站的github是外网，访问外网慢是必然的。</p><p> 有很多人博客采用hexo+github+coding方式，至于coding是什么？大家可以理解为中国版的github，如果把代码既托管到coding上，又托管到github上，让大陆的用户访问的是由coding托管的网站，歪果仁访问的是由github托管的网站，这样访问速度就能上去了。</p><p> hexo与github的步骤不再重复，全在之前的博客里 <a href="https://www.hongmaple.xyz/2020/03/05/hello-world/">点这里跳转</a></p><p> 完成上面步骤，我们接着往下走：</p><p>创建账号和项目:</p><p>​        此时我们需要创建一个coding账号，然后添加一个项目，项目名为你的coding账号名，例如我的账号地址是是<a href="https://hongmaple.coding.net/，所以我新建的项目为hongmaple，注意要在初始化项目那一项打勾" target="_blank" rel="noopener">https://hongmaple.coding.net/，所以我新建的项目为hongmaple，注意要在初始化项目那一项打勾</a></p><p>![163622.png](//cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/hexojiashu/2020-05-04 163622.png)</p><h3 id="部署SSH"><a href="#部署SSH" class="headerlink" title="部署SSH:"></a>部署SSH:</h3><p>​       进入项目 -&gt; 设置 -&gt; 部署公匙 -&gt;新建部署公匙，给项目添加公匙SSH，ssh公匙获取方法和github一样（生成密钥的地址一般在C:\Users\Maple.ssh目录），在之前博客 <a href="https://www.hongmaple.xyz/2020/03/05/hello-world/">点这里跳转</a> 第四步有详细的介绍。公匙名称可以不填，但是授予推送权限选项必须打勾，这样你才有写权限</p><p>![164954.png](//cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/hexojiashu/2020-05-04 164954.png)</p><h3 id="新建代码库并上传"><a href="#新建代码库并上传" class="headerlink" title="新建代码库并上传:"></a>新建代码库并上传:</h3><ul><li><p>项目中有默认代码库，没有，则新建一个 </p></li><li><p>上传hexo代码到你的仓库</p><ul><li>在本地博客路径下，修改_config.yml下的deploy，改为：</li></ul></li></ul>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repo:</span></span><br><span class="line">    <span class="attr">github:</span></span><br><span class="line">      <span class="string">git@github.com:yourname/yourname.github.io.git,master</span></span><br><span class="line">    <span class="attr">coding:</span> </span><br><span class="line">      <span class="string">git@e.coding.net:yourname/项目名(最后是用用户名）.coding.me/仓库名.git</span></span><br></pre></td></tr></table></figure><p>  <font color=#FF0000 ><strong>格式一定要正确！！！不然会报错！！！</strong></font></p><p>  gitbath 输入以下指令</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo</span> clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><h3 id="开启持续部署"><a href="#开启持续部署" class="headerlink" title="开启持续部署"></a>开启持续部署</h3><p>​      项目设置<code>&gt;</code>项目与成员<code>&gt;</code>功能开关</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="//cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/hexojiashu/%E5%BC%80%E5%90%AF%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2.png" alt="开启持续部署 "></p><h3 id="新建静态网站-amp-部署静态网站"><a href="#新建静态网站-amp-部署静态网站" class="headerlink" title="新建静态网站&amp;部署静态网站"></a>新建静态网站&amp;部署静态网站</h3><p>​      持续部署<code>&gt;</code>静态网站(‼所选代码仓库一定要有代码)</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="//cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/hexojiashu/%E6%96%B0%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99.png" alt="新建静态网站"></p><p>​         保存后</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="//cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/hexojiashu/%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99.png" alt="部署静态网站"> </p><p>成功后就可以访问了😄</p><h3 id="添加域名解析"><a href="#添加域名解析" class="headerlink" title="添加域名解析"></a>添加域名解析</h3><p>​     在你的域名管理平台中（比如阿里云，腾讯云之类的），域名 -&gt;管理-&gt; 解析域名，增加一条CNAME信息，记录值为 youruser.coding.me（youruser为你的coding用户名)，记录值就是部署之后的访问地址</p><p>![域名解析](//cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/hexojiashu/批注 2020-05-04 172006.png)</p><p>Ok!这样本地博客就能同时同步到github和coding上了，访问你的域名会解析到coding平台上，速度比github快很多</p>]]></content>
      
      
      <categories>
          
          <category> hexo博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> git </tag>
            
            <tag> nodejs </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hystrix</title>
      <link href="/posts/211e8063/"/>
      <url>/posts/211e8063/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-Hystrix"><a href="#1-Hystrix" class="headerlink" title="1.Hystrix"></a>1.Hystrix</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1.简介"></a>1.1.简介</h2><p>Hystrix,英文意思是豪猪，全身是刺，看起来就不好惹，是一种保护机制。</p><p>Hystrix也是Netflix公司的一款组件。</p><p>主页：<a href="https://github.com/Netflix/Hystrix/" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/</a></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1525658740266.png" alt="1525658740266"></p><p>那么Hystix的作用是什么呢？具体要保护什么呢？</p><p>Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。</p><h2 id="1-2-雪崩问题"><a href="#1-2-雪崩问题" class="headerlink" title="1.2.雪崩问题"></a>1.2.雪崩问题</h2><p>微服务中，服务间调用关系错综复杂，一个请求，可能需要调用多个微服务接口才能实现，会形成非常复杂的调用链路：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1533829099748.png" alt="1533829099748"></p><p>如图，一次业务请求，需要调用A、P、H、I四个服务，这四个服务又可能调用其它服务。</p><p>如果此时，某个服务出现异常：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1533829198240.png" alt="1533829198240"></p><p>例如微服务I发生异常，请求阻塞，用户不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1533829307389.png" alt="1533829307389"></p><p>服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，形成雪崩效应。</p><p>这就好比，一个汽车生产线，生产不同的汽车，需要使用不同的零件，如果某个零件因为种种原因无法使用，那么就会造成整台车无法装配，陷入等待零件的状态，直到零件到位，才能继续组装。  此时如果有很多个车型都需要这个零件，那么整个工厂都将陷入等待的状态，导致所有生产都陷入瘫痪。一个零件的波及范围不断扩大。 </p><p>Hystix解决雪崩问题的手段有两个：</p><ul><li>线程隔离</li><li>服务熔断</li></ul><h2 id="1-3-线程隔离，服务降级"><a href="#1-3-线程隔离，服务降级" class="headerlink" title="1.3.线程隔离，服务降级"></a>1.3.线程隔离，服务降级</h2><h3 id="1-3-1-原理"><a href="#1-3-1-原理" class="headerlink" title="1.3.1.原理"></a>1.3.1.原理</h3><p>线程隔离示意图：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1533829598310.png" alt="1533829598310"></p><p>解读：</p><p>Hystrix为每个依赖服务调用分配一个小的线程池，如果线程池已满调用将被立即拒绝，默认不采用排队.加速失败判定时间。</p><p>用户的请求将不再直接访问服务，而是通过线程池中的空闲线程来访问服务，如果<strong>线程池已满</strong>，或者<strong>请求超时</strong>，则会进行降级处理，什么是服务降级？</p><blockquote><p>服务降级：优先保证核心服务，而非核心服务不可用或弱可用。</p></blockquote><p>用户的请求故障时，不会被阻塞，更不会无休止的等待或者看到系统崩溃，至少可以看到一个执行结果（例如返回友好的提示信息） 。</p><p>服务降级虽然会导致请求失败，但是不会导致阻塞，而且最多会影响这个依赖服务对应的线程池中的资源，对其它服务没有响应。</p><p>触发Hystix服务降级的情况：</p><ul><li>线程池已满</li><li>请求超时</li></ul><h3 id="1-3-2-动手实践"><a href="#1-3-2-动手实践" class="headerlink" title="1.3.2.动手实践"></a>1.3.2.动手实践</h3><h4 id="1-3-2-1-引入依赖"><a href="#1-3-2-1-引入依赖" class="headerlink" title="1.3.2.1.引入依赖"></a>1.3.2.1.引入依赖</h4><p>首先在itcast-service-consumer的pom.xml中引入Hystrix依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-3-2-2-开启熔断"><a href="#1-3-2-2-开启熔断" class="headerlink" title="1.3.2.2.开启熔断"></a>1.3.2.2.开启熔断</h4><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1535341341482.png" alt="1535341341482"></p><p>可以看到，我们类上的注解越来越多，在微服务中，经常会引入上面的三个注解，于是Spring就提供了一个组合注解：@SpringCloudApplication</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1535341390087.png" alt="1535341390087"></p><p>因此，我们可以使用这个组合注解来代替之前的3个注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringCloudApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItcastServiceConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ItcastServiceConsumerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-3-编写降级逻辑"><a href="#1-3-2-3-编写降级逻辑" class="headerlink" title="1.3.2.3.编写降级逻辑"></a>1.3.2.3.编写降级逻辑</h4><p>我们改造itcast-service-consumer，当目标服务的调用出现故障，我们希望快速失败，给用户一个友好提示。因此需要提前编写好失败时的降级处理逻辑，要使用HystixCommond来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"consumer/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"queryUserByIdFallBack"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">queryUserById</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">        String user = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://service-provider/user/"</span> + id, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">queryUserByIdFallBack</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"请求繁忙，请稍后再试！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意，因为熔断的降级逻辑方法必须跟正常逻辑方法保证：<strong>相同的参数列表和返回值声明</strong>。失败逻辑中返回User对象没有太大意义，一般会返回友好提示。所以我们把queryById的方法改造为返回String，反正也是Json数据。这样失败逻辑中返回一个错误说明，会比较方便。</p><p>说明：</p><ul><li>@HystrixCommand(fallbackMethod = “queryByIdFallBack”)：用来声明一个降级逻辑的方法</li></ul><p>测试：</p><p>当itcast-service-provder正常提供服务时，访问与以前一致。但是当我们将itcast-service-provider停机时，会发现页面返回了降级处理信息：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1535852634763.png" alt="1535852634763"></p><h4 id="1-3-2-4-默认FallBack"><a href="#1-3-2-4-默认FallBack" class="headerlink" title="1.3.2.4.默认FallBack"></a>1.3.2.4.默认FallBack</h4><p>我们刚才把fallback写在了某个业务方法上，如果这样的方法很多，那岂不是要写很多。所以我们可以把Fallback配置加在类上，实现默认fallback：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"consumer/user"</span>)</span><br><span class="line"><span class="meta">@DefaultProperties</span>(defaultFallback = <span class="string">"fallBackMethod"</span>) <span class="comment">// 指定一个类的全局熔断方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@HystrixCommand</span> <span class="comment">// 标记该方法需要熔断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">queryUserById</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">        String user = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://service-provider/user/"</span> + id, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 熔断方法</span></span><br><span class="line"><span class="comment">     * 返回值要和被熔断的方法的返回值一致</span></span><br><span class="line"><span class="comment">     * 熔断方法不需要参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fallBackMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"请求繁忙，请稍后再试！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@DefaultProperties(defaultFallback = “defaultFallBack”)：在类上指明统一的失败降级方法</li><li>@HystrixCommand：在方法上直接使用该注解，使用默认的剪辑方法。</li><li>defaultFallback：默认降级方法，不用任何参数，以匹配更多方法，但是返回值一定一致</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1535852634763.png" alt="1535852634763"></p><h4 id="1-3-2-5-设置超时"><a href="#1-3-2-5-设置超时" class="headerlink" title="1.3.2.5.设置超时"></a>1.3.2.5.设置超时</h4><p>在之前的案例中，请求在超过1秒后都会返回错误信息，这是因为Hystix的默认超时时长为1，我们可以通过配置修改这个值：</p><p>我们可以通过<code>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</code>来设置Hystrix超时时间。该配置没有提示。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">6000</span> <span class="comment"># 设置hystrix的超时时间为6000ms</span></span><br></pre></td></tr></table></figure><p><strong>改造服务提供者</strong></p><p>改造服务提供者的UserController接口，随机休眠一段时间，以触发熔断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">queryUserById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.userService.queryUserById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-服务熔断"><a href="#1-4-服务熔断" class="headerlink" title="1.4.服务熔断"></a>1.4.服务熔断</h2><h3 id="1-4-1-熔断原理"><a href="#1-4-1-熔断原理" class="headerlink" title="1.4.1.熔断原理"></a>1.4.1.熔断原理</h3><p>熔断器，也叫断路器，其英文单词为：Circuit Breaker </p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1525658640314.png" alt="1525658640314"></p><p>熔断状态机3个状态：</p><ul><li>Closed：关闭状态，所有请求都正常访问。</li><li>Open：打开状态，所有请求都会被降级。Hystix会对请求情况计数，当一定时间内失败请求百分比达到阈值，则触发熔断，断路器会完全打开。默认失败比例的阈值是50%，请求次数最少不低于20次。</li><li>Half Open：半开状态，open状态不是永久的，打开后会进入休眠时间（默认是5S）。随后断路器会自动进入半开状态。此时会释放部分请求通过，若这些请求都是健康的，则会完全关闭断路器，否则继续保持打开，再次进行休眠计时</li></ul><h3 id="1-4-2-动手实践"><a href="#1-4-2-动手实践" class="headerlink" title="1.4.2.动手实践"></a>1.4.2.动手实践</h3><p>为了能够精确控制请求的成功或失败，我们在consumer的调用业务中加入一段逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryUserById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"太忙了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    String user = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://service-provider/user/"</span> + id, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样如果参数是id为1，一定失败，其它情况都成功。（不要忘了清空service-provider中的休眠逻辑）</p><p>我们准备两个请求窗口：</p><ul><li>一个请求：<a href="http://localhost/consumer/user/1，注定失败" target="_blank" rel="noopener">http://localhost/consumer/user/1，注定失败</a></li><li>一个请求：<a href="http://localhost/consumer/user/2，肯定成功" target="_blank" rel="noopener">http://localhost/consumer/user/2，肯定成功</a></li></ul><p>当我们疯狂访问id为1的请求时（超过20次），就会触发熔断。断路器会断开，一切请求都会被降级处理。</p><p>此时你访问id为2的请求，会发现返回的也是失败，而且失败时间很短，只有几毫秒左右：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1543053265477.png" alt="1543053265477"></p><p>不过，默认的熔断触发要求较高，休眠时间窗较短，为了测试方便，我们可以通过配置修改熔断策略：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">circuitBreaker.requestVolumeThreshold</span>=<span class="string">10</span></span><br><span class="line"><span class="meta">circuitBreaker.sleepWindowInMilliseconds</span>=<span class="string">10000</span></span><br><span class="line"><span class="meta">circuitBreaker.errorThresholdPercentage</span>=<span class="string">50</span></span><br></pre></td></tr></table></figure><p>解读：</p><ul><li>requestVolumeThreshold：触发熔断的最小请求次数，默认20</li><li>errorThresholdPercentage：触发熔断的失败请求最小占比，默认50%</li><li>sleepWindowInMilliseconds：休眠时长，默认是5000毫秒</li></ul>]]></content>
      
      
      <categories>
          
          <category> springcolud教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springcolud </tag>
            
            <tag> iade </tag>
            
            <tag> javaweb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解springboot</title>
      <link href="/posts/30009449/"/>
      <url>/posts/30009449/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-了解SpringBoot"><a href="#1-了解SpringBoot" class="headerlink" title="1. 了解SpringBoot"></a>1. 了解SpringBoot</h1><p>在这一部分，我们主要了解以下3个问题：</p><ul><li>什么是SpringBoot</li><li>为什么要学习SpringBoot</li><li>SpringBoot的特点</li></ul><h2 id="1-1-什么是SpringBoot"><a href="#1-1-什么是SpringBoot" class="headerlink" title="1.1.什么是SpringBoot"></a>1.1.什么是SpringBoot</h2><p>SpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品:</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springboot/1527681455097.png" alt="1527681455097"></p><p>我们可以看到下面的一段介绍：</p><blockquote><p>Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”.</p><p>We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration.</p></blockquote><p>翻译一下：</p><blockquote><p>Spring Boot你只需要“run”就可以非常轻易的构建独立的、生产级别的spring应用。</p><p>我们为spring平台和第三方依赖库提供了一种固定化的使用方式，使你能非常轻松的开始开发你的应用程序。大部分Spring Boot应用只需要很少的配置。</p></blockquote><p>其实人们把Spring Boot称为搭建程序的<code>脚手架</code>。其最主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注于业务而非配置。</p><p>我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。</p><h2 id="1-2-为什么要学习SpringBoot"><a href="#1-2-为什么要学习SpringBoot" class="headerlink" title="1.2.为什么要学习SpringBoot"></a>1.2.为什么要学习SpringBoot</h2><p>java一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因主要是两点：</p><ul><li><p>复杂的配置</p><p>项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。</p></li><li><p>混乱的依赖管理</p><p>项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这也是件棘手的问题。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。</p></li></ul><p>而SpringBoot让这一切成为过去！</p><h2 id="1-3-SpringBoot的特点"><a href="#1-3-SpringBoot的特点" class="headerlink" title="1.3.SpringBoot的特点"></a>1.3.SpringBoot的特点</h2><p>Spring Boot 主要特征是：</p><ul><li>创建独立的spring应用程序</li><li>直接内嵌tomcat、jetty和undertow（不需要打包成war包部署）</li><li>提供了固定化的“starter”配置，以简化构建配置</li><li>尽可能的自动配置spring和第三方库</li><li>提供产品级的功能，如：安全指标、运行状况监测和外部化配置等</li><li>绝对不会生成代码，并且不需要XML配置</li></ul><p>总之，Spring Boot为所有 Spring 的开发者提供一个开箱即用的、非常快速的、广泛接受的入门体验</p><p>更多细节，大家可以到<a href="http://projects.spring.io/spring-boot/" target="_blank" rel="noopener">官网</a>查看。</p>]]></content>
      
      
      <categories>
          
          <category> springboot教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> iade </tag>
            
            <tag> javaweb </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Feign</title>
      <link href="/posts/dad91c55/"/>
      <url>/posts/dad91c55/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="4-Feign"><a href="#4-Feign" class="headerlink" title="4.Feign"></a>4.Feign</h1><p>在前面的学习中，我们使用了Ribbon的负载均衡功能，大大简化了远程调用时的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String user = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://service-provider/user/"</span> + id, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>如果就学到这里，你可能以后需要编写类似的大量重复代码，格式基本相同，无非参数不一样。有没有更优雅的方式，来对这些代码再次优化呢？</p><p>这就是我们接下来要学的Feign的功能了。</p><h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1.简介"></a>4.1.简介</h2><p>有道词典的英文解释：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/fegin%E7%AE%80%E4%BB%8B.png" alt="1528855057359"></p><p>为什么叫伪装？</p><p>Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。</p><p>项目主页：<a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener">https://github.com/OpenFeign/feign</a></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1525652009416.png" alt="1525652009416"></p><h2 id="4-2-快速入门"><a href="#4-2-快速入门" class="headerlink" title="4.2.快速入门"></a>4.2.快速入门</h2><p>改造itcast-service-consumer工程</p><h3 id="4-2-1-导入依赖"><a href="#4-2-1-导入依赖" class="headerlink" title="4.2.1.导入依赖"></a>4.2.1.导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-2-2-开启Feign功能"><a href="#4-2-2-开启Feign功能" class="headerlink" title="4.2.2.开启Feign功能"></a>4.2.2.开启Feign功能</h3><p>我们在启动类上，<strong>添加注解</strong>，开启Feign功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringCloudApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span> <span class="comment">// 开启feign客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItcastServiceConsumerApplication</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ItcastServiceConsumerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除RestTemplate</strong>：feign已经自动集成了Ribbon负载均衡的RestTemplate。所以，此处不需要再注册RestTemplate。</p><h3 id="4-2-3-Feign的客户端"><a href="#4-2-3-Feign的客户端" class="headerlink" title="4.2.3.Feign的客户端"></a>4.2.3.Feign的客户端</h3><p>在itcast-service-consumer工程中，添加UserClient接口：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1540683659305.png" alt="1540683659305"></p><p>内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"service-provider"</span>) <span class="comment">// 标注该类是一个feign接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">queryById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像</li><li><code>@FeignClient</code>，声明这是一个Feign客户端，类似<code>@Mapper</code>注解。同时通过<code>value</code>属性指定服务名称</li><li>接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果</li></ul><p>改造原来的调用逻辑，调用UserClient接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"consumer/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserClient userClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserById</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">        User user = <span class="keyword">this</span>.userClient.queryUserById(id);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-4-启动测试"><a href="#4-2-4-启动测试" class="headerlink" title="4.2.4.启动测试"></a>4.2.4.启动测试</h3><p>访问接口： </p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/urlTest.png" alt="1535346290987"></p><p>正常获取到了结果。</p><h2 id="4-3-负载均衡"><a href="#4-3-负载均衡" class="headerlink" title="4.3.负载均衡"></a>4.3.负载均衡</h2><p>Feign中本身已经集成了Ribbon依赖和自动配置：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/rbbinlei.png" alt="1528859608579"></p><p>因此我们不需要额外引入依赖，也不需要再注册<code>RestTemplate</code>对象。</p><h2 id="4-4-Hystrix支持"><a href="#4-4-Hystrix支持" class="headerlink" title="4.4.Hystrix支持"></a>4.4.Hystrix支持</h2><p>Feign默认也有对Hystrix的集成：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/hystrix-fegin.png" alt="1528861288636"></p><p>只不过，默认情况下是关闭的。我们需要通过下面的参数来开启：(在itcast-service-consumer工程添加配置内容)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启Feign的熔断功能</span></span><br></pre></td></tr></table></figure><p>但是，Feign中的Fallback配置不像hystrix中那样简单了。</p><p>1）首先，我们要定义一个类UserClientFallback，实现刚才编写的UserClient，作为fallback的处理类</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1540683742479.png" alt="1540683742479"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClientFallback</span> <span class="keyword">implements</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUserName(<span class="string">"服务器繁忙，请稍后再试！"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）然后在UserFeignClient中，指定刚才编写的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"service-provider"</span>, fallback = UserClientFallback<span class="class">.<span class="keyword">class</span>) // 标注该类是一个<span class="title">feign</span>接口</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">queryUserById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）重启测试：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1535346896313.png" alt="1535346896313"></p><h2 id="4-5-请求压缩-了解"><a href="#4-5-请求压缩-了解" class="headerlink" title="4.5.请求压缩(了解)"></a>4.5.请求压缩(了解)</h2><p>Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">compression:</span></span><br><span class="line">    <span class="attr">request:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启请求压缩</span></span><br><span class="line">    <span class="attr">response:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启响应压缩</span></span><br></pre></td></tr></table></figure><p>同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">compression:</span></span><br><span class="line">    <span class="attr">request:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启请求压缩</span></span><br><span class="line">      <span class="attr">mime-types:</span> <span class="string">text/html,application/xml,application/json</span> <span class="comment"># 设置压缩的数据类型</span></span><br><span class="line">      <span class="attr">min-request-size:</span> <span class="number">2048</span> <span class="comment"># 设置触发压缩的大小下限</span></span><br></pre></td></tr></table></figure><p>注：上面的数据类型、压缩大小下限均为默认值。</p><h2 id="4-6-日志级别-了解"><a href="#4-6-日志级别-了解" class="headerlink" title="4.6.日志级别(了解)"></a>4.6.日志级别(了解)</h2><p>前面讲过，通过<code>logging.level.xx=debug</code>来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为<code>@FeignClient</code>注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的级别才可以。</p><p>1）设置com.leyou包下的日志级别都为debug</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">cn.itcast:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><p>2）编写配置类，定义日志级别</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/logger.png" alt="1529113196740"></p><p>内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignLogConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里指定的Level级别是FULL，Feign支持4种级别：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/jiebie.png" alt="1528863525224"></p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><p>3）在FeignClient中指定配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"service-privider"</span>, fallback = UserFeignClientFallback<span class="class">.<span class="keyword">class</span>, <span class="title">configuration</span> </span>= FeignConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">UserFeignClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">queryUserById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）重启项目，即可看到每次访问的日志：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/relogfer.png" alt="1528863489923"></p>]]></content>
      
      
      <categories>
          
          <category> springcolud教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springcolud </tag>
            
            <tag> iade </tag>
            
            <tag> javaweb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ribbon</title>
      <link href="/posts/f6b50692/"/>
      <url>/posts/f6b50692/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="3-负载均衡Ribbon"><a href="#3-负载均衡Ribbon" class="headerlink" title="3.负载均衡Ribbon"></a>3.负载均衡Ribbon</h1><p>在刚才的案例中，我们启动了一个itcast-service-provider，然后通过DiscoveryClient来获取服务实例信息，然后获取ip和端口来访问。</p><p>但是实际环境中，我们往往会开启很多个itcast-service-provider的集群。此时我们获取的服务列表中就会有多个，到底该访问哪一个呢？</p><p>一般这种情况下我们就需要编写负载均衡算法，在多个实例列表中进行选择。</p><p>不过Eureka中已经帮我们集成了负载均衡组件：Ribbon，简单修改代码即可使用。</p><p>什么是Ribbon：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1525619257397.png" alt="1525619257397"></p><p>接下来，我们就来使用Ribbon实现负载均衡。</p><h2 id="3-1-启动两个服务实例"><a href="#3-1-启动两个服务实例" class="headerlink" title="3.1.启动两个服务实例"></a>3.1.启动两个服务实例</h2><p>首先参照itcast-eureka启动两个ItcastServiceProviderApplication实例，一个8081，一个8082。</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1540644966386.png" alt="1540644966386"></p><p>Eureka监控面板：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1540645032363.png" alt="1540645032363"></p><h2 id="3-2-开启负载均衡"><a href="#3-2-开启负载均衡" class="headerlink" title="3.2.开启负载均衡"></a>3.2.开启负载均衡</h2><p>因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖，直接修改代码。</p><p>修改itcast-service-consumer的引导类，在RestTemplate的配置方法上添加<code>@LoadBalanced</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改调用方式，不再手动获取ip和端口，而是直接通过服务名称调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"consumer/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@Autowired</span></span><br><span class="line">    <span class="comment">//private DiscoveryClient discoveryClient; // 注入discoveryClient，通过该客户端获取服务列表</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserById</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">        <span class="comment">// 通过client获取服务提供方的服务列表，这里我们只有一个</span></span><br><span class="line">        <span class="comment">// ServiceInstance instance = discoveryClient.getInstances("service-provider").get(0);</span></span><br><span class="line">        String baseUrl = <span class="string">"http://service-provider/user/"</span> + id;</span><br><span class="line">        User user = <span class="keyword">this</span>.restTemplate.getForObject(baseUrl, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问页面，查看结果：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1535674665806.png" alt="1535674665806"></p><p>完美！</p><h2 id="3-3-源码跟踪"><a href="#3-3-源码跟踪" class="headerlink" title="3.3.源码跟踪"></a>3.3.源码跟踪</h2><p>为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。</p><p>显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code></p><p>在如下代码打断点：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528774637934.png" alt="1528774637934"></p><p>一路源码跟踪：RestTemplate.getForObject –&gt; RestTemplate.execute –&gt; RestTemplate.doExecute：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528776129378.png" alt="1528776129378"></p><p>点击进入AbstractClientHttpRequest.execute –&gt; AbstractBufferingClientHttpRequest.executeInternal –&gt; InterceptingClientHttpRequest.executeInternal –&gt; InterceptingClientHttpRequest.execute:</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528776489965.png" alt="1528776489965"></p><p>继续跟入：LoadBalancerInterceptor.intercept方法</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528775270103.png" alt="1528775270103"></p><p>继续跟入execute方法：发现获取了8082端口的服务</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528775890956.png" alt="1528775890956"></p><p>再跟下一次，发现获取的是8081：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528775845812.png" alt="1528775845812"></p><h2 id="3-4-负载均衡策略"><a href="#3-4-负载均衡策略" class="headerlink" title="3.4.负载均衡策略"></a>3.4.负载均衡策略</h2><p>Ribbon默认的负载均衡策略是简单的轮询，我们可以测试一下：</p><p>编写测试类，在刚才的源码中我们看到拦截中是使用RibbonLoadBalanceClient来进行负载均衡的，其中有一个choose方法，找到choose方法的接口方法，是这样介绍的：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1525622320277.png" alt="1525622320277"></p><p>现在这个就是负载均衡获取实例的方法。</p><p>我们注入这个类的对象，然后对其测试：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528780835917.png" alt="1528780835917"></p><p>测试内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span>(<span class="title">classes</span> </span>= ItcastServiceConsumerApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">LoadBalanceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RibbonLoadBalancerClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLoadBalance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            ServiceInstance instance = <span class="keyword">this</span>.client.choose(<span class="string">"service-provider"</span>);</span><br><span class="line">            System.out.println(instance.getHost() + <span class="string">":"</span> +instance.getPort());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1535338345659.png" alt="1535338345659"></p><p>符合了我们的预期推测，确实是轮询方式。</p><p>我们是否可以修改负载均衡的策略呢？</p><p>继续跟踪源码，发现这么一段代码：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1525622652849.png" alt="1525622652849"></p><p>我们看看这个rule是谁：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1525622699666.png" alt="1525622699666"></p><p>这里的rule默认值是一个<code>RoundRobinRule</code>，看类的介绍：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1525622754316.png" alt="1525622754316"></p><p>这不就是轮询的意思嘛。</p><p>我们注意到，这个类其实是实现了接口IRule的，查看一下：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1525622817451.png" alt="1525622817451"></p><p>定义负载均衡的规则接口。</p><p>它有以下实现：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528782624098.png" alt="1528782624098"></p><p>SpringBoot也帮我们提供了修改负载均衡规则的配置入口，在itcast-service-consumer的application.yml中添加如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">service-consumer</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br><span class="line"><span class="attr">service-provider:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure><p>格式是：<code>{服务名称}.ribbon.NFLoadBalancerRuleClassName</code>，值就是IRule的实现类。</p><p>再次测试，发现结果变成了随机：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528782514987.png" alt="1528782514987"></p>]]></content>
      
      
      <categories>
          
          <category> springcolud教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springcolud </tag>
            
            <tag> iade </tag>
            
            <tag> javaweb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zuul</title>
      <link href="/posts/c1823aa1/"/>
      <url>/posts/c1823aa1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="5-Zuul网关"><a href="#5-Zuul网关" class="headerlink" title="5.Zuul网关"></a>5.Zuul网关</h1><p>通过前面的学习，使用Spring Cloud实现微服务的架构基本成型，大致是这样的：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1525674644660.png" alt="1525674644660"></p><pre><code>我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。我们把焦点聚集在对外服务这块，直接暴露我们的服务地址，这样的实现是否合理，或者是否有更好的实现方式呢？</code></pre><p>先来说说这样架构需要做的一些事儿以及存在的不足：</p><ul><li><p>破坏了服务无状态特点。</p><p>为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。</p><pre><code>从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。</code></pre></li><li><p>无法直接复用既有接口。</p><p>当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。</p></li></ul><p>面对类似上面的问题，我们要如何解决呢？答案是：服务网关！</p><p>为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器的 服务网关。</p><p>服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备<code>服务路由</code>、<code>均衡负载</code>功能之外，它还具备了<code>权限控制</code>等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。</p><h2 id="5-1-简介"><a href="#5-1-简介" class="headerlink" title="5.1.简介"></a>5.1.简介</h2><p>官网：<a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">https://github.com/Netflix/zuul</a></p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1525675037152.png" alt=""></p><p>Zuul：维基百科</p><p>电影《捉鬼敢死队》中的怪兽，Zuul，在纽约引发了巨大骚乱。</p><p>事实上，在微服务架构中，Zuul就是守门的大Boss！一夫当关，万夫莫开！</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="D:/ItResourceLibrary/%E7%AC%AC%E4%B8%89%E5%AD%A6%E6%9C%9F/%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E-2018%E5%B9%B411%E6%9C%8820-12%E6%9C%8817/leyou/day03-springcloud/%E7%AC%94%E8%AE%B0/assets/1525675168152.png" alt="1525675168152"></p><h2 id="5-2-Zuul加入后的架构"><a href="#5-2-Zuul加入后的架构" class="headerlink" title="5.2.Zuul加入后的架构"></a>5.2.Zuul加入后的架构</h2><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1525675648881.png" alt="1525675648881"></p><p>不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。</p><h2 id="5-3-快速入门"><a href="#5-3-快速入门" class="headerlink" title="5.3.快速入门"></a>5.3.快速入门</h2><h3 id="5-3-1-新建工程"><a href="#5-3-1-新建工程" class="headerlink" title="5.3.1.新建工程"></a>5.3.1.新建工程</h3><p>填写基本信息：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1529112749084.png" alt="1529112749084"></p><p>添加Zuul依赖：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1529112691169.png" alt="1529112691169"></p><h3 id="5-3-2-编写配置"><a href="#5-3-2-编写配置" class="headerlink" title="5.3.2.编写配置"></a>5.3.2.编写配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">api-gateway</span> <span class="comment">#指定服务名</span></span><br></pre></td></tr></table></figure><h3 id="5-3-3-编写引导类"><a href="#5-3-3-编写引导类" class="headerlink" title="5.3.3.编写引导类"></a>5.3.3.编写引导类</h3><p>通过<code>@EnableZuulProxy</code>注解开启Zuul的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span> <span class="comment">// 开启网关功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItcastZuulApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ItcastZuulApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-4-编写路由规则"><a href="#5-3-4-编写路由规则" class="headerlink" title="5.3.4.编写路由规则"></a>5.3.4.编写路由规则</h3><p>我们需要用Zuul来代理service-provider服务，先看一下控制面板中的服务状态：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1542672192226.png" alt="1542672192226"></p><ul><li>ip为：127.0.0.1</li><li>端口为：8081</li></ul><p>映射规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">api-gateway</span> <span class="comment">#指定服务名</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">service-provider:</span> <span class="comment"># 这里是路由id，随意写</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/service-provider/**</span> <span class="comment"># 这里是映射路径</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">http://127.0.0.1:8081</span> <span class="comment"># 映射路径对应的实际url地址</span></span><br></pre></td></tr></table></figure><p>我们将符合<code>path</code> 规则的一切请求，都代理到 <code>url</code>参数指定的地址</p><p>本例中，我们将 <code>/service-provider/**</code>开头的请求，代理到<a href="http://127.0.0.1:8081" target="_blank" rel="noopener">http://127.0.0.1:8081</a></p><h3 id="5-3-5-启动测试"><a href="#5-3-5-启动测试" class="headerlink" title="5.3.5.启动测试"></a>5.3.5.启动测试</h3><p>访问的路径中需要加上配置规则的映射路径，我们访问：<a href="http://127.0.0.1:10010/service-provider/user/1" target="_blank" rel="noopener">http://127.0.0.1:10010/service-provider/user/1</a></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1543054030005.png" alt="1543054030005"></p><h2 id="5-4-面向服务的路由"><a href="#5-4-面向服务的路由" class="headerlink" title="5.4.面向服务的路由"></a>5.4.面向服务的路由</h2><p>在刚才的路由规则中，我们把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然就不合理了。我们应该根据服务的名称，去Eureka注册中心查找 服务对应的所有实例列表，然后进行动态路由才对！</p><p>对itcast-zuul工程修改优化：</p><h3 id="5-4-1-添加Eureka客户端依赖"><a href="#5-4-1-添加Eureka客户端依赖" class="headerlink" title="5.4.1.添加Eureka客户端依赖"></a>5.4.1.添加Eureka客户端依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-4-2-添加Eureka配置，获取服务信息"><a href="#5-4-2-添加Eureka配置，获取服务信息" class="headerlink" title="5.4.2.添加Eureka配置，获取服务信息"></a>5.4.2.添加Eureka配置，获取服务信息</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">5</span> <span class="comment"># 获取服务列表的周期：5s</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><h3 id="5-4-3-开启Eureka客户端发现功能"><a href="#5-4-3-开启Eureka客户端发现功能" class="headerlink" title="5.4.3.开启Eureka客户端发现功能"></a>5.4.3.开启Eureka客户端发现功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span> <span class="comment">// 开启Zuul的网关功能</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(ZuulDemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-4-修改映射配置，通过服务名称获取"><a href="#5-4-4-修改映射配置，通过服务名称获取" class="headerlink" title="5.4.4.修改映射配置，通过服务名称获取"></a>5.4.4.修改映射配置，通过服务名称获取</h3><p>因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">service-provider:</span> <span class="comment"># 这里是路由id，随意写</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/service-provider/**</span> <span class="comment"># 这里是映射路径</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">service-provider</span> <span class="comment"># 指定服务名称</span></span><br></pre></td></tr></table></figure><h3 id="5-4-5-启动测试"><a href="#5-4-5-启动测试" class="headerlink" title="5.4.5.启动测试"></a>5.4.5.启动测试</h3><p>再次启动，这次Zuul进行代理时，会利用Ribbon进行负载均衡访问：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1543054030005.png" alt="1543054030005"></p><h2 id="5-5-简化的路由配置"><a href="#5-5-简化的路由配置" class="headerlink" title="5.5.简化的路由配置"></a>5.5.简化的路由配置</h2><p>在刚才的配置中，我们的规则是这样的：</p><ul><li><code>zuul.routes.&lt;route&gt;.path=/xxx/**</code>： 来指定映射路径。<code>&lt;route&gt;</code>是自定义的路由名</li><li><code>zuul.routes.&lt;route&gt;.serviceId=service-provider</code>：来指定服务名。</li></ul><p>而大多数情况下，我们的<code>&lt;route&gt;</code>路由名称往往和服务名会写成一样的。因此Zuul就提供了一种简化的配置语法：<code>zuul.routes.&lt;serviceId&gt;=&lt;path&gt;</code></p><p>比方说上面我们关于service-provider的配置可以简化为一条：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">service-provider:</span> <span class="string">/service-provider/**</span> <span class="comment"># 这里是映射路径</span></span><br></pre></td></tr></table></figure><p>省去了对服务名称的配置。</p><h2 id="5-6-默认的路由规则"><a href="#5-6-默认的路由规则" class="headerlink" title="5.6.默认的路由规则"></a>5.6.默认的路由规则</h2><p>在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁琐的。因此Zuul就指定了默认的路由规则：</p><ul><li>默认情况下，一切服务的映射路径就是服务名本身。例如服务名为：<code>service-provider</code>，则默认的映射路径就    是：<code>/service-provider/**</code></li></ul><p>也就是说，刚才的映射规则我们完全不配置也是OK的，不信就试试看。</p><h2 id="5-7-路由前缀"><a href="#5-7-路由前缀" class="headerlink" title="5.7.路由前缀"></a>5.7.路由前缀</h2><p>配置示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">service-provider:</span> <span class="string">/service-provider/**</span></span><br><span class="line">    <span class="attr">service-consumer:</span> <span class="string">/service-consumer/**</span></span><br><span class="line">  <span class="attr">prefix:</span> <span class="string">/api</span> <span class="comment"># 添加路由前缀</span></span><br></pre></td></tr></table></figure><p>我们通过<code>zuul.prefix=/api</code>来指定了路由的前缀，这样在发起请求时，路径就要以/api开头。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1543054221479.png" alt="1543054221479"></p><h2 id="5-8-过滤器"><a href="#5-8-过滤器" class="headerlink" title="5.8.过滤器"></a>5.8.过滤器</h2><p>Zuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个动作我们往往是通过Zuul提供的过滤器来实现的。</p><h3 id="5-8-1-ZuulFilter"><a href="#5-8-1-ZuulFilter" class="headerlink" title="5.8.1.ZuulFilter"></a>5.8.1.ZuulFilter</h3><p>ZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ZuulFilter implements IZuulFilter&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span></span>;<span class="comment">// 来自IZuulFilter</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException</span>;<span class="comment">// IZuulFilter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>shouldFilter</code>：返回一个<code>Boolean</code>值，判断该过滤器是否需要执行。返回true执行，返回false不执行。</li><li><code>run</code>：过滤器的具体业务逻辑。</li><li><code>filterType</code>：返回字符串，代表过滤器的类型。包含以下4种：<ul><li><code>pre</code>：请求在被路由之前执行</li><li><code>route</code>：在路由请求时调用</li><li><code>post</code>：在route和errror过滤器之后调用</li><li><code>error</code>：处理请求时发生错误调用</li></ul></li><li><code>filterOrder</code>：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。</li></ul><h3 id="5-8-2-过滤器执行生命周期"><a href="#5-8-2-过滤器执行生命周期" class="headerlink" title="5.8.2.过滤器执行生命周期"></a>5.8.2.过滤器执行生命周期</h3><p>这张是Zuul官网提供的请求生命周期图，清晰的表现了一个请求在各个过滤器的执行顺序。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1529152248172.png" alt="1529152248172"></p><p>正常流程：</p><ul><li>请求到达首先会经过pre类型过滤器，而后到达route类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。</li></ul><p>异常流程：</p><ul><li>整个过程中，pre或者route过滤器出现异常，都会直接进入error过滤器，在error处理完毕后，会将请求交给POST过滤器，最后返回给用户。</li><li>如果是error过滤器自己出现异常，最终也会进入POST过滤器，将最终结果返回给请求客户端。</li><li>如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和route不同的是，请求不会再到达POST过滤器了。</li></ul><p>所有内置过滤器列表：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1525682427811.png" alt=""></p><h3 id="5-8-3-使用场景"><a href="#5-8-3-使用场景" class="headerlink" title="5.8.3.使用场景"></a>5.8.3.使用场景</h3><p>场景非常多：</p><ul><li>请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了</li><li>异常处理：一般会在error类型和post类型过滤器中结合来处理。</li><li>服务调用时长统计：pre和post结合使用。</li></ul><h2 id="5-9-自定义过滤器"><a href="#5-9-自定义过滤器" class="headerlink" title="5.9.自定义过滤器"></a>5.9.自定义过滤器</h2><p>接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。</p><h3 id="5-9-1-定义过滤器类"><a href="#5-9-1-定义过滤器类" class="headerlink" title="5.9.1.定义过滤器类"></a>5.9.1.定义过滤器类</h3><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1529136926454.png" alt="1529136926454"></p><p>内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器类型，前置过滤器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器的执行顺序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该过滤器是否生效</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登陆校验逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ZuulException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取zuul提供的上下文对象</span></span><br><span class="line">        RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">        <span class="comment">// 从上下文对象中获取请求对象</span></span><br><span class="line">        HttpServletRequest request = context.getRequest();</span><br><span class="line">        <span class="comment">// 获取token信息</span></span><br><span class="line">        String token = request.getParameter(<span class="string">"access-token"</span>);</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">            <span class="comment">// 过滤该请求，不对其进行路由</span></span><br><span class="line">            context.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 设置响应状态码，401</span></span><br><span class="line">            context.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED);</span><br><span class="line">            <span class="comment">// 设置响应信息</span></span><br><span class="line">            context.setResponseBody(<span class="string">"&#123;\"status\":\"401\", \"text\":\"request error!\"&#125;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校验通过，把登陆信息放入上下文信息，继续向后执行</span></span><br><span class="line">        context.set(<span class="string">"token"</span>, token);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-9-2-测试"><a href="#5-9-2-测试" class="headerlink" title="5.9.2.测试"></a>5.9.2.测试</h3><p>没有token参数时，访问失败：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1529161460740.png" alt="1529161460740"></p><p>添加token参数后：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1529161252733.png" alt="1529161252733"></p><h2 id="5-10-负载均衡和熔断"><a href="#5-10-负载均衡和熔断" class="headerlink" title="5.10.负载均衡和熔断"></a>5.10.负载均衡和熔断</h2><p>Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">2000</span> <span class="comment"># 设置hystrix的超时时间为6000ms</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springcolud教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springcolud </tag>
            
            <tag> iade </tag>
            
            <tag> javaweb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eureka</title>
      <link href="/posts/ecf3d7bd/"/>
      <url>/posts/ecf3d7bd/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="2-Eureka注册中心"><a href="#2-Eureka注册中心" class="headerlink" title="2.Eureka注册中心"></a>2.Eureka注册中心</h1><h2 id="2-1-认识Eureka"><a href="#2-1-认识Eureka" class="headerlink" title="2.1.认识Eureka"></a>2.1.认识Eureka</h2><p>首先我们来解决第一问题，服务的管理。</p><blockquote><p>问题分析</p></blockquote><p>在刚才的案例中，itcast-service-provider对外提供服务，需要对外暴露自己的地址。而consumer（调用者）需要记录服务提供者的地址。将来地址出现变更，还需要及时更新。这在服务较少的时候并不觉得有什么，但是在现在日益复杂的互联网环境，一个项目肯定会拆分出十几，甚至数十个微服务。此时如果还人为管理地址，不仅开发困难，将来测试、发布上线都会非常麻烦，这与DevOps的思想是背道而驰的。</p><blockquote><p>网约车</p></blockquote><p>这就好比是 网约车出现以前，人们出门叫车只能叫出租车。一些私家车想做出租却没有资格，被称为黑车。而很多人想要约车，但是无奈出租车太少，不方便。私家车很多却不敢拦，而且满大街的车，谁知道哪个才是愿意载人的。一个想要，一个愿意给，就是缺少引子，缺乏管理啊。</p><p>此时滴滴这样的网约车平台出现了，所有想载客的私家车全部到滴滴注册，记录你的车型（服务类型），身份信息（联系方式）。这样提供服务的私家车，在滴滴那里都能找到，一目了然。</p><p>此时要叫车的人，只需要打开APP，输入你的目的地，选择车型（服务类型），滴滴自动安排一个符合需求的车到你面前，为你服务，完美！</p><blockquote><p>Eureka做什么？</p></blockquote><p>Eureka就好比是滴滴，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。</p><p>同时，服务提供方与Eureka之间通过<code>“心跳”</code>机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。</p><p>这就实现了服务的自动注册、发现、状态监控。</p><h2 id="2-2-原理图"><a href="#2-2-原理图" class="headerlink" title="2.2.原理图"></a>2.2.原理图</h2><blockquote><p>基本架构：</p></blockquote><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84.png" alt="基本架构"></p><ul><li>Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址</li><li>提供者：启动后向Eureka注册自己信息（地址，提供什么服务）</li><li>消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新</li><li>心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态</li></ul><h2 id="2-3-入门案例"><a href="#2-3-入门案例" class="headerlink" title="2.3.入门案例"></a>2.3.入门案例</h2><h3 id="2-3-1-搭建EurekaServer"><a href="#2-3-1-搭建EurekaServer" class="headerlink" title="2.3.1.搭建EurekaServer"></a>2.3.1.搭建EurekaServer</h3><p>接下来我们创建一个项目，启动一个EurekaServer：</p><p>依然使用spring提供的快速搭建工具：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528295484808.png" alt="1528295484808"></p><p>选择依赖：EurekaServer-服务注册中心依赖，Eureka Discovery-服务提供方和服务消费方。因为，对于eureka来说：服务提供方和服务消费方都属于客户端</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528295612501.png" alt="1528295612501"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528295690203.png" alt="1528295690203"></p><p>完整的Pom文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.eureka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itcast-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>itcast-eureka<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.RC2<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写application.yml配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span> <span class="comment"># 端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span> <span class="comment"># 应用名称，会在Eureka中显示</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:$&#123;server.port&#125;/eureka</span></span><br></pre></td></tr></table></figure><p>修改引导类，在类上添加@EnableEurekaServer注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span> <span class="comment">// 声明当前springboot应用是一个eureka服务中心</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItcastEurekaApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ItcastEurekaApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动服务，并访问：<a href="http://127.0.0.1:10086" target="_blank" rel="noopener">http://127.0.0.1:10086</a></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1525604959508.png" alt="1525604959508"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/eruker.png" alt="1533793804268"></p><h3 id="2-3-2-注册到Eureka"><a href="#2-3-2-注册到Eureka" class="headerlink" title="2.3.2.注册到Eureka"></a>2.3.2.注册到Eureka</h3><p>注册服务，就是在服务上添加Eureka的客户端依赖，客户端代码会自动把服务注册到EurekaServer中。</p><p>修改itcast-service-provider工程</p><ol><li>在pom.xml中，添加springcloud的相关依赖。</li><li>在application.yml中，添加springcloud的相关依赖。</li><li>在引导类上添加注解，把服务注入到eureka注册中心。</li></ol><p>具体操作</p><h4 id="2-3-2-1-pom-xml"><a href="#2-3-2-1-pom-xml" class="headerlink" title="2.3.2.1.pom.xml"></a>2.3.2.1.pom.xml</h4><p>参照itcast-eureka，先添加SpringCloud依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringCloud的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.SR2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后是Eureka客户端：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Eureka客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完整pom.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.service<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itcast-service-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>itcast-service-provider<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-2-2-application-yml"><a href="#2-3-2-2-application-yml" class="headerlink" title="2.3.2.2.application.yml"></a>2.3.2.2.application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/heima</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">service-provider</span> <span class="comment"># 应用名称，注册到eureka后的服务名称</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">cn.itcast.service.pojo</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># EurekaServer地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>这里我们添加了spring.application.name属性来指定应用名称，将来会作为应用的id使用。</li></ul><h4 id="2-3-2-3-引导类"><a href="#2-3-2-3-引导类" class="headerlink" title="2.3.2.3.引导类"></a>2.3.2.3.引导类</h4><p>在引导类上开启Eureka客户端功能</p><p>通过添加<code>@EnableDiscoveryClient</code>来开启Eureka客户端功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItcastServiceProviderApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ItcastServiceApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重启项目，访问<a href="http://127.0.0.1:10086" target="_blank" rel="noopener">Eureka监控页面</a>查看</p></blockquote><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1525609225152.png" alt="1525609225152"></p><p>我们发现service-provider服务已经注册成功了</p><h3 id="2-3-3-从Eureka获取服务"><a href="#2-3-3-从Eureka获取服务" class="headerlink" title="2.3.3.从Eureka获取服务"></a>2.3.3.从Eureka获取服务</h3><p>接下来我们修改itcast-service-consumer，尝试从EurekaServer获取服务。</p><p>方法与消费者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！</p><ol><li>pom.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.service<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itcast-service-consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>itcast-service-consumer<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Eureka客户端 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- SpringCloud的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.SR2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>修改配置</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">service-consumer</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:10086/eureka</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在启动类开启Eureka客户端</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">// 开启Eureka客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItcastServiceConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ItcastServiceConsumerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>修改UserController代码，用DiscoveryClient类的方法，根据服务名称，获取服务实例：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"consumer/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient; <span class="comment">// eureka客户端，可以获取到eureka中服务的信息</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserById</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">        <span class="comment">// 根据服务名称，获取服务实例。有可能是集群，所以是service实例集合</span></span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">"service-provider"</span>);</span><br><span class="line">        <span class="comment">// 因为只有一个Service-provider。所以获取第一个实例</span></span><br><span class="line">        ServiceInstance instance = instances.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 获取ip和端口信息，拼接成服务地址</span></span><br><span class="line">        String baseUrl = <span class="string">"http://"</span> + instance.getHost() + <span class="string">":"</span> + instance.getPort() + <span class="string">"/user/"</span> + id;</span><br><span class="line">        User user = <span class="keyword">this</span>.restTemplate.getForObject(baseUrl, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5）Debug跟踪运行：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528534110188.png" alt="1528534110188"></p><p>生成的URL：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528534148651.png" alt="1528534148651"></p><p>访问结果：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1535674665806.png" alt="1535674665806"></p><h2 id="2-4-Eureka详解"><a href="#2-4-Eureka详解" class="headerlink" title="2.4.Eureka详解"></a>2.4.Eureka详解</h2><p>接下来我们详细讲解Eureka的原理及配置。</p><h3 id="2-4-1-基础架构"><a href="#2-4-1-基础架构" class="headerlink" title="2.4.1.基础架构"></a>2.4.1.基础架构</h3><p>Eureka架构中的三个核心角色：</p><ul><li><p>服务注册中心</p><p>Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的itcast-eureka。</p></li><li><p>服务提供者</p><p>提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。本例中就是我们实现的itcast-service-provider。</p></li><li><p>服务消费者</p><p>消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。本例中就是我们实现的itcast-service-consumer。</p></li></ul><h3 id="2-4-2-高可用的Eureka-Server"><a href="#2-4-2-高可用的Eureka-Server" class="headerlink" title="2.4.2.高可用的Eureka Server"></a>2.4.2.高可用的Eureka Server</h3><p>Eureka Server即服务的注册中心，在刚才的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个集群，形成高可用的Eureka中心。</p><blockquote><p>服务同步</p></blockquote><p>多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现<strong>数据同步</strong>。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息。</p><blockquote><p>动手搭建高可用的EurekaServer</p></blockquote><p>我们假设要运行两个EurekaServer的集群，端口分别为：10086和10087。只需要把itcast-eureka启动两次即可。</p><p>1）启动第一个eurekaServer，我们修改原来的EurekaServer配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span> <span class="comment"># 端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span> <span class="comment"># 应用名称，会在Eureka中显示</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># 配置其他Eureka服务的地址，而不是自己，比如10087</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10087/eureka</span></span><br></pre></td></tr></table></figure><p>所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务进行注册，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改：</p><ul><li>把service-url的值改成了另外一台EurekaServer的地址，而不是自己</li></ul><p>启动报错，很正常。因为10087服务没有启动：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="/images/1528691515859.png" alt="1528691515859"></p><p>2）启动第二个eurekaServer，再次修改itcast-eureka的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10087</span> <span class="comment"># 端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span> <span class="comment"># 应用名称，会在Eureka中显示</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># 配置其他Eureka服务的地址，而不是自己，比如10087</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><p>注意：idea中一个应用不能启动两次，我们需要重新配置一个启动器：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528540668018.png" alt="1528540668018"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528691728618.png" alt="1528691728618"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528693484031.png" alt="1528693484031"></p><p>然后启动即可。</p><p>3）访问集群，测试：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528693648200.png" alt="1528693648200"></p><p>4）客户端注册服务到集群</p><p>因为EurekaServer不止一个，因此注册服务的时候，service-url参数需要变化：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># EurekaServer地址,多个地址以','隔开</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka</span></span><br></pre></td></tr></table></figure><p>10086：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528693943950.png" alt="1528693943950"></p><p>10087：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528693979654.png" alt="1528693979654"></p><h3 id="2-4-3-服务提供者"><a href="#2-4-3-服务提供者" class="headerlink" title="2.4.3.服务提供者"></a>2.4.3.服务提供者</h3><p>服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。</p><blockquote><p>服务注册</p></blockquote><p>服务提供者在启动时，会检测配置属性中的：<code>eureka.client.register-with-eureka=true</code>参数是否正确，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个双层Map结构中。</p><ul><li>第一层Map的Key就是服务id，一般是配置中的<code>spring.application.name</code>属性</li><li>第二层Map的key是服务的实例id。一般host+ serviceId + port，例如：<code>locahost:service-provider:8081</code></li><li>值则是服务的实例对象，也就是说一个服务，可以同时启动多个不同实例，形成集群。</li></ul><blockquote><p>服务续约</p></blockquote><p>在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）；</p><p>有两个重要参数可以修改服务续约的行为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">90</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><ul><li>lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒</li><li>lease-expiration-duration-in-seconds：服务失效时间，默认值90秒</li></ul><p>也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。</p><p>但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">10</span> <span class="comment"># 10秒即过期</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">5</span> <span class="comment"># 5秒一次心跳</span></span><br></pre></td></tr></table></figure><h3 id="2-4-4-服务消费者"><a href="#2-4-4-服务消费者" class="headerlink" title="2.4.4.服务消费者"></a>2.4.4.服务消费者</h3><blockquote><p>获取服务列表</p></blockquote><p>当服务消费者启动时，会检测<code>eureka.client.fetch-registry=true</code>参数的值，如果为true，则会拉取Eureka Server服务的列表只读备份，然后缓存在本地。并且<code>每隔30秒</code>会重新获取并更新数据。我们可以通过下面的参数来修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>生产环境中，我们不需要修改这个值。</p><p>但是为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点。</p><h3 id="2-4-5-失效剔除和自我保护"><a href="#2-4-5-失效剔除和自我保护" class="headerlink" title="2.4.5.失效剔除和自我保护"></a>2.4.5.失效剔除和自我保护</h3><blockquote><p>服务下线</p></blockquote><p>当服务进行正常关闭操作时，它会触发一个服务下线的REST请求给Eureka Server，告诉服务注册中心：“我要下线了”。服务中心接受到请求之后，将该服务置为下线状态。</p><blockquote><p>失效剔除</p></blockquote><p>有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。</p><p>可以通过<code>eureka.server.eviction-interval-timer-in-ms</code>参数对其进行修改，单位是毫秒，生产环境不要修改。</p><p>这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如：10秒</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528696142799.png" alt="1528696142799"></p><blockquote><p>自我保护</p></blockquote><p>我们关停一个服务，就会在Eureka面板看到一条警告：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1525618396076.png" alt="1525618396076"></p><p>这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。</p><p>但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式：（itcast-eureka）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 关闭自我保护模式（缺省为打开）</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">1000</span> <span class="comment"># 扫描失效服务的间隔时间（缺省为60*1000ms）</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> springcolud教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springcolud </tag>
            
            <tag> iade </tag>
            
            <tag> javaweb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务场景模拟</title>
      <link href="/posts/85eab82b/"/>
      <url>/posts/85eab82b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-微服务场景模拟"><a href="#1-微服务场景模拟" class="headerlink" title="1.微服务场景模拟"></a>1.微服务场景模拟</h1><p>首先，我们需要模拟一个服务调用的场景，搭建两个工程：itcast-service-provider（服务提供方）和itcast-service-consumer（服务调用方）。方便后面学习微服务架构</p><p>服务提供方：使用mybatis操作数据库，实现对数据的增删改查；并对外提供rest接口服务。</p><p>服务消费方：使用restTemplate远程调用服务提供方的rest接口服务，获取数据。</p><h2 id="1-1-服务提供者"><a href="#1-1-服务提供者" class="headerlink" title="1.1.服务提供者"></a>1.1.服务提供者</h2><p>我们新建一个项目：itcast-service-provider，对外提供根据id查询用户的服务。</p><h3 id="1-1-1-Spring脚手架创建工程"><a href="#1-1-1-Spring脚手架创建工程" class="headerlink" title="1.1.1.Spring脚手架创建工程"></a>1.1.1.Spring脚手架创建工程</h3><p>借助于Spring提供的快速搭建工具：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528266515225.png" alt="1528266515225"></p><p>next–&gt;填写项目信息：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528266803455.png" alt="1528266803455"></p><p>next –&gt;  添加web依赖：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528266923967.png" alt="1528266923967"></p><p>添加mybatis依赖：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528267588935.png" alt="1528267588935"></p><p>Next –&gt;  填写项目位置：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528267665004.png" alt="1528267665004"></p><p>生成的项目结构，已经包含了引导类（itcastServiceProviderApplication）：</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528267830854.png" alt="1528267830854"></p><p>依赖也已经全部自动引入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.service<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itcast-service-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>itcast-service-provider<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 需要手动引入通用mapper的启动器，spring没有收录该依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然，因为要使用通用mapper，所以我们<strong>需要手动加一条依赖</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>非常快捷啊！</p><h3 id="1-1-2-编写代码"><a href="#1-1-2-编写代码" class="headerlink" title="1.1.2.编写代码"></a>1.1.2.编写代码</h3><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1535671376231.png" alt="1535671376231"></p><h4 id="1-1-2-1-配置"><a href="#1-1-2-1-配置" class="headerlink" title="1.1.2.1.配置"></a>1.1.2.1.配置</h4><p>属性文件,这里我们采用了yaml语法，而不是properties：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis</span> <span class="comment">#你学习mybatis时，使用的数据库地址</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">cn.itcast.service.pojo</span></span><br></pre></td></tr></table></figure><h4 id="1-1-2-2-实体类"><a href="#1-1-2-2-实体类" class="headerlink" title="1.1.2.2.实体类"></a>1.1.2.2.实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Table</span>(name = <span class="string">"tb_user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户名</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 密码</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 性别，1男性，2女性</span></span><br><span class="line">    <span class="keyword">private</span> Integer sex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出生日期</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建时间</span></span><br><span class="line">    <span class="keyword">private</span> Date created;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新时间</span></span><br><span class="line">    <span class="keyword">private</span> Date updated;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(Integer sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getCreated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> created;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCreated</span><span class="params">(Date created)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.created = created;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getUpdated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> updated;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpdated</span><span class="params">(Date updated)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.updated = updated;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-2-3-UserMapper"><a href="#1-1-2-3-UserMapper" class="headerlink" title="1.1.2.3.UserMapper"></a>1.1.2.3.UserMapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">tk</span>.<span class="title">mybatis</span>.<span class="title">mapper</span>.<span class="title">common</span>.<span class="title">Mapper</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-2-4-UserService"><a href="#1-1-2-4-UserService" class="headerlink" title="1.1.2.4.UserService"></a>1.1.2.4.UserService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userMapper.selectByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-5-UserController"><a href="#4-1-2-5-UserController" class="headerlink" title="4.1.2.5.UserController"></a>4.1.2.5.UserController</h4><p>添加一个对外查询的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userService.queryById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-3-启动并测试"><a href="#1-1-3-启动并测试" class="headerlink" title="1.1.3.启动并测试"></a>1.1.3.启动并测试</h3><p>启动项目，访问接口：<a href="http://localhost:8081/user/1" target="_blank" rel="noopener">http://localhost:8081/user/1</a></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528272537927.png" alt="1528272537927"></p><h2 id="1-2-服务调用者"><a href="#1-2-服务调用者" class="headerlink" title="1.2.服务调用者"></a>1.2.服务调用者</h2><p>搭建itcast-service-consumer服务消费方工程。</p><h3 id="1-2-1-创建工程"><a href="#1-2-1-创建工程" class="headerlink" title="1.2.1.创建工程"></a>1.2.1.创建工程</h3><p>与上面类似，这里不再赘述，需要注意的是，我们调用itcast-service-provider的解耦获取数据，因此不需要mybatis相关依赖了。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528272829384.png" alt="1528272829384"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528272875502.png" alt="1528272875502"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1528273029361.png" alt="1528273029361"></p><p>pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.service<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itcast-service-consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>itcast-service-consumer<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-2-编写代码"><a href="#1-2-2-编写代码" class="headerlink" title="1.2.2.编写代码"></a>1.2.2.编写代码</h3><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1540643087305.png" alt="1540643087305"></p><p>首先在引导类中注册<code>RestTemplate</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItcastServiceConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ItcastServiceConsumerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写配置（application.yml）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 80</span><br></pre></td></tr></table></figure><p>编写UserController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"consumer/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserById</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">        User user = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://localhost:8081/user/"</span> + id, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pojo对象（User）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户名</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 密码</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 性别，1男性，2女性</span></span><br><span class="line">    <span class="keyword">private</span> Integer sex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出生日期</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建时间</span></span><br><span class="line">    <span class="keyword">private</span> Date created;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新时间</span></span><br><span class="line">    <span class="keyword">private</span> Date updated;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(Integer sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getCreated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> created;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCreated</span><span class="params">(Date created)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.created = created;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getUpdated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> updated;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpdated</span><span class="params">(Date updated)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.updated = updated;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-3-启动测试"><a href="#1-2-3-启动测试" class="headerlink" title="1.2.3.启动测试"></a>1.2.3.启动测试</h3><p>因为我们没有配置端口，那么默认就是8080，我们访问：<a href="http://localhost/consumer/user?id=1" target="_blank" rel="noopener">http://localhost/consumer/user?id=1</a></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1535587919022.png" alt="1535587919022"></p><p>一个简单的远程服务调用案例就实现了。</p><h2 id="1-3-有没有问题？"><a href="#1-3-有没有问题？" class="headerlink" title="1.3.有没有问题？"></a>1.3.有没有问题？</h2><p>简单回顾一下，刚才我们写了什么：</p><ul><li>itcast-service-provider：一个提供根据id查询用户的微服务。</li><li>itcast-service-consumer：一个服务调用者，通过RestTemplate远程调用itcast-service-provider。</li></ul><p>存在什么问题？</p><ul><li>在consumer中，我们把url地址硬编码到了代码中，不方便后期维护</li><li>consumer需要记忆provider的地址，如果出现变更，可能得不到通知，地址将失效</li><li>consumer不清楚provider的状态，服务宕机也不知道</li><li>provider只有1台服务，不具备高可用性</li><li>即便provider形成集群，consumer还需自己实现负载均衡</li></ul><p>其实上面说的问题，概括一下就是分布式服务必然要面临的问题：</p><ul><li>服务管理<ul><li>如何自动注册和发现</li><li>如何实现状态监管</li><li>如何实现动态路由</li></ul></li><li>服务如何实现负载均衡</li><li>服务如何解决容灾问题</li><li>服务如何实现统一配置</li></ul><p>以上的问题，我们都将在SpringCloud中得到答案。</p>]]></content>
      
      
      <categories>
          
          <category> springcolud教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springcolud </tag>
            
            <tag> iade </tag>
            
            <tag> javaweb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务基础知识</title>
      <link href="/posts/ac8c8fdc/"/>
      <url>/posts/ac8c8fdc/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        springcloud是一系列框架的有序集合，是基于springboot上演变来的，所以本教程适合有ssm基础懂springboot的童鞋学习</p><h3 id="1-系统架构的演变"><a href="#1-系统架构的演变" class="headerlink" title="1.系统架构的演变"></a>1.系统架构的演变</h3><p>​       随着互联网的发展，系统架构由单体应用架构 –&gt; 垂直应用架构 –&gt; 分布式SOA架构 – &gt;微服务架构。</p><h4 id="1-1-单体应用架构"><a href="#1-1-单体应用架构" class="headerlink" title="1.1 单体应用架构"></a>1.1 单体应用架构</h4><p>​        web应用程序发展早期，大部分web工程(包含前端页面，web层代码，service层代码，dao层代码)是将所有的功能模块，打包到一起并放在一个web容器中运行。</p><p> <strong>优点：</strong></p><ul><li><p>所有的功能集成到一个项目中</p><ul><li>项目架构简单，开发成本低，周期短，小型项目首选</li></ul><p><strong>缺点：</strong></p></li><li><p>全部功能集中到一起，对应大型项目不易开发，扩展及维护。</p></li><li><p>系统性能扩展只能通过扩展集群节点，成本高，有瓶颈。</p></li><li><p>技术栈受限</p></li></ul><h4 id="1-2-垂直应用架构"><a href="#1-2-垂直应用架构" class="headerlink" title="1.2 垂直应用架构"></a>1.2 垂直应用架构</h4><p>​       访问量增大，单一应用增加机器带来的加速度越来越小，将应用拆分成互不相干的几个应用，以提升效率</p><p><strong>优点</strong></p><ul><li><p>项目架构简单，前期开发成本低，周期短，适合小项目</p></li><li><p>通过垂直拆分，原来的单体应用不至于无限扩大</p></li><li><p>不同的项目可采用不同的技术</p><p><strong>缺点</strong></p><ul><li>系统性能扩展只能通过扩展集群节点，成本高，有瓶颈</li><li>全部功能集成再一个工程中，对于大型项目不易开发，扩展及维护</li></ul></li></ul><h4 id="1-3-分布式SOA架构"><a href="#1-3-分布式SOA架构" class="headerlink" title="1.3 分布式SOA架构"></a>1.3 分布式SOA架构</h4><p>​       SOA全称为Service-Oriented Architecture，即面向服务的架构，它可以根据需求通过网络对松散耦合的粗粒度应用组件（服务）进行分布式部署，组合和使用。站在功能角度看，可以把业务逻辑抽象成可复用可组装的服务，通过服务的编排实现业务的快速再生。</p><p>特点是：分布式，可重用，扩展灵活，松耦合</p><h4 id="1-4单体，垂直，SOA对比图"><a href="#1-4单体，垂直，SOA对比图" class="headerlink" title="1.4单体，垂直，SOA对比图"></a>1.4单体，垂直，SOA对比图</h4><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/hongmaple/CDN@master/images/springcloud/1%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png" alt=""></p><h4 id="1-5-微服务架构"><a href="#1-5-微服务架构" class="headerlink" title="1.5 微服务架构"></a>1.5 微服务架构</h4><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="http://img2018.cnblogs.com/blog/918692/201811/918692-20181120160203049-1663158822.png" alt="微服务架构图"></p><p><strong>优点：</strong></p><ul><li><p>通过服务的原子拆分，以及微服务的独立打包，部署和升级，小团队的交付周期将缩短，运维成本也将大幅度下降</p></li><li><p>微服务遵循单一原则。微服务之间采用Restful等轻量协议传输。</p><p><strong>缺点:</strong></p></li><li><p>微服务过多，服务治理成本高，不利于系统维护。</p></li><li><p>分布式系统开发的技术成本高（容错，分布式事务等）。</p></li></ul><h4 id="1-6-SOA与微服务的关系"><a href="#1-6-SOA与微服务的关系" class="headerlink" title="1.6 SOA与微服务的关系"></a>1.6 SOA与微服务的关系</h4><p> <strong>SOA</strong>是面向服务的架构，他是一种设计方法，其中包含多个服务，服务之间通过相互依赖最终提供一系列的功能。一个服务通常以独立的形式存在与操作系统进程中。各个服务之间通过网络调用。</p><p><strong>微服务架构：</strong>其实和SOA架构类似，微服务是在SOA上做的升华，微服务架构强调的一个重点是业务需要彻底的组件化和服务化，原有的单个业务系统会拆分为多个可以独立开发，设计，运行的小应用。这些小组件之间通过服务完成交互和集成。</p><table><thead><tr><th>功能</th><th>SOA</th><th>微服务</th></tr></thead><tbody><tr><td>组件大小</td><td>大块业务逻辑</td><td>单独任务或小块业务逻辑</td></tr><tr><td>耦合</td><td>通常松耦合</td><td>总是松耦合</td></tr><tr><td>公司架构</td><td>任何类型</td><td>小型，专注于功能交叉团队</td></tr><tr><td>管理</td><td>着重中央管理</td><td>着重分散管理</td></tr><tr><td>目标</td><td>确保应用能够交互操作</td><td>执行新功能，快速拓展开发团队</td></tr></tbody></table><h3 id="2-分布式的核心知识"><a href="#2-分布式的核心知识" class="headerlink" title="2.分布式的核心知识"></a>2.分布式的核心知识</h3><h3 id="2-1-分布式中的远程调用"><a href="#2-1-分布式中的远程调用" class="headerlink" title="2.1 分布式中的远程调用"></a>2.1 分布式中的远程调用</h3><h4 id="1-RPC和HTTP"><a href="#1-RPC和HTTP" class="headerlink" title="1.RPC和HTTP"></a>1.RPC和HTTP</h4><p>无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？</p><p>常见的远程调用方式有以下2种：</p><ul><li><p>RPC：Remote Produce Call远程过程调用，类似的还有RMI。<u>自定义数据格式</u>，<u>基于原生TCP通信，速度快，效率高</u>。早期的webservice，现在热门的dubbo，都是RPC的典型代表</p></li><li><p>Http：http其实是一种网络传输协议，基于TCP，<u>规定了数据传输的格式</u>。现在客户端浏览器与服务端通信基本都是采用Http协议，也可以用来进行远程服务调用。缺点是消息封装臃肿，<u>优势是对服务的提供和调用方没有任何技术限定，自由灵活，更符合微服务理念</u>。</p><p>现在热门的Rest风格，就可以通过http协议来实现。</p></li></ul><p>如果你们公司全部采用Java技术栈，那么使用Dubbo作为微服务架构是一个不错的选择。</p><p>相反，<u>如果公司的技术栈多样化，而且你更青睐Spring家族，那么SpringCloud搭建微服务是不二之选</u>。在我们的项目中，我们会选择SpringCloud套件，因此我们会使用Http方式来实现服务间调用。</p><h4 id="2-Http客户端工具"><a href="#2-Http客户端工具" class="headerlink" title="2.Http客户端工具"></a>2.Http客户端工具</h4><p>既然微服务选择了Http，那么我们就需要考虑自己来实现对请求和响应的处理。不过开源世界已经有很多的http客户端工具，能够帮助我们做这些事情，例如：</p><ul><li>HttpClient</li><li>OKHttp</li><li>URLConnection</li></ul><p>接下来，不过这些不同的客户端，API各不相同</p><h4 id="3-Spring的RestTemplate"><a href="#3-Spring的RestTemplate" class="headerlink" title="3.Spring的RestTemplate"></a>3.Spring的RestTemplate</h4><p>Spring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持：</p><ul><li>HttpClient</li><li>OkHttp</li><li>JDK原生的URLConnection（默认的）</li></ul><p>首先在项目中注册一个<code>RestTemplate</code>对象，可以在启动类位置注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(HttpDemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类中直接<code>@Autowired</code>注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span>(<span class="title">classes</span> </span>= HttpDemoApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">HttpDemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">httpGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用springboot案例中的rest接口</span></span><br><span class="line">User user = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://localhost/user/1"</span>, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码，RestTemplate会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化。</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://github.com//hongmaple/hongmaple.github.io/blob/master/images/it-images/1525573702492.png?raw=true" alt="1525573702492"></p><h3 id="2-2-CAP原理"><a href="#2-2-CAP原理" class="headerlink" title="2.2 CAP原理"></a>2.2 CAP原理</h3><p>CAP理论：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。如下图所示<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://img-blog.csdn.net/20180725223937836?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MTY1NTk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h4 id="CAP的定义"><a href="#CAP的定义" class="headerlink" title="CAP的定义"></a>CAP的定义</h4><p><strong><em>一致性</em></strong><br>所有节点在同一时间的数据完全一致，一致性说的就是分布式数据一致性。<br>对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是<strong>强一致性</strong>。如果能容忍后续的部分或者全部访问不到，则是<strong>弱一致性</strong>。如果经过一段时间后要求能访问到更新后的数据，则是<strong>最终一致性</strong>。CAP中说，不可能同时满足的这个一致性指的是强一致性。<br><strong><em>可用性</em></strong><br>对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。所以，一般我们在衡量一个系统的可用性的时候，都是通过停机时间来计算的。</p><table><thead><tr><th>可用性分类</th><th>可用水平（%）</th><th>年可容忍停机时间</th></tr></thead><tbody><tr><td>容错可用性</td><td>99.9999</td><td>&lt;1min</td></tr><tr><td>极高可用性</td><td>99.999</td><td>&lt;5min</td></tr><tr><td>具有故障自动恢复能力的可用性</td><td>99.99</td><td>&lt;53min</td></tr><tr><td>高可用性</td><td>99.9</td><td>&lt;8.8h</td></tr><tr><td>商品可用性</td><td>99</td><td>&lt;43.8h</td></tr></tbody></table><p>通常我们描述一个系统的可用性时，我们说淘宝的系统可用性可以达到5个9，意思就是说他的可用水平是99.999%，即全年停机时间不超过 (1-0.99999)<em>365</em>24<em>60 = 5.256 min，这是一个极高的要求。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。一个分布式系统，上下游设计很多系统如负载均衡、WEB服务器、应用代码、数据库服务器等，任何一个节点的不稳定都可以影响可用性。<br>*</em>分区容错性**<br>分区容错性指分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。<br>分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。简单点说，就是<strong>在网络中断，消息丢失的情况下，系统如果还能正常工作，就是有比较好的分区容错性</strong>。</p><h4 id="CAP的证明"><a href="#CAP的证明" class="headerlink" title="CAP的证明"></a>CAP的证明</h4><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://img-blog.csdn.net/20180725224549170?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MTY1NTk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>如上图，是我们证明CAP的基本场景，网络中有两个节点N1和N2，可以简单的理解N1和N2分别是两台计算机，他们之间网络可以连通，N1中有一个应用程序A，和一个数据库V，N2也有一个应用程序B2和一个数据库V。现在，A和B是分布式系统的两个部分，V是分布式系统的数据存储的两个子数据库。<br>在满足一致性的时候，N1和N2中的数据是一样的，V0=V0。在满足可用性的时候，用户不管是请求N1或者N2，都会得到立即响应。在满足分区容错性的情况下，N1和N2有任何一方宕机，或者网络不通的时候，都不会影响N1和N2彼此之间的正常运作。<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://img-blog.csdn.net/20180725224626679?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MTY1NTk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>如上图，是分布式系统正常运转的流程，用户向N1机器请求数据更新，程序A更新数据库Vo为V1，分布式系统将数据进行同步操作M，将V1同步的N2中V0，使得N2中的数据V0也更新为V1，N2中的数据再响应N2的请求。<br>这里，可以定义N1和N2的数据库V之间的数据是否一样为一致性；外部对N1和N2的请求响应为可用行；N1和N2之间的网络环境为分区容错性。这是正常运作的场景，也是理想的场景，然而现实是残酷的，当错误发生的时候，一致性和可用性还有分区容错性，是否能同时满足，还是说要进行取舍呢？<br>作为一个分布式系统，它和单机系统的最大区别，就在于网络，现在假设一种极端情况，N1和N2之间的网络断开了，我们要支持这种网络异常，相当于要满足分区容错性，能不能同时满足一致性和响应性呢？还是说要对他们进行取舍。<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://img-blog.csdn.net/20180725224703604?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MTY1NTk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>假设在N1和N2之间网络断开的时候，有用户向N1发送数据更新请求，那N1中的数据V0将被更新为V1，由于网络是断开的，所以分布式系统同步操作M，所以N2中的数据依旧是V0；这个时候，有用户向N2发送数据读取请求，由于数据还没有进行同步，应用程序没办法立即给用户返回最新的数据V1，怎么办呢？<br>有二种选择，第一，牺牲数据一致性，保证可用性。响应旧的数据V0给用户；第二，牺牲可用性，保证数据一致性。阻塞等待，直到网络连接恢复，数据更新操作M完成后，再给用户响应最新的数据V1。这个过程，证明了要满足分区容错性的分布式系统，只能在一致性和可用性两者中，选择其中一个。</p><h4 id="CAP权衡"><a href="#CAP权衡" class="headerlink" title="CAP权衡"></a>CAP权衡</h4><p>通过CAP理论及前面的证明，我们知道无法同时满足一致性、可用性和分区容错性这三个特性，那要舍弃哪个呢？我们分三种情况来阐述一下。</p><ul><li>CA without P</li></ul><p>这种情况在分布式系统中几乎是不存在的。首先在分布式环境下，网络分区是一个自然的事实。因为分区是必然的，所以如果舍弃P，意味着要舍弃分布式系统。那也就没有必要再讨论CAP理论了。这也是为什么在前面的CAP证明中，我们以系统满足P为前提论述了无法同时满足C和A。<br>比如我们熟知的关系型数据库，如My Sql和Oracle就是保证了可用性和数据一致性，但是他并不是个分布式系统。一旦关系型数据库要考虑主备同步、集群部署等就必须要把P也考虑进来。对于一个分布式系统来说。P是一个基本要求，CAP三者中，只能在CA两者之间做权衡，并且要想尽办法提升P。</p><ul><li>CP without A</li></ul><p>如果一个分布式系统不要求强的可用性，即容许系统停机或者长时间无响应的话，就可以在CAP三者中保障CP而舍弃A。一个保证了CP而一个舍弃了A的分布式系统，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实也不少，其中最典型的就是很多分布式数据库，他们都是设计成CP的。在发生极端情况时，优先保证数据的强一致性，代价就是舍弃系统的可用性。如Redis、HBase等，还有分布式系统中常用的Zookeeper也是在CAP三者之中选择优先保证CP的。<br>无论是像Redis、HBase这种分布式存储系统，还是像Zookeeper这种分布式协调组件。数据的一致性是他们最最基本的要求。一个连数据一致性都保证不了的分布式存储要他有何用？ZooKeeper是个CP（一致性+分区容错性）的，即任何时刻对ZooKeeper的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性。但是它不能保证每次服务请求的可用性，也就是在极端环境下，ZooKeeper可能会丢弃一些请求，消费者程序需要重新请求才能获得结果。ZooKeeper是分布式协调服务，它的职责是保证数据在其管辖下的所有服务之间保持同步、一致。所以就不难理解为什么ZooKeeper被设计成CP而不是AP特性的了。</p><ul><li>AP wihtout C</li></ul><p>要高可用并允许分区，则需放弃一致性。一旦网络问题发生，节点之间可能会失去联系。为了保证高可用，需要在用户访问时可以马上得到返回，则每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。<br>这种舍弃强一致性而保证系统的分区容错性和可用性的场景和案例非常多。前面我们介绍可用性的时候说到过，很多系统在可用性方面会做很多事情来保证系统的全年可用性可以达到N个9，所以，对于很多业务系统来说，比如淘宝的购物，或者网上火车购票。都是在可用性和一致性之间舍弃了一致性而选择可用性。你在12306买票的时候肯定遇到过这种场景，当你购买的时候提示你是有票的（但是可能实际已经没票了），你也正常的去输入验证码，下单了。但是过了一会系统提示你下单失败，余票不足。这其实就是先在可用性方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，会影响一些用户体验，但是也不至于造成用户流程的严重阻塞。<br>但是，我们说很多网站牺牲了一致性，选择了可用性，这其实也不准确的。就比如上面的买票的例子，其实舍弃的只是强一致性。退而求其次保证了最终一致性。也就是说，虽然下单的瞬间，关于车票的库存可能存在数据不一致的情况，但是过了一段时间，还是要保证最终一致性的。<br>对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。</p><h3 id="2-常用的微服务框架"><a href="#2-常用的微服务框架" class="headerlink" title="2.常用的微服务框架"></a>2.常用的微服务框架</h3><p><strong>dubbo</strong></p><p>​         阿里开源的微服务框架，是一款高性能、轻量级的开源Java RPC框架，提供三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现<br>目前已经正式进入Apache孵化器<br>核心概念<br>Provider 暴露服务的服务提供方<br>Consumer 调用远程服务的服务消费方<br>Registry 服务注册与发现的注册中心<br>Monitor 统计服务的调用次数和调用时间的监控中心</p><p><strong>springcloud</strong></p><p>​              一系列框架的有序集合。利用SpringBoot简化分布式系统的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等。它将目前各家公司开发的比较成熟服务框架组合起来，通过SpringBoot风格再封装屏蔽了复杂的配置和实现原理，给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包<br><em>核心组件</em></p><p>Netflix Eureka 服务注册与发现<br>Netflix Ribbon 客户端负载均衡<br>Netflix Hystrix 服务熔断<br>Netflix Zuul 服务网关<br>Spring Cloud Config 分布式配置</p>]]></content>
      
      
      <categories>
          
          <category> springcolud教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springcolud </tag>
            
            <tag> iade </tag>
            
            <tag> javaweb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo从零开始到搭建完整</title>
      <link href="/posts/a82329f5/"/>
      <url>/posts/a82329f5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>其实平时自己写的文章并不多，偶尔看到一些东西会做点笔记，但是每次写的东西都会到处放，不好找，所以才想着自己搭建一个人博客网站，现在大家用hexo比较多，也比较方便，并且能使用的主题也很多，所以小花就用她啦~</p><p>本篇为从零开始的基础篇，其他SEO、评论系统、统计等请看<a href="http://visugar.com/2017/08/01/20170801HexoPlugins/" target="_blank" rel="noopener">Hexo博客添加SEO-评论系统-阅读统计-站长统计</a>，本篇所包含的内容如下：</p><ol><li>安装Git Bash</li><li>安装NodeJs</li><li>安装hexo</li><li>生成SSH并添加到github</li><li>部署项目</li><li>上传到github</li><li>绑定个人域名</li><li>修改及配置主题</li><li>添加RSS</li><li>添加评论</li><li>写文章部分</li></ol><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>由于小花的电脑在搭建博客之前就有了各种环境，但是对于没有任何基础的人来讲，我觉得还是从源头开始讲会好一点，就像教别人做菜，总得把所有的用料及步骤说清楚对吧？（大佬们可以自动忽略啊啊啊啊~）</p><h5 id="1-安装Git-Bash"><a href="#1-安装Git-Bash" class="headerlink" title="1.安装Git Bash"></a>1.安装Git Bash</h5><p>我一直不太喜欢在cmd中操作各种命令，所以挑了这个比较好使的<a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">Git Bash</a>, 我的是windows环境，所以下载windows版本并安装就可以了。</p><ul><li><p><a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">下载地址</a></p></li><li><p>安装步骤：双击下载好的exe文件，一路next就好啦</p></li><li><p>安装好后，打开gitbash，查看版本：</p></li><li><ul><li>命令：git      version (写这篇博客的时候最新版本：2.12.2)</li></ul></li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQoAAABZCAIAAABJxP1zAAANE0lEQVR42u2de2wUxxnAPx6hxOVRLGNj7EtISpAcSiWXxhi5gaMljUUhiGCVuHaoItTmD8ASEioSUaST2iAlsuSKEqmt6lZKnNBIpshyQKQP0oS4nEltKgXk4NJg8AOw6VkQkoKApLszu3OzszP7ulvfw99PyDrvzc7Mzn2/nW/m1smU+l+0lFd8AxAEsTEF9UAQFagHgihBPRBESUA9FoyPPNX11r2p0ztqfnhtbkmmrwJBQiGIHgW3Ptv0wZuLrvxHe32x5OGj1U8nZhdl+kIQJP341qPoxtj9t24+ePVCzZl3p9+7ox25VPLQkerNaAiSf/jTo+j61fUn2wtuf/7nb2+c9b/rjwx//PDIuen37qIhSEa4+f4r774zCAs3rtm+dpbt3SvtOz88DeWNv6qsMF7rkMJAT6x8fkMdH/yj51/9eV9J8qAPPYgbh8quXdJeD5Qufiv6Y02MZ47/gR5BQ5CJR9fjI5gzAmW7frZYCL1rf32vpRcWDs75rq4HUFuuGiIZXoEhj0lQPXg39G7NnP2nVT8anr+oqu/91f/6y/Qv7gIagkw4JMpLyytPDYEwD5C3RkvLT5+CRoUeH5WWw6mhkarHXnp2gXGSVY++1z3psWB85MlTHeVjF/mD8UdXXype9OWUacXjw8s+6Z13MzHti3sXS75+rOop3MtCJgaqx2O7Ss+19FonkDOnXzg6e9e6T1t+o9bjW2u2QE9Lx41kisXrob/2pMfznS3a7CEcjD+66tP751T+u/tQdOvnMwrW9h5d9kmP3onCstZ1OzM9bsikwNDjpWehfee54hdXrypOHh9dt6EOTr/gqIe5CDFTLE4PPTfr8KTHT4/8cv74FeGgrkfBnO/1Hu2oeabvgWVre45UffyBdnzsayW/Xb8r0+OGTAqYHgv6Xu9sAzNNOmNaccZVj1lUCSPF4vTQK7zsSY/i8cu1H3ZERgf4g5oeNwrmfv+fnde/Ou+/c4vKxga/cufW0PwH36naeGXewkyPGzIpSOpBInt4GZlAtMg+XkpC34sedBFPU6xi6+zR631pPvqD+CG2/Lh938yOmi23Z8zc/F5bwe3P6MHhogfeXrkZFx7IhMHpwSL+m1eYJx71MDeyyhtfnH2crT30c31t7CYN0eaHN5/4yd2pU+v/9vsIOYJuIBMPr4chQ2XV0Gl7lqX/4qCHseoYicxZOHjD3LnSyvj9WtAw5O70+3ofWXFv6rTl/fEZd26jG0hGsOphTAJznmRrdO96mCmW9oLbyPL/UIk1ywKcN5DMIehBFwzcDm9SD8m35oIe7LvCykDfmjM0Q9bFD9GcSluLH6l+Gt1A8pKAD7SXJC5v/Mcfp3wJHd/ZgvtUSL6Cfw6FIEpQDwRRgnogiBLUA0GUoB4IogT1QBAlqAeCKEE9EESJkx7jI0OZ7h6CZBIXPX6387lM9xBBMgbqgSBKUA8EUYJ6IIgS1ANBlKAeCKIE9UAQJagHgihBPRBECeqBIEpQDwRRgnogiBLUA0GUoB4IosSnHssBNgDEUm42XfXkDssboaIP2nrEcYhtgM4Y9HgsbyNSC9uqId4Kxwady0HTNkh0ulfot7zHfnqvvzEGi83X7tcVMjmrRwRgG0ArAD98TQCF5EUCYH+4A+e3t02b4PB+ED9rlR6q8vaKM6uH5376rp8U6Ec9fNMIydsLr4fmRj/AMbPMNfK6FqBaUczeOn+kifzkHaNCUuJmQx4vV3WLVegR8JZs9lMSWOHoEbyfqIcTqdQTIbFOa2Bxr2lQBNBmHtc4T34FokqhGeisGIOXim+CmsDqp0c6wQjkmB9DHG6xUj0C35LZ6ROjRyr9zCs9WNISJzfjmFmCHQfzoBBGjeRnm618ivWATQ+thsPkxTZSg/ZuBVc+Rlockzkp1aOW/CwypyB7B2qt/XdEy382aXpyTdQ2QTW53ngcqqtFPRzKn49DYbURNHyOzmrgD1IScVKVGY7XasyqaGhaw1SbDfQRapOUt+dvfD/1HG8JxBNQvVgvqb2hnWW8SJAKubO0kq2HYZNz/TI92Djwl6wan7TgQQ/+7kvjOGa+BvM4K+MQ1umqhyLoESP/aFgfs+nBphRhrQIKPWKkZDGnU8w6XUhXPgq0kO3jPks9BAuhldx06ecq6OFa3hJJ9vlHPXsUmlbQFYt+lqMehWbU8n2Q9pNWqFXeVwE1hdB/WBdjST/sHxO7p52lfaxto271265Cv3YwyvDlXcYnNTzoEePClCVFQnywaB5Vh3W66gGuBpUe9vK8nDx2PXi1WJ/5zoPNXjX2qcCID3MchOjxUj6wHhA3a2Znuc0eqnaFfhpzwn4oNmvQIlXX41jyBV9s0K1+8Spkv9LTXcYnNdz0eOU5S/iysBaik0WSKqwFDQLXw7Drob1eSl5rSVQN2bzic6ElRA/7gsGuh9ZWn63dWMDZQ5gKxI95ueTm6lo+sB4Ju5ZB9RD66aAH30PtYFGXJKlz10PWATYLOY1PanjTI/Bdv8kMU+F2G7gehqAH26qKkZJdZjbFN1FsUxFkesRsAxELuPawTwXKMPVTPjw99OQkIdEjmYwp+umkB5ivtUSrxsygHOuXXIVq9hh1G5/U8JBcCSEOjmsG4G60dAeW7SClqx4zLCyxLugXse7kdnGzgZBiCXoIixaQzWa0LQ87V7Vkw0D4qIQQLORWmS7lzZW3ix5CPgbGgKi01AoXkqRLnzrIOCf7dt5ol++DtJ/OetDmEglIdJkdcKyfFfCy9nAZn9TwoAeLZnZXjnGxJew4gXlnBRJM5H95aERbuuphBRgJzijhiH3aiZnv2uuJWV2iCLsFFC+7ulpMVFg/cjDGgVqhdaO1C7ax4HYtr41EJ2wQZJDpQW/GBueVyRI9ixWmC2s+ueonG2t0PJPrZlk/XfSggctX4lA/X8DLzpXz+KQGPnMVFtKpINXy6odQsva6KJIJLQzSPT6oRziopgL/5SMRGOQTjISfajN+XfQS2IZVCD0KdXxQj2zHkiklwgqykDDWMxDijBfq+HjXY/3Lbyx6reHA2dTaW7rjjVfroH17yhWFTK70EwkVT3qQWCkzjnY3R/e8Hbi9XAm7XOknEioe9Fj/8t93l7dvPxjZm4bZQ4IeiStPYiAi2Ye7Hmb0DmxNR3IlAfVAshUPswfJM4aam6Heox7JXKy7vb28bmVDtAHIHLTCKMDyM/6gwbBjQmNTST9woCEqNsyaMDofPfG40VIyN7Q0zpqV9tNWvVj/9sF685JTyj2R7MLb0pzGzLCnVNzIxfSSNJ6Go7oe/NtgCSF/s4d2fv0gK6yfG2mI7oGkCHrNtA/RhgMspGnUascfP0HbtvfDfhn8+5bFiKp+vg9IHuB558qIA1dFrGFF4iitelAjDrJ7917Yx0WsWQtpJappo1xiu629hX4KnSRnN0SjYjVu0iG5hR89tg4chN1cDMoQwigEPTg/uJnEsrlGIbOW8/2cnWVPiYR+Wu2jv+8x9Riy3A5Qj/zBnx4NWgrPpTYSJOGSbj1YgjWwlaVK9viV90fdZ3Ei8TN7oB75irse63fsuHDgwFk2e4CHWOOWACvAbe0RIKaIH+1DdZETybNIY7ZZQKWHcVXqDvhZe6Ae+Yq3jV2WtnhZnXMbV83Nuk9RsnQ2kAWQ/68d5SsHa4blmFxZ98wklyXpp8POFeqRn/hMrvx+7myJjCA5SPofSVy6dOnZs1yGjvucSM4Sgh5+kzEEyVZS1SNXHt3LlX7mOnk2zqhHGhvwuj2d3Bfw9giK3/IZJC3jnD3XG8KfQ02yRwy5PTBPqSS3ueVpbcYNZ26ObICnIrLmelGPFDF3IhRfS9qwP3TjvBHst3z24fuZuiy6Xi96TPQTuOxALj2BG1wPx7Mk39Y7hRp9v32orm6FNgL7YK/+SCj3XaYwPpLpK9mCfDzBHg+20sHjwe/1ho2Hb80n/Ancg7bMI9mHMJ/AtdfvY2faqx58u0Zj3S7d5qp16xCtsZvcPurLu0/ue00zhHwYD8nHRxwW9rtyPO3xYLnqFOPB5/WGjaseh7LnCVy9lTCfwNU/hgtBn8D1qgdw99Th9uaTK3c7jlUAPSw2XDAPgGJ8bNM1l/fLyrvNfpNLj1/3ZM8TuO3mpxzSE7hmOAV6SMSHHn7OCpRcyfQ4qxyf5DXydyrFeMqeyE6nHjmWXOl6TJYncIcmXA8PJ/lbqrroIR+f5J9Lyx/HtuWDQ+HNHrm2NG+ePE/gSharKeohS86tp1ivUFbeaaPTVl6px8Aap/EhnR8eLhtiU4dyPCVPZLvo4TCIfq93wvH6t+bZ8ASuU3KVsSdwJZszyeZVH7/YqvU9W++VX5P50GOr4/iQFoaFZFNR3hYPlj75ige/1zvh+PzeA5/AzU+CJjGZTn7CxsPfe+ATuPmOv8XzZIqHEP4cCskdzDTGRxIzqeIB/xPUCKIE9UAQJagHgihBPRBEyf8Bz3wWXc9CKxgAAAAASUVORK5CYII=" alt="git version"></p><ul><li>然后你就可以在这里发挥你的聪明才智了</li></ul><h5 id="2-安装NodeJs"><a href="#2-安装NodeJs" class="headerlink" title="2.安装NodeJs"></a>2.安装NodeJs</h5><p>Hexo是基于nodeJS环境的静态博客，里面的npm工具很有用啊，所以还是老老实实把这玩意儿装了吧</p><ul><li><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">下载地址</a>(说明：LTS为长期支持版，Current为当前最新版)</p></li><li><p>安装步骤：反正下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add     to PATH ,这样你就不用自己去配置电脑上环境变量了，装完在按 win     + r 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量），没有的话你就自由发挥吧。</p></li><li><p>查看版本：</p></li><li><ul><li>命令：node      -v</li></ul></li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="data:image/png;base64,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" alt="node-version"></p><ul><li>又到自由发挥的时候了</li></ul><h5 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h5><p>看到这么多安装，千万不要紧张，小哥哥小姐姐们一定要稳住，别怕，因为后面的东西都是在gitbash中用npm工具安装就好了。</p><ul><li>先创建一个文件夹（用来存放所有blog的东西），然后cd到该文件夹下。</li><li>安装hexo命令：npm i -g hexo</li><li>安装完成后，查看版本：</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="data:image/png;base64,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" alt="npm-v"></p><ul><li>初始化命令：hexo init ，初始化完成之后打开所在的文件夹可以看到以下文件：</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="data:image/png;base64,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" alt="myblog"></p><ul><li><p>解释一下：</p></li><li><ul><li>node_modules：是依赖包</li><li>public：存放的是生成的页面</li><li>scaffolds：命令生成文章等的模板</li><li>source：用命令创建的各种文章</li><li>themes：主题</li><li>_config.yml：整个博客的配置</li><li>db.json：source解析所得到的</li><li>package.json：项目所需模块项目的配置信息</li></ul></li><li><p>做好这些前置工作之后接下来的就是各种配配配置了。</p></li></ul><h5 id="4-搭桥到github"><a href="#4-搭桥到github" class="headerlink" title="4.搭桥到github"></a>4.搭桥到github</h5><ul><li><p>没账号的创建账号，有账号的看下面。</p></li><li><ul><li>创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建才有用哦，如下：</li></ul></li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="data:image/png;base64,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" alt="new-repo"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="data:image/png;base64,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" alt="create-repo"></p><ul><li>回到gitbash中，配置github账户信息（YourName和YourEail都替换成你自己的）：</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="data:image/png;base64,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" alt="username"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="data:image/png;base64,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" alt="email"></p><ul><li>创建SSH<pre><code>在gitbash中输入：ssh-keygen     -t rsa -C &quot;youremail@example.com，生成ssh。然后按下图的方式找到id_rsa.pub文件的内容。</code></pre></li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="data:image/png;base64,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" alt="ssh-key"></p><ul><li>将上面获取的ssh放到github中：</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="data:image/png;base64,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" alt="settings"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="data:image/png;base64,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" alt="ssh-key"></p><p>添加一个 New SSH key ，title随便取，key就填刚刚那一段。</p><ul><li>在gitbash中验证是否添加成功：ssh     -T <a href="mailto:git@github.com">git@github.com</a></li><li>完成下一步你就成功啦！</li></ul><h5 id="5-一步之遥"><a href="#5-一步之遥" class="headerlink" title="5.一步之遥"></a>5.一步之遥</h5><ul><li>用编辑器打开你的blog项目，修改_config.yml文件的一些配置(冒号之后都是有一个半角空格的)：</li></ul><p>deploy:<br>  type: git<br>  repo: <a href="https://github.com/YourgithubName/YourgithubName.github.io.git" target="_blank" rel="noopener">https://github.com/YourgithubName/YourgithubName.github.io.git</a><br>  branch: master</p><ul><li>回到gitbash中，进入你的blog目录，分别执行以下命令：</li></ul><p>hexo clean<br> hexo generate<br> hexo server</p><p>注：hexo 3.0把服务器独立成个别模块，需要单独安装：npm i hexo-server。</p><ul><li>打开浏览器输入：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></li><li>接着你就可以遇见天使的微笑了~</li></ul><h5 id="6-上传到github"><a href="#6-上传到github" class="headerlink" title="6.上传到github"></a>6.上传到github</h5><ul><li>先安装一波：npm     install hexo-deployer-git –save（这样才能将你写好的文章部署到github服务器上并让别人浏览到）</li><li>执行命令(建议每次都按照如下步骤部署)：</li></ul><p>hexo clean<br> hexo generate<br> hexo deploy</p><p>注意deploy的过程中要输入你的username及passward。如下：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="data:image/png;base64,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" alt="deploy"></p><ul><li>在浏览器中输入<a href="http://yourgithubname.github.io就可以看到你的个人博客啦，是不是很兴奋！" target="_blank" rel="noopener">http://yourgithubname.github.io就可以看到你的个人博客啦，是不是很兴奋！</a></li><li>感觉gitbash中东西太多的时候输入clear命令清空。</li></ul><h5 id="7-绑定个人域名"><a href="#7-绑定个人域名" class="headerlink" title="7.绑定个人域名"></a>7.绑定个人域名</h5><ul><li>不想绑定的自行忽略</li><li>第一步购买域名：随便在哪个网站买一个就好了，小花是在阿里云购买的<a href="http://visugar.com/" target="_blank" rel="noopener">visugar.com</a>, DNS也是顺道在那买的。</li><li>第二步添加CNAME：在项目的source文件夹下新建一个名为CNAME的文件，在里面添加你购买的域名，比如我添加的是visugar.com，只能添加一个哦。</li><li>到DNS中添加一条记录：</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="data:image/png;base64,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" alt="dns-note"></p><p>其中ip地址为你的github的地址，可在cmd中ping一下就能看到(ping yourname.github.io)：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="data:image/png;base64,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" alt="github-ip"></p><ul><li>接着再次部署一下，用你购买的域名打开，就可以看到你的博客啦~</li></ul><h5 id="8-修改及配置主题"><a href="#8-修改及配置主题" class="headerlink" title="8.修改及配置主题"></a>8.修改及配置主题</h5><ul><li>hexo初始化之后默认的主题是landscape , 然后你可以去<a href="https://hexo.io/themes/" target="_blank" rel="noopener">这个地址</a>里面找到你想要的主题。在github中搜索你要的主题名称，里面都会有该主题的如何使用的介绍，按着来就好了，反正就是改改改！我选的是hueman,看起来挺不错，至少是我喜欢的类型。</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="data:image/png;base64,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" alt="themes"></p><ul><li>跟该主题相关的配置在themes/hueman/_config.yml里面,然后根据你的需要在这配配配就行了。</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="data:image/png;base64,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" alt="themes-config"></p><ul><li><p>有的东西我也不知道是啥玩意儿，你要多试多倒腾几次，就能意会啦</p></li><li><p>下面是针对我所选的主题的两小点(别的主题我没看，可能也是类似):</p><pre><code>**在导航栏添加点东西**</code></pre></li><li><ul><li>例如我添加了一个更新日志的模块。</li><li>在主题的配置文件中，menu添加一栏：Board:      /board。</li><li>然后在source中添加一个board，即对应上面的名字。然后再创建一个index.md，里面可以写你想写的内容。</li><li>在主题的hueman/langulages/zh-CN.yml中的index适当的位置加：board:      ‘更新日志’，位置和名字是你自己设定。</li><li>重新部署，然后就OK了<pre><code>**在侧边栏添加点东西**</code></pre></li><li>回到你的主题的配置文件中，找到widgets一栏，在你要添加的位置处添加一条你自定义的名称。例如我的叫communiation且放在了第二行。</li><li>在上面所提到的zh-CN.yml文件中找到sidebar一栏，添加communiation:      ‘你要设的名称’。</li><li>在hueman/layout/widget中添加一个communiation.ejs,填入模板<pre><code>&lt;% if (site.posts.length) { %&gt;  &lt;div class=&quot;widget-wrap      widget-list&quot;&gt;    &lt;h3 class=&quot;widget-title&quot;&gt;&lt;%= __(&apos;sidebar.communiation&apos;)      %&gt;&lt;/h3&gt;    &lt;div class=&quot;widget&quot;&gt;      &lt;!--这里添加你要写的内容--&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;% } %&gt;</code></pre></li></ul></li></ul><h5 id="9-添加RSS"><a href="#9-添加RSS" class="headerlink" title="9.添加RSS"></a>9.添加RSS</h5><ul><li>先安装rss相关插件：npm     i hexo-generator-feed</li><li>在你的项目的_config.yml配置文件下找到Extensions添加如下内容：<pre><code>\# Extensions #插件和主题 ## Plugins: https://hexo.io/plugins/     ## Themes: https://hexo.io/themes/     #RSS订阅 plugin: - hexo-generator-feed     #Feed Atom feed: type: atom path: atom.xml limit: 20</code></pre></li><li>进入到你的主题的配置文件下，找到你的放rss的位置，添加/atom.xml即可。</li><li>重新部署再打开就能看到效果啦~</li></ul><h5 id="10-添加评论"><a href="#10-添加评论" class="headerlink" title="10.添加评论"></a>10.添加评论</h5><p><strong>20170812**</strong>更新：**</p><p>云更贴已在2017年8月1日停止服务，具体评论系统文章统计站长统计及百度SEO谷歌SEO什么的可参考<a href="http://visugar.com/2017/08/01/20170801HexoPlugins/" target="_blank" rel="noopener">Hexo博客添加SEO-评论系统-阅读统计-站长统计</a></p><p>-—-</p><p>此段已失效。</p><ul><li>先选一个你要使用的第三方评论系统，最好找个靠谱点的（我使用的是网易云跟帖）。</li><li>在主题的配置文件下找到comment，添加一行，例如我添加的是yungentie:     此处自由发挥</li><li>注册完评论系统后获取相应的代码，然后在主题的layout下找到comment新建一个ejs模板文件，名称自定义。</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="data:image/png;base64,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" alt="yungentie"></p><ul><li>找到你的article.ejs模板文件，加上&lt;%-     partial(‘comment/你刚刚取得名字’)     %&gt;保存。</li><li>重新部署，OK啦</li></ul><h5 id="11-写文章部分"><a href="#11-写文章部分" class="headerlink" title="11.写文章部分"></a>11.写文章部分</h5><ul><li>新建文章：hexo     new ‘文章名’，然后你就可以在source/_posts路径下看到你创建的文章啦，编辑完成之后按照前面说的方式部署，在浏览器刷新就能看到你的文章了。</li><li>关于具体的文章编辑你可以看下<a href="https://hexo.io/zh-cn/docs/writing.html" target="_blank" rel="noopener">官网的介绍</a></li><li>至于markdown，可以自行发挥啦~</li></ul><p>More info: <a href="https://hexo.io" target="_blank" rel="noopener">hexo</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> git </tag>
            
            <tag> nodejs </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
